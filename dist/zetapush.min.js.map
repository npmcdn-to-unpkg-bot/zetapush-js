{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///zetapush.min.js","webpack:///webpack/bootstrap ece421f4a66eb3981f62","webpack:///./~/whatwg-fetch/fetch.js","webpack:///./lib/index.js","webpack:///./lib/authentication/handshake.js","webpack:///./lib/services/index.js","webpack:///./lib/connection/connection-status.js","webpack:///./lib/connection/cometd.js","webpack:///./~/zetapush-cometd/index.js","webpack:///./~/zetapush-cometd/lib/CallbackPollingTransport.js","webpack:///./~/zetapush-cometd/lib/Transport.js","webpack:///./~/zetapush-cometd/lib/Utils.js","webpack:///./~/zetapush-cometd/lib/RequestTransport.js","webpack:///./~/zetapush-cometd/lib/CometD.js","webpack:///./~/zetapush-cometd/lib/TransportRegistry.js","webpack:///./~/zetapush-cometd/lib/LongPollingTransport.js","webpack:///./~/zetapush-cometd/lib/WebSocketTransport.js","webpack:///./lib/client.js","webpack:///./lib/utils/index.js","webpack:///./lib/client-helper.js","webpack:///./lib/weak-client.js","webpack:///./lib/utils/token-persistence.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","self","normalizeName","name","String","test","TypeError","toLowerCase","normalizeValue","value","iteratorFor","items","iterator","next","shift","done","undefined","support","iterable","Symbol","Headers","headers","map","forEach","append","Object","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","Blob","prototype","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","toString","arrayBuffer","ArrayBuffer","Error","get","set","type","rejected","then","text","decode","json","JSON","parse","normalizeMethod","method","upcased","toUpperCase","methods","indexOf","Request","input","options","url","credentials","mode","referrer","form","trim","split","bytes","replace","join","decodeURIComponent","xhr","head","pairs","getAllResponseHeaders","header","key","Response","bodyInit","status","ok","statusText","fetch","e","list","push","values","getAll","has","hasOwnProperty","callback","thisArg","keys","entries","clone","response","redirectStatuses","redirect","RangeError","location","init","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill","_interopRequireWildcard","obj","__esModule","newObj","defineProperty","VERSION","services","WeakClient","Client","TransportTypes","ConnectionStatusListener","Authentication","_handshake","enumerable","_connectionStatus","_cometd","_client","_weakClient","_index","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","CredentialsHandshake","TokenHandshake","AbstractHandshake","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_services","DeployableNames","AUTH_SIMPLE","AUTH_WEAK","AUTH_DELEGATING","_ref","authType","sandboxId","deploymentId","client","authentication","data","authData","getSandboxId","version","authVersion","getResource","resource","ext","_AbstractHandshake","_ref2","token","_this","getPrototypeOf","_AbstractHandshake2","_ref3","login","password","_this2","_ref4","_ref4$deploymentId","Simple","DEFAULT_DEPLOYMENT_ID","_ref5","_ref5$deploymentId","Weak","_ref6","_ref6$deploymentId","Delegating","_ref7","_objectDestructuringEmpty","Service","$publish","Remoting","Aggreg","_Service","apply","arguments","owner","Stack","_Service2","stack","page","guids","_ref8","listeners","_ref9","guid","Echo","_Service3","_ref10","GameEngine","_Service4","_ref11","callerId","msgId","payload","_ref12","_ref13","gameInfo","maxGames","_ref14","gameId","_ref15","_ref16","Game","_Service5","_ref17","_ref18","role","userId","userName","_ref19","_ref20","_ref21","_ref22","Gda","_Service6","_ref23","table","_ref24","column","key2","_ref25","_ref26","columns","_ref27","_ref28","rows","_ref29","start","stop","_ref30","_ref31","_ref32","_ref33","_ref34","_Service7","_ref35","cmd","from","fromResource","_ref36","answeringResource","askingResource","_capabilities","capabilities","_ref37","_ref38","_ref39","_ref40","action","_ref41","available","uid","user","_ref42","Search","GroupManagement","_Service8","_ref43","group","_ref44","_ref45","users","_ref46","_ref47","groupName","_ref48","_ref49","_ref50","_ref51","_ref52","_ref53","_ref54","_ref55","_ref56","_ref57","hardFail","_ref58","actions","_ref59","_ref60","_ref61","Httpclient","_Service9","_ref62","requestId","_ref63","Macro","_Service10","_ref64","debug","parameters","_ref65","_ref66","Sendmail","_Service11","_ref67","Messaging","_Service12","_ref68","channel","Queue","_Service13","_ref69","description","originBusinessId","originDeploymentId","_ref70","success","taskId","_ref71","capacity","_ref72","_ref73","Sms_ovh","_Service14","_ref74","Cron","_Service15","_ref75","_ref76","_ref77","cronName","_Service16","_ref78","index","_ref79","_ref80","_ref81","indices","query","sort","Template","_Service17","_ref82","languageTag","Zpfs_s3","_Service18","_ref83","oldPath","path","_ref84","_ref85","_ref86","_ref87","folder","_ref88","parents","_ref89","_ref90","metadata","tags","_ref91","contentType","_ref92","_ref93","_ref94","metadataFiles","Zpfs_hdfs","_Service19","_ref95","_ref96","_ref97","_ref98","_ref99","_ref100","_ref101","_ref102","_ref103","_ref104","_ref105","_ref106","Zpfs_s3compat","_Service20","_ref107","_ref108","_ref109","_ref110","_ref111","_ref112","_ref113","_ref114","_ref115","_ref116","_ref117","_ref118","Userdir","_Service21","_ref119","_ref120","userKeys","_Service22","_ref121","_Service23","_ref122","_ref123","_ref124","_ref125","_ref126","_ref127","_Service24","_ref128","fullRights","publicToken","_ref129","FetchLongPollingTransport","_super","_zetapushCometd","LongPollingTransport","that","Transport","derive","xhrSend","packet","assign","Content-Type","onSuccess","onError","TransportLayers","LONG_POLLING","WEBSOCKET","WebSocketTransport","CallbackPollingTransport","CometD","RequestTransport","TransportRegistry","Utils","_failTransportFn","envelope","x","transportFailure","_self","accept","crossDomain","jsonpSend","transportSend","messages","lengths","stringify","slice","urlLength","encodeURI","maxLength","getConfiguration","maxURILength","getType","setTimeout","envelopeToSend","begin","end","_debug","_mixin","onFailure","nextEnvelope","metaConnect","sameStack","transport","sync","requestHeaders","responses","received","convertToMessages","httpCode","transportSuccess","exception","reason","failure","xx","_type","_url","registered","cometd","unregistered","getAdvice","funktion","delay","clearTimeout","handle","isString","isArray","getURL","setURL","reset","abort","baseObject","F","Array","inArray","element","array","timeoutHandle","_coalesceEnvelopes","_envelopes","envelopeAndRequest","newEnvelope","newRequest","concat","_transportSend","expired","maxDelay","maxNetworkDelay","timeout","errorMessage","xhrStatus","abortXHR","complete","_queueSend","_requestIds","_requests","maxConnections","_metaConnectComplete","_metaConnectRequest","_complete","splice","nextRequest","autoBatch","_metaConnectSend","state","readyState","UNSENT","_fieldValue","object","_isString","_isFunction","_zeroPad","Math","pow","_log","level","args","console","logger","now","Date","getHours","getMinutes","getSeconds","getMilliseconds","_splitURL","exec","_configure","configuration","_config","urlParts","hostAndPort","uri","afterURI","_crossDomain","_isCrossDomain","appendMessageTypeToURL","_info","uriSegments","lastSegmentIndex","match","_removeListener","subscription","subscriptions","_listeners","listener","_removeSubscription","_clearSubscriptions","_setStatus","newStatus","_status","_isDisconnected","_nextMessageId","_messageId","_applyExtension","scope","message","outgoing","handler","onExtensionException","_applyIncomingExtensions","_extensions","reverseIncomingExtensions","extension","incoming","_applyOutgoingExtensions","_notify","onListenerException","_notifyListeners","channelParts","last","channelPart","_cancelDelayedSend","_scheduledSend","_delayedSend","operation","time","_advice","interval","_backoff","_send","extraPath","messageId","_clientId","clientId","_callbacks","rcvdMessages","_handleMessages","conduit","getTransport","connectionType","_handleFailure","_transport","_batch","_internalBatch","_messageQueue","_resetBackoff","_increaseBackoff","maxBackoff","backoffIncrement","_startBatch","_flushBatch","_endBatch","_connect","bayeuxMessage","_connected","advice","_delayedConnect","_updateAdvice","newAdvice","_disconnect","_notifyTransportFailure","oldTransport","newTransport","onTransportException","handshakeProps","handshakeCallback","_transports","reconnect","_handshakeProps","_handshakeCallback","transportTypes","findTransportTypes","minimumVersion","supportedConnectionTypes","_putCallback","negotiateTransport","getTransportTypes","_warn","_delayedHandshake","_notifyCallback","onCallbackException","_handleCallback","_getCallback","_handleRemoteCall","context","_remoteCalls","_failHandshake","retry","_handshakeResponse","successful","reestablish","_reestablish","_handshakeFailure","_failConnect","_connectResponse","_connectFailure","_failDisconnect","_disconnectResponse","_disconnectFailure","_failSubscribe","_subscribeResponse","_subscribeFailure","_failUnsubscribe","_unsubscribeResponse","_unsubscribeFailure","_failMessage","_messageResponse","_handshakeMessages","_messageFailure","_receive","_unconnectTime","_hasSubscriptions","_resolveScopedCallback","delegate","_addListener","isListener","_name","protocol","stickyReconnect","connectTimeout","logLevel","urls","maxInterval","deep","objects","propName","prop","targ","source","window","host","receive","failureMessage","registerTransport","add","unregisterTransport","remove","unregisterTransports","clear","findTransport","find","getTransportRegistry","configure","handshake","disconnect","disconnectProps","disconnectCallback","startBatch","endBatch","batch","addListener","removeListener","clearListeners","subscribe","subscribeProps","subscribeCallback","unsubscribe","unsubscribeProps","unsubscribeCallback","resubscribe","clearSubscriptions","publish","content","publishProps","publishCallback","remoteCall","getStatus","isDisconnected","setBackoffIncrement","period","getBackoffIncrement","getBackoffPeriod","increaseBackoffPeriod","resetBackoffPeriod","setLogLevel","registerExtension","existing","existingExtension","unregisterExtension","getExtension","getName","getClientId","_types","types","j","_supportsCrossDomain","_forceClose","event","webSocketClose","code","onClose","_sameContext","_connecting","_context","_storeEnvelope","messageIds","envelopes","_websocketConnect","webSocket","WebSocket","_webSocketSupported","_stickyReconnect","connectTimer","onopen","_webSocketConnected","onOpen","onclose","onmessage","wsMessage","onMessage","_webSocketSend","timeouts","_successCallback","_notifySuccess","fn","_notifyFailure","close","removed","ids","websocketCode","websocketEnabled","_defineProperty","_clientHelper","_ref$apiUrl","apiUrl","API_URL","_ref$forceHttps","forceHttps","isHttpsProtocol","transports","helper","ClientHelper","isConnected","connect","getUserId","service","$subscriptions","_ref2$deploymentId","createService","setResource","addConnectionStatusListener","removeConnectionStatusListener","UNSECURE_PATTERN","getSecureUrl","shuffle","floor","random","getServers","secureApiUrl","servers","server","derived","parent","is","Message","RECONNECT_HANDSHAKE_VALUE","RECONNECT_NONE_VALUE","RECONNECT_RETRY_VALUE","AllTransports","_ref$resource","_ref$transports","connectionListeners","connected","wasConnected","serverUrl","subscribeQueue","filter","includes","updateServerUrl","_ext$authentication","initialized","handshakeFailure","authenticationFailed","negotiate","connectionWillClose","prefix","connectionEstablished","connectionBroken","connectionClosed","getHandshakeFields","enabled","onConnectionEstablished","onConnectionBroken","onMessageLost","onConnectionWillClose","onConnectionClosed","onSuccessfulHandshake","onFailedHandshake","_this3","_getQueuedSubscriptio","getQueuedSubscription","queued","_getQueuedSubscriptio2","findIndex","_this4","_this5","isMacroType","getMacroPublisher","getServicePublisher","_tokenPersistence","_Client","getToken","weak","strategy","LocalStorageTokenPersistenceStrategy","ZETAPUSH_TOKEN_KEY","AbstractTokenPersistenceStrategy","_ref$key","_AbstractTokenPersist","localStorage","getItem","setItem"],"mappings":"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","file":"zetapush.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ZetaPush\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZetaPush\"] = factory();\n\telse\n\t\troot[\"ZetaPush\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ZetaPush\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZetaPush\"] = factory();\n\telse\n\t\troot[\"ZetaPush\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.VERSION = exports.services = exports.WeakClient = exports.Client = exports.TransportTypes = exports.ConnectionStatusListener = exports.Authentication = undefined;\n\t\n\tvar _handshake = __webpack_require__(3);\n\t\n\tObject.defineProperty(exports, 'Authentication', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _handshake.Authentication;\n\t  }\n\t});\n\t\n\tvar _connectionStatus = __webpack_require__(5);\n\t\n\tObject.defineProperty(exports, 'ConnectionStatusListener', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _connectionStatus.ConnectionStatusListener;\n\t  }\n\t});\n\t\n\tvar _cometd = __webpack_require__(6);\n\t\n\tObject.defineProperty(exports, 'TransportTypes', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _cometd.TransportTypes;\n\t  }\n\t});\n\t\n\tvar _client = __webpack_require__(16);\n\t\n\tObject.defineProperty(exports, 'Client', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _client.Client;\n\t  }\n\t});\n\t\n\tvar _weakClient = __webpack_require__(19);\n\t\n\tObject.defineProperty(exports, 'WeakClient', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _weakClient.WeakClient;\n\t  }\n\t});\n\t\n\tvar _index = __webpack_require__(4);\n\t\n\tvar services = _interopRequireWildcard(_index);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\texports.services = services;\n\t\n\t/**\n\t * SDK Version\n\t * @type {string}\n\t */\n\t\n\tvar VERSION = exports.VERSION = '2.0.0-rc.2';\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Authentication = exports.CredentialsHandshake = exports.TokenHandshake = exports.AbstractHandshake = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _services = __webpack_require__(4);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * ZetaPush deployables names\n\t */\n\tvar DeployableNames = {\n\t  AUTH_SIMPLE: 'simple',\n\t  AUTH_WEAK: 'weak',\n\t  AUTH_DELEGATING: 'delegating'\n\t};\n\t\n\t/**\n\t * Provide abstraction over CometD handshake data structure\n\t * @access public\n\t */\n\t\n\tvar AbstractHandshake = exports.AbstractHandshake = function () {\n\t  /**\n\t   * Create a new handshake manager\n\t   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters\n\t   */\n\t\n\t  function AbstractHandshake(_ref) {\n\t    var authType = _ref.authType;\n\t    var sandboxId = _ref.sandboxId;\n\t    var deploymentId = _ref.deploymentId;\n\t\n\t    _classCallCheck(this, AbstractHandshake);\n\t\n\t    /**\n\t     * @access protected\n\t     * @type {string}\n\t     */\n\t    this.authType = authType;\n\t    /**\n\t     * @access protected\n\t     * @type {string}\n\t     */\n\t    this.sandboxId = sandboxId;\n\t    /**\n\t     * @access protected\n\t     * @type {string}\n\t     */\n\t    this.deploymentId = deploymentId;\n\t  }\n\t  /**\n\t   * @param {ClientHelper} client\n\t   * @return {Object}\n\t   */\n\t\n\t\n\t  _createClass(AbstractHandshake, [{\n\t    key: 'getHandshakeFields',\n\t    value: function getHandshakeFields(client) {\n\t      var authentication = {\n\t        data: this.authData,\n\t        type: client.getSandboxId() + '.' + this.deploymentId + '.' + this.authType,\n\t        version: this.authVersion\n\t      };\n\t      if (client.getResource()) {\n\t        authentication.resource = client.getResource();\n\t      }\n\t      return {\n\t        ext: {\n\t          authentication: authentication\n\t        }\n\t      };\n\t    }\n\t    /**\n\t     * Get auth version\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'authVersion',\n\t    get: function get() {\n\t      return 'none';\n\t    }\n\t  }]);\n\t\n\t  return AbstractHandshake;\n\t}();\n\t\n\t/**\n\t * Provide abstraction over CometD token base handshake data structure\n\t * @access public\n\t * @extends {AbstractHandshake}\n\t */\n\t\n\t\n\tvar TokenHandshake = exports.TokenHandshake = function (_AbstractHandshake) {\n\t  _inherits(TokenHandshake, _AbstractHandshake);\n\t\n\t  /**\n\t   * @param {{authType: string, deploymentId: string, token: string}} parameters\n\t   */\n\t\n\t  function TokenHandshake(_ref2) {\n\t    var authType = _ref2.authType;\n\t    var deploymentId = _ref2.deploymentId;\n\t    var token = _ref2.token;\n\t\n\t    _classCallCheck(this, TokenHandshake);\n\t\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TokenHandshake).call(this, { deploymentId: deploymentId, authType: authType }));\n\t\n\t    _this.token = token;\n\t    return _this;\n\t  }\n\t  /**\n\t   * @return {token: string}\n\t   */\n\t\n\t\n\t  _createClass(TokenHandshake, [{\n\t    key: 'authData',\n\t    get: function get() {\n\t      var token = this.token;\n\t\n\t      return {\n\t        token: token\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return TokenHandshake;\n\t}(AbstractHandshake);\n\t\n\t/**\n\t * Provide abstraction over CometD credentials based handshake data structure\n\t * @access public\n\t * @extends {AbstractHandshake}\n\t */\n\t\n\t\n\tvar CredentialsHandshake = exports.CredentialsHandshake = function (_AbstractHandshake2) {\n\t  _inherits(CredentialsHandshake, _AbstractHandshake2);\n\t\n\t  /**\n\t   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n\t   */\n\t\n\t  function CredentialsHandshake(_ref3) {\n\t    var authType = _ref3.authType;\n\t    var deploymentId = _ref3.deploymentId;\n\t    var login = _ref3.login;\n\t    var password = _ref3.password;\n\t\n\t    _classCallCheck(this, CredentialsHandshake);\n\t\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t\n\t    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(CredentialsHandshake).call(this, { authType: authType, deploymentId: deploymentId }));\n\t\n\t    _this2.login = login;\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t    _this2.password = password;\n\t    return _this2;\n\t  }\n\t  /**\n\t   * Get auth data\n\t   * @return {login: string, password: string}\n\t   */\n\t\n\t\n\t  _createClass(CredentialsHandshake, [{\n\t    key: 'authData',\n\t    get: function get() {\n\t      var login = this.login;\n\t      var password = this.password;\n\t\n\t      return {\n\t        login: login, password: password\n\t      };\n\t    }\n\t  }]);\n\t\n\t  return CredentialsHandshake;\n\t}(AbstractHandshake);\n\t\n\t/**\n\t * Factory to create handshake\n\t * @access public\n\t */\n\t\n\t\n\tvar Authentication = exports.Authentication = function () {\n\t  function Authentication() {\n\t    _classCallCheck(this, Authentication);\n\t  }\n\t\n\t  _createClass(Authentication, null, [{\n\t    key: 'simple',\n\t\n\t    /**\n\t     * @param {{deploymentId: string, login: string, password: string}} parameters\n\t     * @return {CredentialsHandshake}\n\t     */\n\t    value: function simple(_ref4) {\n\t      var _ref4$deploymentId = _ref4.deploymentId;\n\t      var deploymentId = _ref4$deploymentId === undefined ? _services.Simple.DEFAULT_DEPLOYMENT_ID : _ref4$deploymentId;\n\t      var login = _ref4.login;\n\t      var password = _ref4.password;\n\t\n\t      return Authentication.create({\n\t        authType: DeployableNames.AUTH_SIMPLE,\n\t        deploymentId: deploymentId,\n\t        login: login,\n\t        password: password\n\t      });\n\t    }\n\t    /**\n\t     * @param {{deploymentId: string, token: string}} parameters\n\t     * @return {TokenHandshake}\n\t     */\n\t\n\t  }, {\n\t    key: 'weak',\n\t    value: function weak(_ref5) {\n\t      var _ref5$deploymentId = _ref5.deploymentId;\n\t      var deploymentId = _ref5$deploymentId === undefined ? _services.Weak.DEFAULT_DEPLOYMENT_ID : _ref5$deploymentId;\n\t      var token = _ref5.token;\n\t\n\t      return Authentication.create({\n\t        authType: DeployableNames.AUTH_WEAK,\n\t        deploymentId: deploymentId,\n\t        login: token,\n\t        password: null\n\t      });\n\t    }\n\t    /**\n\t     * @param {{deploymentId: string, token: string}} parameters\n\t     * @return {TokenHandshake}\n\t     */\n\t\n\t  }, {\n\t    key: 'delegating',\n\t    value: function delegating(_ref6) {\n\t      var _ref6$deploymentId = _ref6.deploymentId;\n\t      var deploymentId = _ref6$deploymentId === undefined ? _services.Delegating.DEFAULT_DEPLOYMENT_ID : _ref6$deploymentId;\n\t      var token = _ref6.token;\n\t\n\t      return Authentication.create({\n\t        authType: DeployableNames.AUTH_DELEGATING,\n\t        deploymentId: deploymentId,\n\t        login: token,\n\t        password: null\n\t      });\n\t    }\n\t    /**\n\t     * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n\t     * @return {TokenHandshake|CredentialsHandshake}\n\t     */\n\t\n\t  }, {\n\t    key: 'create',\n\t    value: function create(_ref7) {\n\t      var authType = _ref7.authType;\n\t      var deploymentId = _ref7.deploymentId;\n\t      var login = _ref7.login;\n\t      var password = _ref7.password;\n\t\n\t      if (null === password) {\n\t        return new TokenHandshake({ authType: authType, deploymentId: deploymentId, token: login });\n\t      }\n\t      return new CredentialsHandshake({ authType: authType, deploymentId: deploymentId, login: login, password: password });\n\t    }\n\t  }]);\n\n\t  return Authentication;\n\t}();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @access protected\n\t */\n\t\n\tvar Service = exports.Service = function Service(_ref) {\n\t\tvar $publish = _ref.$publish;\n\t\n\t\t_classCallCheck(this, Service);\n\t\n\t\tthis.$publish = $publish;\n\t};\n\t/**\n\t * Data aggregation\n\t *\n\t * Provides data aggregation over time and across different items\n\t *  User devices push items data on developer-defined categories\n\t *  This service automatically aggregates the data\n\t * Raw data is not available for reading, only the generated aggregation result\n\t *\n\t * */\n\t/**\n\t * User API for item aggregation\n\t *\n\t * Users can push data and be notified of aggregated data.\n\t * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Aggreg = exports.Aggreg = function (_Service) {\n\t\t_inherits(Aggreg, _Service);\n\t\n\t\tfunction Aggreg() {\n\t\t\t_classCallCheck(this, Aggreg);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Aggreg).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Aggreg, [{\n\t\t\tkey: 'push',\n\t\n\t\t\t/**\n\t   * Pushes some data\n\t   *\n\t   * Pushes the given data.\n\t   * All the items are processed according to the defined rules.\n\t   * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.\n\t   * */\n\t\t\tvalue: function push(_ref2) {\n\t\t\t\tvar items = _ref2.items;\n\t\t\t\tvar owner = _ref2.owner;\n\t\t\t\tthis.$publish('push', { items: items, owner: owner });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to AggregService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'aggreg_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Aggreg;\n\t}(Service);\n\t/**\n\t * Data stacks\n\t *\n\t * Stacks are a per-user named persistent queue of data\n\t *  An administrator creates a stack service\n\t *  End-users can push data on an arbitrary number of their own arbitrary named stacks\n\t * */\n\t/**\n\t * Data stack user API\n\t *\n\t * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.\n\t * Stack names are arbitrary and do not need to be explicitly initialized.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Stack = exports.Stack = function (_Service2) {\n\t\t_inherits(Stack, _Service2);\n\t\n\t\tfunction Stack() {\n\t\t\t_classCallCheck(this, Stack);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Stack).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Stack, [{\n\t\t\tkey: 'getListeners',\n\t\n\t\t\t/**\n\t   * Lists the listeners\n\t   *\n\t   * Returns the whole list of listeners for the given stack.\n\t   * */\n\t\t\tvalue: function getListeners(_ref3) {\n\t\t\t\tvar owner = _ref3.owner;\n\t\t\t\tvar stack = _ref3.stack;\n\t\t\t\tthis.$publish('getListeners', { owner: owner, stack: stack });\n\t\t\t}\n\t\t\t/**\n\t   * Lists content\n\t   *\n\t   * Returns a paginated list of contents for the given stack.\n\t   * Content is sorted according to the statically configured order.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'list',\n\t\t\tvalue: function list(_ref4) {\n\t\t\t\tvar owner = _ref4.owner;\n\t\t\t\tvar page = _ref4.page;\n\t\t\t\tvar stack = _ref4.stack;\n\t\t\t\tthis.$publish('list', { owner: owner, page: page, stack: stack });\n\t\t\t}\n\t\t\t/**\n\t   * Empties a stack\n\t   *\n\t   * Removes all items from the given stack.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'purge',\n\t\t\tvalue: function purge(_ref5) {\n\t\t\t\tvar owner = _ref5.owner;\n\t\t\t\tvar stack = _ref5.stack;\n\t\t\t\tthis.$publish('purge', { owner: owner, stack: stack });\n\t\t\t}\n\t\t\t/**\n\t   * Pushes an item\n\t   *\n\t   * Pushes an item onto the given stack.\n\t   * The stack does not need to be created.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'push',\n\t\t\tvalue: function push(_ref6) {\n\t\t\t\tvar stack = _ref6.stack;\n\t\t\t\tvar data = _ref6.data;\n\t\t\t\tvar owner = _ref6.owner;\n\t\t\t\tthis.$publish('push', { stack: stack, data: data, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Removes items\n\t   *\n\t   * Removes the item with the given guid from the given stack.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'remove',\n\t\t\tvalue: function remove(_ref7) {\n\t\t\t\tvar guids = _ref7.guids;\n\t\t\t\tvar owner = _ref7.owner;\n\t\t\t\tvar stack = _ref7.stack;\n\t\t\t\tthis.$publish('remove', { guids: guids, owner: owner, stack: stack });\n\t\t\t}\n\t\t\t/**\n\t   * Sets the listeners\n\t   *\n\t   * Sets the listeners for the given stack.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'setListeners',\n\t\t\tvalue: function setListeners(_ref8) {\n\t\t\t\tvar listeners = _ref8.listeners;\n\t\t\t\tvar owner = _ref8.owner;\n\t\t\t\tvar stack = _ref8.stack;\n\t\t\t\tthis.$publish('setListeners', { listeners: listeners, owner: owner, stack: stack });\n\t\t\t}\n\t\t\t/**\n\t   * Updates an item\n\t   *\n\t   * Updates an existing item of the given stack.\n\t   * The item MUST exist prior to the call.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'update',\n\t\t\tvalue: function update(_ref9) {\n\t\t\t\tvar guid = _ref9.guid;\n\t\t\t\tvar stack = _ref9.stack;\n\t\t\t\tvar data = _ref9.data;\n\t\t\t\tvar owner = _ref9.owner;\n\t\t\t\tthis.$publish('update', { guid: guid, stack: stack, data: data, owner: owner });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to StackService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'stack_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Stack;\n\t}(Service);\n\t/**\n\t * Echo\n\t *\n\t * Echo\n\t * */\n\t/**\n\t * Echo service\n\t *\n\t * Simple echo service, for development purposes.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Echo = exports.Echo = function (_Service3) {\n\t\t_inherits(Echo, _Service3);\n\t\n\t\tfunction Echo() {\n\t\t\t_classCallCheck(this, Echo);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Echo).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Echo, [{\n\t\t\tkey: 'echo',\n\t\n\t\t\t/**\n\t   * Echoes an object\n\t   *\n\t   * Echoes an object: the server will echo that object on channel 'echo' for the current user.\n\t   * */\n\t\t\tvalue: function echo(_ref10) {\n\t\t\t\t_objectDestructuringEmpty(_ref10);\n\t\n\t\t\t\tthis.$publish('echo', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to EchoService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'echo_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Echo;\n\t}(Service);\n\t/**\n\t * Game engine\n\t *\n\t * Abstract Game Engine\n\t *  Concrete game engines are remote cometd clients or internal macros\n\t * */\n\t/**\n\t * Game Engine API\n\t *\n\t * The Game Engine API is for game engine clients, not end-users.\n\t * @access public\n\t * */\n\t\n\t\n\tvar GameEngine = exports.GameEngine = function (_Service4) {\n\t\t_inherits(GameEngine, _Service4);\n\t\n\t\tfunction GameEngine() {\n\t\t\t_classCallCheck(this, GameEngine);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(GameEngine).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(GameEngine, [{\n\t\t\tkey: 'join_result',\n\t\n\t\t\t/**\n\t   * Notify the result for a join request\n\t   *\n\t   * A Game Engine notifies the STR of the result of a join request that it received on join_callback\n\t   * */\n\t\t\tvalue: function join_result(_ref11) {\n\t\t\t\tvar callerId = _ref11.callerId;\n\t\t\t\tvar error = _ref11.error;\n\t\t\t\tvar msgId = _ref11.msgId;\n\t\t\t\tvar payload = _ref11.payload;\n\t\t\t\tthis.$publish('join_result', { callerId: callerId, error: error, msgId: msgId, payload: payload });\n\t\t\t}\n\t\t\t/**\n\t   * Notify the result for an organization request\n\t   *\n\t   * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'organize_result',\n\t\t\tvalue: function organize_result(_ref12) {\n\t\t\t\tvar callerId = _ref12.callerId;\n\t\t\t\tvar error = _ref12.error;\n\t\t\t\tvar msgId = _ref12.msgId;\n\t\t\t\tvar payload = _ref12.payload;\n\t\t\t\tthis.$publish('organize_result', { callerId: callerId, error: error, msgId: msgId, payload: payload });\n\t\t\t}\n\t\t\t/**\n\t   * Registers a game engine\n\t   *\n\t   * A client registers itself to the STR as a Game Engine.\n\t   * The STR may, from now on, dispatch game of the given game type to said client.\n\t   * Unregistration is done automatically on logoff.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'register',\n\t\t\tvalue: function register(_ref13) {\n\t\t\t\tvar gameInfo = _ref13.gameInfo;\n\t\t\t\tvar location = _ref13.location;\n\t\t\t\tvar maxGames = _ref13.maxGames;\n\t\t\t\tthis.$publish('register', { gameInfo: gameInfo, location: location, maxGames: maxGames });\n\t\t\t}\n\t\t\t/**\n\t   * Notify the result for a start request\n\t   *\n\t   * A Game Engine notifies the STR of the result of a start request that it received on start_callback\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'start_result',\n\t\t\tvalue: function start_result(_ref14) {\n\t\t\t\tvar gameId = _ref14.gameId;\n\t\t\t\tthis.$publish('start_result', { gameId: gameId });\n\t\t\t}\n\t\t\t/**\n\t   * Notify a game event\n\t   *\n\t   * A Game Engine notifies the STR of some arbitrary game event.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'state',\n\t\t\tvalue: function state(_ref15) {\n\t\t\t\tvar data = _ref15.data;\n\t\t\t\tvar gameId = _ref15.gameId;\n\t\t\t\tvar status = _ref15.status;\n\t\t\t\tthis.$publish('state', { data: data, gameId: gameId, status: status });\n\t\t\t}\n\t\t\t/**\n\t   * Notify the result for an unjoin request\n\t   *\n\t   * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'unjoin_result',\n\t\t\tvalue: function unjoin_result(_ref16) {\n\t\t\t\tvar callerId = _ref16.callerId;\n\t\t\t\tvar error = _ref16.error;\n\t\t\t\tvar msgId = _ref16.msgId;\n\t\t\t\tvar payload = _ref16.payload;\n\t\t\t\tthis.$publish('unjoin_result', { callerId: callerId, error: error, msgId: msgId, payload: payload });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to GameEngineService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'game_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn GameEngine;\n\t}(Service);\n\t/**\n\t * User API for games\n\t *\n\t * Users can list, start, join games, and play.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Game = exports.Game = function (_Service5) {\n\t\t_inherits(Game, _Service5);\n\t\n\t\tfunction Game() {\n\t\t\t_classCallCheck(this, Game);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Game).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Game, [{\n\t\t\tkey: 'available',\n\t\n\t\t\t/**\n\t   * Lists game types\n\t   *\n\t   * Returns the list of game types supported by the server and the currently registered game engines.\n\t   * */\n\t\t\tvalue: function available(_ref17) {\n\t\t\t\t_objectDestructuringEmpty(_ref17);\n\t\n\t\t\t\tthis.$publish('available', {});\n\t\t\t}\n\t\t\t/**A user joins a game*/\n\t\n\t\t}, {\n\t\t\tkey: 'join',\n\t\t\tvalue: function join(_ref18) {\n\t\t\t\tvar gameId = _ref18.gameId;\n\t\t\t\tvar role = _ref18.role;\n\t\t\t\tvar userId = _ref18.userId;\n\t\t\t\tvar userName = _ref18.userName;\n\t\t\t\tthis.$publish('join', { gameId: gameId, role: role, userId: userId, userName: userName });\n\t\t\t}\n\t\t\t/**Organizes a game*/\n\t\n\t\t}, {\n\t\t\tkey: 'organize',\n\t\t\tvalue: function organize(_ref19) {\n\t\t\t\tvar type = _ref19.type;\n\t\t\t\tvar owner = _ref19.owner;\n\t\t\t\tvar options = _ref19.options;\n\t\t\t\tthis.$publish('organize', { type: type, owner: owner, options: options });\n\t\t\t}\n\t\t\t/**Gives some command to the game engine*/\n\t\n\t\t}, {\n\t\t\tkey: 'play',\n\t\t\tvalue: function play(_ref20) {\n\t\t\t\tvar data = _ref20.data;\n\t\t\t\tvar gameId = _ref20.gameId;\n\t\t\t\tvar userId = _ref20.userId;\n\t\t\t\tthis.$publish('play', { data: data, gameId: gameId, userId: userId });\n\t\t\t}\n\t\t\t/**Starts a game*/\n\t\n\t\t}, {\n\t\t\tkey: 'start',\n\t\t\tvalue: function start(_ref21) {\n\t\t\t\tvar gameId = _ref21.gameId;\n\t\t\t\tthis.$publish('start', { gameId: gameId });\n\t\t\t}\n\t\t\t/**A user cancels joining a game*/\n\t\n\t\t}, {\n\t\t\tkey: 'unjoin',\n\t\t\tvalue: function unjoin(_ref22) {\n\t\t\t\tvar gameId = _ref22.gameId;\n\t\t\t\tvar role = _ref22.role;\n\t\t\t\tvar userId = _ref22.userId;\n\t\t\t\tvar userName = _ref22.userName;\n\t\t\t\tthis.$publish('unjoin', { gameId: gameId, role: role, userId: userId, userName: userName });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to GameService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'game_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Game;\n\t}(Service);\n\t/**\n\t * Generic Data Access\n\t *\n\t * Generic Data Access Service : NoSQL storage\n\t * */\n\t/**\n\t * GDA User API\n\t *\n\t * User API for Generic Data Access.\n\t * Data is stored on a per-user basis.\n\t * Users can put, get, list their data.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Gda = exports.Gda = function (_Service6) {\n\t\t_inherits(Gda, _Service6);\n\t\n\t\tfunction Gda() {\n\t\t\t_classCallCheck(this, Gda);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Gda).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Gda, [{\n\t\t\tkey: 'get',\n\t\n\t\t\t/**\n\t   * Asks for a data row\n\t   *\n\t   * Returns a full data row.\n\t   * */\n\t\t\tvalue: function get(_ref23) {\n\t\t\t\tvar key = _ref23.key;\n\t\t\t\tvar owner = _ref23.owner;\n\t\t\t\tvar table = _ref23.table;\n\t\t\t\tthis.$publish('get', { key: key, owner: owner, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Asks for a data cell\n\t   *\n\t   * Returns a precise list of cells from a column in a data row.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'getCells',\n\t\t\tvalue: function getCells(_ref24) {\n\t\t\t\tvar column = _ref24.column;\n\t\t\t\tvar key = _ref24.key;\n\t\t\t\tvar key2 = _ref24.key2;\n\t\t\t\tvar owner = _ref24.owner;\n\t\t\t\tvar table = _ref24.table;\n\t\t\t\tthis.$publish('getCells', { column: column, key: key, key2: key2, owner: owner, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Increments an integer value\n\t   *\n\t   * Increments a cell 64-bit signed integer value and returns the result in the data field.\n\t   * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'inc',\n\t\t\tvalue: function inc(_ref25) {\n\t\t\t\tvar table = _ref25.table;\n\t\t\t\tvar data = _ref25.data;\n\t\t\t\tvar key = _ref25.key;\n\t\t\t\tvar key2 = _ref25.key2;\n\t\t\t\tvar owner = _ref25.owner;\n\t\t\t\tvar column = _ref25.column;\n\t\t\t\tthis.$publish('inc', { table: table, data: data, key: key, key2: key2, owner: owner, column: column });\n\t\t\t}\n\t\t\t/**\n\t   * Asks for a list of rows\n\t   *\n\t   * Returns a paginated list of rows from the given table.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'list',\n\t\t\tvalue: function list(_ref26) {\n\t\t\t\tvar columns = _ref26.columns;\n\t\t\t\tvar owner = _ref26.owner;\n\t\t\t\tvar page = _ref26.page;\n\t\t\t\tvar table = _ref26.table;\n\t\t\t\tthis.$publish('list', { columns: columns, owner: owner, page: page, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Puts some data into a cell\n\t   *\n\t   * Creates or replaces the contents of a particular cell.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'put',\n\t\t\tvalue: function put(_ref27) {\n\t\t\t\tvar column = _ref27.column;\n\t\t\t\tvar data = _ref27.data;\n\t\t\t\tvar key = _ref27.key;\n\t\t\t\tvar key2 = _ref27.key2;\n\t\t\t\tvar owner = _ref27.owner;\n\t\t\t\tvar table = _ref27.table;\n\t\t\t\tthis.$publish('put', { column: column, data: data, key: key, key2: key2, owner: owner, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Puts several rows\n\t   *\n\t   * Creates or replaces the (maybe partial) contents of a collection of rows.\n\t   * This method only creates or replaces cells for non-null input values.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'puts',\n\t\t\tvalue: function puts(_ref28) {\n\t\t\t\tvar owner = _ref28.owner;\n\t\t\t\tvar rows = _ref28.rows;\n\t\t\t\tvar table = _ref28.table;\n\t\t\t\tthis.$publish('puts', { owner: owner, rows: rows, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Asks for a range of rows\n\t   *\n\t   * Returns a paginated range of rows from the given table.\n\t   * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t   * You can specify partial keys for the start and stop fields.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'range',\n\t\t\tvalue: function range(_ref29) {\n\t\t\t\tvar columns = _ref29.columns;\n\t\t\t\tvar owner = _ref29.owner;\n\t\t\t\tvar page = _ref29.page;\n\t\t\t\tvar start = _ref29.start;\n\t\t\t\tvar stop = _ref29.stop;\n\t\t\t\tvar table = _ref29.table;\n\t\t\t\tthis.$publish('range', { columns: columns, owner: owner, page: page, start: start, stop: stop, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Reduces a range of rows\n\t   *\n\t   * Returns a computed single reduced result from a range of rows from the given table.\n\t   * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t   * You can specify partial keys for the start and stop fields.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'reduce',\n\t\t\tvalue: function reduce(_ref30) {\n\t\t\t\t_objectDestructuringEmpty(_ref30);\n\t\n\t\t\t\tthis.$publish('reduce', {});\n\t\t\t}\n\t\t\t/**\n\t   * Removes one cell inside a column of a row\n\t   *\n\t   * Removes only one cell of the given column of the given row from the given table.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'removeCell',\n\t\t\tvalue: function removeCell(_ref31) {\n\t\t\t\tvar column = _ref31.column;\n\t\t\t\tvar key = _ref31.key;\n\t\t\t\tvar key2 = _ref31.key2;\n\t\t\t\tvar owner = _ref31.owner;\n\t\t\t\tvar table = _ref31.table;\n\t\t\t\tthis.$publish('removeCell', { column: column, key: key, key2: key2, owner: owner, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Removes one full column of a row\n\t   *\n\t   * Removes all cells of the given column of the given row from the given table.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'removeColumn',\n\t\t\tvalue: function removeColumn(_ref32) {\n\t\t\t\tvar column = _ref32.column;\n\t\t\t\tvar key = _ref32.key;\n\t\t\t\tvar owner = _ref32.owner;\n\t\t\t\tvar table = _ref32.table;\n\t\t\t\tthis.$publish('removeColumn', { column: column, key: key, owner: owner, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Removes a range of rows\n\t   *\n\t   * Removes the specified columns of the given range of rows from the given table.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'removeRange',\n\t\t\tvalue: function removeRange(_ref33) {\n\t\t\t\tvar columns = _ref33.columns;\n\t\t\t\tvar owner = _ref33.owner;\n\t\t\t\tvar start = _ref33.start;\n\t\t\t\tvar stop = _ref33.stop;\n\t\t\t\tvar table = _ref33.table;\n\t\t\t\tthis.$publish('removeRange', { columns: columns, owner: owner, start: start, stop: stop, table: table });\n\t\t\t}\n\t\t\t/**\n\t   * Removes one full row\n\t   *\n\t   * Removes all columns of the given row from the given table.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'removeRow',\n\t\t\tvalue: function removeRow(_ref34) {\n\t\t\t\tvar key = _ref34.key;\n\t\t\t\tvar owner = _ref34.owner;\n\t\t\t\tvar table = _ref34.table;\n\t\t\t\tthis.$publish('removeRow', { key: key, owner: owner, table: table });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to GdaService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'gda_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Gda;\n\t}(Service);\n\t/**\n\t * Groups Management\n\t *\n\t * Groups management for users, grants on resources, remote commands on devices\n\t *  This is where you can configure rights for any resource\n\t *\n\t * */\n\t/**\n\t * User API for remote control\n\t *\n\t * @access public\n\t * */\n\t\n\t\n\tvar Remoting = function (_Service7) {\n\t\t_inherits(Remoting, _Service7);\n\t\n\t\tfunction Remoting() {\n\t\t\t_classCallCheck(this, Remoting);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Remoting).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Remoting, [{\n\t\t\tkey: 'addListener',\n\t\n\t\t\t/**\n\t   * Adds a listener\n\t   *\n\t   * A user requests notifications from a device owned by anyone who granted him the right authorizations.\n\t   * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.\n\t   * */\n\t\t\tvalue: function addListener(_ref35) {\n\t\t\t\tvar cmd = _ref35.cmd;\n\t\t\t\tvar data = _ref35.data;\n\t\t\t\tvar from = _ref35.from;\n\t\t\t\tvar fromResource = _ref35.fromResource;\n\t\t\t\tvar owner = _ref35.owner;\n\t\t\t\tvar resource = _ref35.resource;\n\t\t\t\tthis.$publish('addListener', { cmd: cmd, data: data, from: from, fromResource: fromResource, owner: owner, resource: resource });\n\t\t\t}\n\t\t\t/**Response to 'getCapabilities'*/\n\t\n\t\t}, {\n\t\t\tkey: 'capabilities',\n\t\t\tvalue: function capabilities(_ref36) {\n\t\t\t\tvar answeringResource = _ref36.answeringResource;\n\t\t\t\tvar askingResource = _ref36.askingResource;\n\t\t\t\tvar _capabilities = _ref36.capabilities;\n\t\t\t\tthis.$publish('capabilities', { answeringResource: answeringResource, askingResource: askingResource, capabilities: _capabilities });\n\t\t\t}\n\t\t\t/**\n\t   * Executes a command\n\t   *\n\t   * A user executes a command on a device owned by anyone who granted him the right authorizations.\n\t   * The command is issued on channel 'command'\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'execute',\n\t\t\tvalue: function execute(_ref37) {\n\t\t\t\tvar resource = _ref37.resource;\n\t\t\t\tvar cmd = _ref37.cmd;\n\t\t\t\tvar data = _ref37.data;\n\t\t\t\tvar owner = _ref37.owner;\n\t\t\t\tthis.$publish('execute', { resource: resource, cmd: cmd, data: data, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Requests capabilities\n\t   *\n\t   * A user requests all his devices for the whole list of their capabilities.\n\t   * Devices are expected to answer on channel 'capabilities'\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'getCapabilities',\n\t\t\tvalue: function getCapabilities(_ref38) {\n\t\t\t\t_objectDestructuringEmpty(_ref38);\n\t\n\t\t\t\tthis.$publish('getCapabilities', {});\n\t\t\t}\n\t\t\t/**\n\t   * Notifies of some event\n\t   *\n\t   * A device notifies the registered users/devices on this channel.\n\t   * The server forwards the notification to said users.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'notify',\n\t\t\tvalue: function notify(_ref39) {\n\t\t\t\tvar cmd = _ref39.cmd;\n\t\t\t\tvar data = _ref39.data;\n\t\t\t\tvar from = _ref39.from;\n\t\t\t\tvar fromResource = _ref39.fromResource;\n\t\t\t\tvar owner = _ref39.owner;\n\t\t\t\tvar resource = _ref39.resource;\n\t\t\t\tthis.$publish('notify', { cmd: cmd, data: data, from: from, fromResource: fromResource, owner: owner, resource: resource });\n\t\t\t}\n\t\t\t/**\n\t   * Pings devices\n\t   *\n\t   * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'ping',\n\t\t\tvalue: function ping(_ref40) {\n\t\t\t\tvar action = _ref40.action;\n\t\t\t\tthis.$publish('ping', { action: action });\n\t\t\t}\n\t\t\t/**Response to ping*/\n\t\n\t\t}, {\n\t\t\tkey: 'pong',\n\t\t\tvalue: function pong(_ref41) {\n\t\t\t\tvar action = _ref41.action;\n\t\t\t\tvar available = _ref41.available;\n\t\t\t\tvar owner = _ref41.owner;\n\t\t\t\tvar resource = _ref41.resource;\n\t\t\t\tvar uid = _ref41.uid;\n\t\t\t\tvar user = _ref41.user;\n\t\t\t\tthis.$publish('pong', { action: action, available: available, owner: owner, resource: resource, uid: uid, user: user });\n\t\t\t}\n\t\t\t/**\n\t   * Removes a listener\n\t   *\n\t   * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'removeListener',\n\t\t\tvalue: function removeListener(_ref42) {\n\t\t\t\tvar cmd = _ref42.cmd;\n\t\t\t\tvar data = _ref42.data;\n\t\t\t\tvar from = _ref42.from;\n\t\t\t\tvar fromResource = _ref42.fromResource;\n\t\t\t\tvar owner = _ref42.owner;\n\t\t\t\tvar resource = _ref42.resource;\n\t\t\t\tthis.$publish('removeListener', { cmd: cmd, data: data, from: from, fromResource: fromResource, owner: owner, resource: resource });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to RemotingService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'groups_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Remoting;\n\t}(Service);\n\t/**\n\t * User API for groups and rights.\n\t *\n\t * Groups are stored per user.\n\t * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.\n\t * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.\n\t * @access public\n\t * */\n\t\n\t\n\texports.Remoting = Remoting;\n\t\n\tvar GroupManagement = exports.GroupManagement = function (_Service8) {\n\t\t_inherits(GroupManagement, _Service8);\n\t\n\t\tfunction GroupManagement() {\n\t\t\t_classCallCheck(this, GroupManagement);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(GroupManagement).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(GroupManagement, [{\n\t\t\tkey: 'addMe',\n\t\n\t\t\t/**\n\t   * Adds me to a group\n\t   *\n\t   * Adds me (the caller) to a group.\n\t   * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.\n\t   * The 'user' field is implicitly set to the current user's key.\n\t   * */\n\t\t\tvalue: function addMe(_ref43) {\n\t\t\t\tvar group = _ref43.group;\n\t\t\t\tvar owner = _ref43.owner;\n\t\t\t\tthis.$publish('addMe', { group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Adds a user to a group\n\t   *\n\t   * Adds the given user to the given group.\n\t   * Addition may fail if the given group does not already exist.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'addUser',\n\t\t\tvalue: function addUser(_ref44) {\n\t\t\t\tvar user = _ref44.user;\n\t\t\t\tvar group = _ref44.group;\n\t\t\t\tvar owner = _ref44.owner;\n\t\t\t\tthis.$publish('addUser', { user: user, group: group, owner: owner });\n\t\t\t}\n\t\t\t/**Adds users to a group*/\n\t\n\t\t}, {\n\t\t\tkey: 'addUsers',\n\t\t\tvalue: function addUsers(_ref45) {\n\t\t\t\tvar users = _ref45.users;\n\t\t\t\tvar group = _ref45.group;\n\t\t\t\tvar owner = _ref45.owner;\n\t\t\t\tthis.$publish('addUsers', { users: users, group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Lists my owned groups, with details\n\t   *\n\t   * Returns the whole list of groups owned by the current user, with their members\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'allGroups',\n\t\t\tvalue: function allGroups(_ref46) {\n\t\t\t\tvar owner = _ref46.owner;\n\t\t\t\tthis.$publish('allGroups', { owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Creates a group\n\t   *\n\t   * Creates a group owned by the current user.\n\t   * Group creation may fail if the group already exists.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'createGroup',\n\t\t\tvalue: function createGroup(_ref47) {\n\t\t\t\tvar group = _ref47.group;\n\t\t\t\tvar groupName = _ref47.groupName;\n\t\t\t\tvar owner = _ref47.owner;\n\t\t\t\tthis.$publish('createGroup', { group: group, groupName: groupName, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Removes a group\n\t   *\n\t   * Removes the given group owned by the current user or the given owner.\n\t   * Also removes all grants to that group.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'delGroup',\n\t\t\tvalue: function delGroup(_ref48) {\n\t\t\t\tvar group = _ref48.group;\n\t\t\t\tvar owner = _ref48.owner;\n\t\t\t\tthis.$publish('delGroup', { group: group, owner: owner });\n\t\t\t}\n\t\t\t/**Removes a user from a group*/\n\t\n\t\t}, {\n\t\t\tkey: 'delUser',\n\t\t\tvalue: function delUser(_ref49) {\n\t\t\t\tvar group = _ref49.group;\n\t\t\t\tvar owner = _ref49.owner;\n\t\t\t\tvar user = _ref49.user;\n\t\t\t\tthis.$publish('delUser', { group: group, owner: owner, user: user });\n\t\t\t}\n\t\t\t/**Removes users from a group*/\n\t\n\t\t}, {\n\t\t\tkey: 'delUsers',\n\t\t\tvalue: function delUsers(_ref50) {\n\t\t\t\tvar group = _ref50.group;\n\t\t\t\tvar groupName = _ref50.groupName;\n\t\t\t\tvar owner = _ref50.owner;\n\t\t\t\tvar users = _ref50.users;\n\t\t\t\tthis.$publish('delUsers', { group: group, groupName: groupName, owner: owner, users: users });\n\t\t\t}\n\t\t\t/**\n\t   * Tests for a group's existence\n\t   *\n\t   * Returns whether a group exists or not.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'exists',\n\t\t\tvalue: function exists(_ref51) {\n\t\t\t\tvar group = _ref51.group;\n\t\t\t\tvar owner = _ref51.owner;\n\t\t\t\tthis.$publish('exists', { group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Grants a right to a group\n\t   *\n\t   * The granting API does not do any check when storing permissions.\n\t   * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'grant',\n\t\t\tvalue: function grant(_ref52) {\n\t\t\t\tvar action = _ref52.action;\n\t\t\t\tvar group = _ref52.group;\n\t\t\t\tvar owner = _ref52.owner;\n\t\t\t\tvar resource = _ref52.resource;\n\t\t\t\tthis.$publish('grant', { action: action, group: group, owner: owner, resource: resource });\n\t\t\t}\n\t\t\t/**\n\t   * Lists the group users\n\t   *\n\t   * Returns the whole list of users configured inside the given group.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'groupUsers',\n\t\t\tvalue: function groupUsers(_ref53) {\n\t\t\t\tvar group = _ref53.group;\n\t\t\t\tvar owner = _ref53.owner;\n\t\t\t\tthis.$publish('groupUsers', { group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Lists my owned groups\n\t   *\n\t   * Returns the whole list of groups owned by the current user\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'groups',\n\t\t\tvalue: function groups(_ref54) {\n\t\t\t\tvar owner = _ref54.owner;\n\t\t\t\tthis.$publish('groups', { owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Lists rights for a group\n\t   *\n\t   * This API lists explicitly configured rights.\n\t   * Effective rights include configured rights, implicit rights and inherited rights.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'listGrants',\n\t\t\tvalue: function listGrants(_ref55) {\n\t\t\t\tvar group = _ref55.group;\n\t\t\t\tvar owner = _ref55.owner;\n\t\t\t\tthis.$publish('listGrants', { group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Lists presences for a group\n\t   *\n\t   * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.\n\t   * The current implementation does not include information about the particular devices users are connected with.\n\t   * If a user is connected twice with two different devices, two identical entries will be returned.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'listPresences',\n\t\t\tvalue: function listPresences(_ref56) {\n\t\t\t\tvar group = _ref56.group;\n\t\t\t\tvar owner = _ref56.owner;\n\t\t\t\tthis.$publish('listPresences', { group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Tests membership\n\t   *\n\t   * Tests whether I (the caller) am a member of the given group.\n\t   * This verb exists so that users can determine if they are part of a group without being granted particular rights.\n\t   * The 'user' field is implicitly set to the current user's key.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'memberOf',\n\t\t\tvalue: function memberOf(_ref57) {\n\t\t\t\tvar hardFail = _ref57.hardFail;\n\t\t\t\tvar group = _ref57.group;\n\t\t\t\tvar owner = _ref57.owner;\n\t\t\t\tthis.$publish('memberOf', { hardFail: hardFail, group: group, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Grants rights to a group\n\t   *\n\t   * Grant several rights at once.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mgrant',\n\t\t\tvalue: function mgrant(_ref58) {\n\t\t\t\tvar actions = _ref58.actions;\n\t\t\t\tvar group = _ref58.group;\n\t\t\t\tvar owner = _ref58.owner;\n\t\t\t\tvar resource = _ref58.resource;\n\t\t\t\tthis.$publish('mgrant', { actions: actions, group: group, owner: owner, resource: resource });\n\t\t\t}\n\t\t\t/**Revokes rights for a group*/\n\t\n\t\t}, {\n\t\t\tkey: 'mrevoke',\n\t\t\tvalue: function mrevoke(_ref59) {\n\t\t\t\tvar actions = _ref59.actions;\n\t\t\t\tvar group = _ref59.group;\n\t\t\t\tvar owner = _ref59.owner;\n\t\t\t\tvar resource = _ref59.resource;\n\t\t\t\tthis.$publish('mrevoke', { actions: actions, group: group, owner: owner, resource: resource });\n\t\t\t}\n\t\t\t/**\n\t   * Lists the groups I am part of\n\t   *\n\t   * Returns the whole list of groups the current user is part of.\n\t   * Groups may be owned by anyone, including the current user.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'myGroups',\n\t\t\tvalue: function myGroups(_ref60) {\n\t\t\t\tvar owner = _ref60.owner;\n\t\t\t\tthis.$publish('myGroups', { owner: owner });\n\t\t\t}\n\t\t\t/**Revokes a right for a group*/\n\t\n\t\t}, {\n\t\t\tkey: 'revoke',\n\t\t\tvalue: function revoke(_ref61) {\n\t\t\t\tvar action = _ref61.action;\n\t\t\t\tvar group = _ref61.group;\n\t\t\t\tvar owner = _ref61.owner;\n\t\t\t\tvar resource = _ref61.resource;\n\t\t\t\tthis.$publish('revoke', { action: action, group: group, owner: owner, resource: resource });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to GroupManagementService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'groups_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn GroupManagement;\n\t}(Service);\n\t/**\n\t * HTTP client\n\t *\n\t * Web-service client\n\t *  An admin records URL templates that can be called by users\n\t *  Calls are not configurable by end-users\n\t *  However an admin may leverage the macro service to achieve URL, headers and body configurability\n\t * */\n\t/**\n\t * User API for http requests\n\t *\n\t * @access public\n\t * */\n\t\n\t\n\tvar Httpclient = exports.Httpclient = function (_Service9) {\n\t\t_inherits(Httpclient, _Service9);\n\t\n\t\tfunction Httpclient() {\n\t\t\t_classCallCheck(this, Httpclient);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Httpclient).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Httpclient, [{\n\t\t\tkey: 'call',\n\t\n\t\t\t/**\n\t   * Makes a predefined request\n\t   *\n\t   * Lookups a predefined request by name, and executes it.\n\t   * */\n\t\t\tvalue: function call(_ref62) {\n\t\t\t\tvar name = _ref62.name;\n\t\t\t\tvar requestId = _ref62.requestId;\n\t\t\t\tthis.$publish('call', { name: name, requestId: requestId });\n\t\t\t}\n\t\t\t/**\n\t   * Makes a parameterized request\n\t   *\n\t   * Executes an HTTP request with the given url, method, headers and body.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'request',\n\t\t\tvalue: function request(_ref63) {\n\t\t\t\t_objectDestructuringEmpty(_ref63);\n\t\n\t\t\t\tthis.$publish('request', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to HttpclientService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'httpclient_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Httpclient;\n\t}(Service);\n\t/**\n\t * Macros\n\t *\n\t * Macro-command service\n\t *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc\n\t *\n\t *\n\t *  End-users play them, with contextual parameters\n\t * */\n\t/**\n\t * User API for macro execution\n\t *\n\t * Simple errors are reported as usual.\n\t * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual 'error' channel, errors are put in the returned 'MacroCompletion' result.\n\t * This behavior can be tuned on a per-call basis with the hardFail parameter.\n\t * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE\n\t * @access public\n\t * */\n\t\n\t\n\tvar Macro = exports.Macro = function (_Service10) {\n\t\t_inherits(Macro, _Service10);\n\t\n\t\tfunction Macro() {\n\t\t\t_classCallCheck(this, Macro);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Macro).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Macro, [{\n\t\t\tkey: 'call',\n\t\n\t\t\t/**\n\t   * Plays a previously recorded macro\n\t   *\n\t   * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.\n\t   * You can override the default notification channel when defining the macro.\n\t   * */\n\t\t\tvalue: function call(_ref64) {\n\t\t\t\tvar debug = _ref64.debug;\n\t\t\t\tvar hardFail = _ref64.hardFail;\n\t\t\t\tvar name = _ref64.name;\n\t\t\t\tvar parameters = _ref64.parameters;\n\t\t\t\tthis.$publish('call', { debug: debug, hardFail: hardFail, name: name, parameters: parameters });\n\t\t\t}\n\t\t\t/**\n\t   * Plays a previously recorded macro and returns the result.\n\t   *\n\t   * Use this verb when you want to synchronously call a macro from inside another macro.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'func',\n\t\t\tvalue: function func(_ref65) {\n\t\t\t\t_objectDestructuringEmpty(_ref65);\n\t\n\t\t\t\tthis.$publish('func', {});\n\t\t\t}\n\t\t\t/**\n\t   * Similar to func, with the ability to impersonate any user at will.\n\t   *\n\t   * Use this verb when you do not want to use or cannot use the standard rights system and wish to bypass it completely.\n\t   * Use this verb sparingly, as it can give the caller any right on any resource.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'sudo',\n\t\t\tvalue: function sudo(_ref66) {\n\t\t\t\t_objectDestructuringEmpty(_ref66);\n\t\n\t\t\t\tthis.$publish('sudo', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to MacroService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'macro_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Macro;\n\t}(Service);\n\t/**\n\t * Mail sender\n\t *\n\t * Sends email through SMTP\n\t * */\n\t/**\n\t * Mail service user API\n\t *\n\t * This service is statically configured with an outgoing SMTP server.\n\t * Users call the API here to actually send emails.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Sendmail = exports.Sendmail = function (_Service11) {\n\t\t_inherits(Sendmail, _Service11);\n\t\n\t\tfunction Sendmail() {\n\t\t\t_classCallCheck(this, Sendmail);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Sendmail).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Sendmail, [{\n\t\t\tkey: 'send',\n\t\n\t\t\t/**\n\t   * Sends an email\n\t   *\n\t   * Sends an email with the given body to the intended recipients.\n\t   * */\n\t\t\tvalue: function send(_ref67) {\n\t\t\t\t_objectDestructuringEmpty(_ref67);\n\t\n\t\t\t\tthis.$publish('send', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to SendmailService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'sendmail_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Sendmail;\n\t}(Service);\n\t/**\n\t * Messaging service\n\t *\n\t * Messaging service\n\t * */\n\t/**\n\t * Messaging service\n\t *\n\t * Simple and flexible user-to-user or user-to-group messaging service.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Messaging = exports.Messaging = function (_Service12) {\n\t\t_inherits(Messaging, _Service12);\n\t\n\t\tfunction Messaging() {\n\t\t\t_classCallCheck(this, Messaging);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Messaging).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Messaging, [{\n\t\t\tkey: 'send',\n\t\n\t\t\t/**\n\t   * Sends a message to a target\n\t   *\n\t   * Sends the given message to the specified target on the given (optional) channel.\n\t   * The administratively given default channel name is used when none is provided in the message itself.\n\t   * */\n\t\t\tvalue: function send(_ref68) {\n\t\t\t\tvar target = _ref68.target;\n\t\t\t\tvar channel = _ref68.channel;\n\t\t\t\tvar data = _ref68.data;\n\t\t\t\tthis.$publish('send', { target: target, channel: channel, data: data });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to MessagingService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'messaging_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Messaging;\n\t}(Service);\n\t/**\n\t * Producer consumer\n\t *\n\t * Producer consumer service\n\t *  Users can submit tasks and other users consume them\n\t * */\n\t/**\n\t * Producer / consumer real-time API\n\t *\n\t * Task producers submits their tasks.\n\t * The server dispatches the tasks.\n\t * Consumers process them and report completion back to the server.\n\t * Tasks are global to the service (i.e. NOT per user).\n\t * @access public\n\t * */\n\t\n\t\n\tvar Queue = exports.Queue = function (_Service13) {\n\t\t_inherits(Queue, _Service13);\n\t\n\t\tfunction Queue() {\n\t\t\t_classCallCheck(this, Queue);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Queue).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Queue, [{\n\t\t\tkey: 'call',\n\t\n\t\t\t/**\n\t   * Submits a task\n\t   *\n\t   * Producer API.\n\t   * A task producer submits the given task to the server.\n\t   * The server will find a tasker with processing capacity and dispatch the task.\n\t   * The task result will be returned to the caller.\n\t   * When called from inside a macro, the comsumer generated result is available for further use.\n\t   * */\n\t\t\tvalue: function call(_ref69) {\n\t\t\t\tvar description = _ref69.description;\n\t\t\t\tvar originBusinessId = _ref69.originBusinessId;\n\t\t\t\tvar originDeploymentId = _ref69.originDeploymentId;\n\t\t\t\tvar data = _ref69.data;\n\t\t\t\tvar owner = _ref69.owner;\n\t\t\t\tthis.$publish('call', { description: description, originBusinessId: originBusinessId, originDeploymentId: originDeploymentId, data: data, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Notifies completion of a task\n\t   *\n\t   * Consumer API.\n\t   * The tasker notifies completion of the given task to the server.\n\t   * The tasker can optionally include a result or an error code.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'done',\n\t\t\tvalue: function done(_ref70) {\n\t\t\t\tvar result = _ref70.result;\n\t\t\t\tvar success = _ref70.success;\n\t\t\t\tvar taskId = _ref70.taskId;\n\t\t\t\tthis.$publish('done', { result: result, success: success, taskId: taskId });\n\t\t\t}\n\t\t\t/**\n\t   * Registers a consumer\n\t   *\n\t   * Consumer API.\n\t   * Registers the current user resource as an available task consumer.\n\t   * Tasks will be then dispatched to that consumer.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'register',\n\t\t\tvalue: function register(_ref71) {\n\t\t\t\tvar capacity = _ref71.capacity;\n\t\t\t\tthis.$publish('register', { capacity: capacity });\n\t\t\t}\n\t\t\t/**\n\t   * Submits a task\n\t   *\n\t   * Producer API.\n\t   * A task producer submits the given task to the server.\n\t   * The server will find a tasker with processing capacity and dispatch the task.\n\t   * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).\n\t   * This verb will return immediately : you can use this API to asynchronously submit a task.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'submit',\n\t\t\tvalue: function submit(_ref72) {\n\t\t\t\tvar description = _ref72.description;\n\t\t\t\tvar originBusinessId = _ref72.originBusinessId;\n\t\t\t\tvar originDeploymentId = _ref72.originDeploymentId;\n\t\t\t\tvar data = _ref72.data;\n\t\t\t\tvar owner = _ref72.owner;\n\t\t\t\tthis.$publish('submit', { description: description, originBusinessId: originBusinessId, originDeploymentId: originDeploymentId, data: data, owner: owner });\n\t\t\t}\n\t\t\t/**\n\t   * Unregisters a consumer\n\t   *\n\t   * Consumer API.\n\t   * Unregisters the current user resource as an available task consumer.\n\t   * All non finished tasks are returned to the server.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'unregister',\n\t\t\tvalue: function unregister(_ref73) {\n\t\t\t\t_objectDestructuringEmpty(_ref73);\n\t\n\t\t\t\tthis.$publish('unregister', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to QueueService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'queue_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Queue;\n\t}(Service);\n\t/**\n\t * SMS via OVH\n\t *\n\t * SMS sender, to send text messages to mobile phones\n\t * This SMS sending service uses the OVH API\n\t *\n\t * */\n\t/**\n\t * SMS service\n\t *\n\t * User API for SMS.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Sms_ovh = exports.Sms_ovh = function (_Service14) {\n\t\t_inherits(Sms_ovh, _Service14);\n\t\n\t\tfunction Sms_ovh() {\n\t\t\t_classCallCheck(this, Sms_ovh);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Sms_ovh).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Sms_ovh, [{\n\t\t\tkey: 'send',\n\t\n\t\t\t/**\n\t   * Sends an SMS\n\t   *\n\t   * Sends the given message to the given recipients.\n\t   * */\n\t\t\tvalue: function send(_ref74) {\n\t\t\t\t_objectDestructuringEmpty(_ref74);\n\t\n\t\t\t\tthis.$publish('send', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to Sms_ovhService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'sms_ovh_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Sms_ovh;\n\t}(Service);\n\t/**\n\t * Scheduler\n\t *\n\t * Scheduler service\n\t *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)\n\t * */\n\t/**\n\t * User API for the Scheduler\n\t *\n\t * User endpoints for scheduling : users can schedule, list and delete tasks.\n\t * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.\n\t * Tasks are run on the server and thus can call api verbs marked as server-only.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Cron = exports.Cron = function (_Service15) {\n\t\t_inherits(Cron, _Service15);\n\t\n\t\tfunction Cron() {\n\t\t\t_classCallCheck(this, Cron);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Cron).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Cron, [{\n\t\t\tkey: 'list',\n\t\n\t\t\t/**\n\t   * List the configured tasks\n\t   *\n\t   * Returns a paginated list of the asking user's tasks.\n\t   * */\n\t\t\tvalue: function list(_ref75) {\n\t\t\t\tvar owner = _ref75.owner;\n\t\t\t\tvar page = _ref75.page;\n\t\t\t\tvar start = _ref75.start;\n\t\t\t\tvar stop = _ref75.stop;\n\t\t\t\tthis.$publish('list', { owner: owner, page: page, start: start, stop: stop });\n\t\t\t}\n\t\t\t/**\n\t   * Schedules a task\n\t   *\n\t   * Schedules a task for later execution.\n\t   * If a task already exists with the same cronName, this new task completely replaces it.\n\t   * A task can be scheduled with a cron-like syntax for repetitive or one-shot execution.\n\t   * Wildcards are not allowed for minutes and hours.\n\t   * When scheduling for one-shot execution, the time must be at least two minutes into the future.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'schedule',\n\t\t\tvalue: function schedule(_ref76) {\n\t\t\t\t_objectDestructuringEmpty(_ref76);\n\t\n\t\t\t\tthis.$publish('schedule', {});\n\t\t\t}\n\t\t\t/**\n\t   * Removes a scheduled task\n\t   *\n\t   * Removes a previously scheduled task.\n\t   * Does absolutely nothing if asked to remove a non-existent task.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'unschedule',\n\t\t\tvalue: function unschedule(_ref77) {\n\t\t\t\tvar cronName = _ref77.cronName;\n\t\t\t\tvar owner = _ref77.owner;\n\t\t\t\tthis.$publish('unschedule', { cronName: cronName, owner: owner });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to CronService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'cron_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Cron;\n\t}(Service);\n\t/**\n\t * Search engine\n\t *\n\t * ElasticSearch engine, to index and search data\n\t *  An admin creates indices\n\t *  Users index and search documents\n\t *\n\t * */\n\t/**\n\t * ElasticSearch Service\n\t *\n\t * This API is a very thin wrapper around ElasticSearch's API.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Search = function (_Service16) {\n\t\t_inherits(Search, _Service16);\n\t\n\t\tfunction Search() {\n\t\t\t_classCallCheck(this, Search);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Search).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Search, [{\n\t\t\tkey: 'delete',\n\t\n\t\t\t/**\n\t   * Deletes data\n\t   *\n\t   * Deletes a document from the elasticsearch engine by id.\n\t   * */\n\t\t\tvalue: function _delete(_ref78) {\n\t\t\t\tvar id = _ref78.id;\n\t\t\t\tvar index = _ref78.index;\n\t\t\t\tvar type = _ref78.type;\n\t\t\t\tthis.$publish('delete', { id: id, index: index, type: type });\n\t\t\t}\n\t\t\t/**\n\t   * Gets data\n\t   *\n\t   * Retrieves a document from the elasticsearch engine by id.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'get',\n\t\t\tvalue: function get(_ref79) {\n\t\t\t\tvar id = _ref79.id;\n\t\t\t\tvar index = _ref79.index;\n\t\t\t\tvar type = _ref79.type;\n\t\t\t\tthis.$publish('get', { id: id, index: index, type: type });\n\t\t\t}\n\t\t\t/**\n\t   * Indexes data\n\t   *\n\t   * Inserts or updates a document into the elasticsearch engine.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'index',\n\t\t\tvalue: function index(_ref80) {\n\t\t\t\tvar data = _ref80.data;\n\t\t\t\tvar id = _ref80.id;\n\t\t\t\tvar _index = _ref80.index;\n\t\t\t\tvar type = _ref80.type;\n\t\t\t\tthis.$publish('index', { data: data, id: id, index: _index, type: type });\n\t\t\t}\n\t\t\t/**Searches for data*/\n\t\n\t\t}, {\n\t\t\tkey: 'search',\n\t\t\tvalue: function search(_ref81) {\n\t\t\t\tvar indices = _ref81.indices;\n\t\t\t\tvar page = _ref81.page;\n\t\t\t\tvar query = _ref81.query;\n\t\t\t\tvar sort = _ref81.sort;\n\t\t\t\tthis.$publish('search', { indices: indices, page: page, query: query, sort: sort });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to SearchService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'search_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Search;\n\t}(Service);\n\t/**\n\t * Template engine\n\t *\n\t * Template engine to produce documents from parameterized templates\n\t * <br>An admin creates templates\n\t * <br> Users produce documents\n\t * <br>The implementation uses the <a href='http://freemarker\n\t * org/'>freemarker</a> engine\n\t *\n\t * */\n\t/**\n\t * User API for templates\n\t *\n\t * Users use this API to evaluate pre-configured templates.\n\t * @access public\n\t * */\n\t\n\t\n\texports.Search = Search;\n\t\n\tvar Template = exports.Template = function (_Service17) {\n\t\t_inherits(Template, _Service17);\n\t\n\t\tfunction Template() {\n\t\t\t_classCallCheck(this, Template);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Template).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Template, [{\n\t\t\tkey: 'evaluate',\n\t\n\t\t\t/**\n\t   * Evaluates a template\n\t   *\n\t   * Evaluates the given template and returns the result as a string.\n\t   * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.\n\t   * */\n\t\t\tvalue: function evaluate(_ref82) {\n\t\t\t\tvar data = _ref82.data;\n\t\t\t\tvar languageTag = _ref82.languageTag;\n\t\t\t\tvar name = _ref82.name;\n\t\t\t\tvar requestId = _ref82.requestId;\n\t\t\t\tthis.$publish('evaluate', { data: data, languageTag: languageTag, name: name, requestId: requestId });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to TemplateService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'template_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Template;\n\t}(Service);\n\t/**\n\t * Upload: S3\n\t *\n\t * Upload service with S3 storage\n\t * */\n\t/**\n\t * User API for file management\n\t *\n\t * User API for virtual file management and http file upload\n\t * This API contains all the verbs needed to browse, upload and remove files.\n\t * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n\t * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Zpfs_s3 = exports.Zpfs_s3 = function (_Service18) {\n\t\t_inherits(Zpfs_s3, _Service18);\n\t\n\t\tfunction Zpfs_s3() {\n\t\t\t_classCallCheck(this, Zpfs_s3);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Zpfs_s3).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Zpfs_s3, [{\n\t\t\tkey: 'cp',\n\t\n\t\t\t/**\n\t   * Copies a file\n\t   *\n\t   * Copies a file or folder (recursively) to a new location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\t\tvalue: function cp(_ref83) {\n\t\t\t\tvar oldPath = _ref83.oldPath;\n\t\t\t\tvar owner = _ref83.owner;\n\t\t\t\tvar path = _ref83.path;\n\t\t\t\tthis.$publish('cp', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Returns disk usage\n\t   *\n\t   * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'du',\n\t\t\tvalue: function du(_ref84) {\n\t\t\t\tvar owner = _ref84.owner;\n\t\t\t\tvar path = _ref84.path;\n\t\t\t\tthis.$publish('du', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**Requests an upload URL without constraints.*/\n\t\n\t\t}, {\n\t\t\tkey: 'freeUploadUrl',\n\t\t\tvalue: function freeUploadUrl(_ref85) {\n\t\t\t\t_objectDestructuringEmpty(_ref85);\n\t\n\t\t\t\tthis.$publish('freeUploadUrl', {});\n\t\t\t}\n\t\t\t/**\n\t   * Links a file\n\t   *\n\t   * Links a file or folder to another location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'link',\n\t\t\tvalue: function link(_ref86) {\n\t\t\t\tvar oldPath = _ref86.oldPath;\n\t\t\t\tvar owner = _ref86.owner;\n\t\t\t\tvar path = _ref86.path;\n\t\t\t\tthis.$publish('link', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Lists a folder content\n\t   *\n\t   * Returns a paginated list of the folder's content.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'ls',\n\t\t\tvalue: function ls(_ref87) {\n\t\t\t\tvar folder = _ref87.folder;\n\t\t\t\tvar owner = _ref87.owner;\n\t\t\t\tvar page = _ref87.page;\n\t\t\t\tthis.$publish('ls', { folder: folder, owner: owner, page: page });\n\t\t\t}\n\t\t\t/**\n\t   * Creates a folder\n\t   *\n\t   * Creates a new folder.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mkdir',\n\t\t\tvalue: function mkdir(_ref88) {\n\t\t\t\tvar folder = _ref88.folder;\n\t\t\t\tvar owner = _ref88.owner;\n\t\t\t\tvar parents = _ref88.parents;\n\t\t\t\tthis.$publish('mkdir', { folder: folder, owner: owner, parents: parents });\n\t\t\t}\n\t\t\t/**\n\t   * Moves a file\n\t   *\n\t   * Moves a file or folder (recursively) to a new location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mv',\n\t\t\tvalue: function mv(_ref89) {\n\t\t\t\tvar oldPath = _ref89.oldPath;\n\t\t\t\tvar owner = _ref89.owner;\n\t\t\t\tvar path = _ref89.path;\n\t\t\t\tthis.$publish('mv', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Notifies of upload completion\n\t   *\n\t   * The client application calls this verb to notify that it's done uploading to the cloud.\n\t   * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'newFile',\n\t\t\tvalue: function newFile(_ref90) {\n\t\t\t\tvar guid = _ref90.guid;\n\t\t\t\tvar metadata = _ref90.metadata;\n\t\t\t\tvar owner = _ref90.owner;\n\t\t\t\tvar tags = _ref90.tags;\n\t\t\t\tthis.$publish('newFile', { guid: guid, metadata: metadata, owner: owner, tags: tags });\n\t\t\t}\n\t\t\t/**\n\t   * Requests an upload URL\n\t   *\n\t   * Requests an HTTP upload URL.\n\t   * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'newUploadUrl',\n\t\t\tvalue: function newUploadUrl(_ref91) {\n\t\t\t\tvar contentType = _ref91.contentType;\n\t\t\t\tvar owner = _ref91.owner;\n\t\t\t\tvar path = _ref91.path;\n\t\t\t\tthis.$publish('newUploadUrl', { contentType: contentType, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Removes a file\n\t   *\n\t   * Removes a file or folder (recursively).\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'rm',\n\t\t\tvalue: function rm(_ref92) {\n\t\t\t\tvar owner = _ref92.owner;\n\t\t\t\tvar path = _ref92.path;\n\t\t\t\tthis.$publish('rm', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Returns information about a file\n\t   *\n\t   * Returns information about a single file.\n\t   * The entry field will be null if the path does not exist\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'stat',\n\t\t\tvalue: function stat(_ref93) {\n\t\t\t\tvar owner = _ref93.owner;\n\t\t\t\tvar path = _ref93.path;\n\t\t\t\tthis.$publish('stat', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**Updates a file's metadata*/\n\t\n\t\t}, {\n\t\t\tkey: 'updateMeta',\n\t\t\tvalue: function updateMeta(_ref94) {\n\t\t\t\tvar metadata = _ref94.metadata;\n\t\t\t\tvar metadataFiles = _ref94.metadataFiles;\n\t\t\t\tvar owner = _ref94.owner;\n\t\t\t\tvar path = _ref94.path;\n\t\t\t\tthis.$publish('updateMeta', { metadata: metadata, metadataFiles: metadataFiles, owner: owner, path: path });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to Zpfs_s3Service\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'zpfs_s3_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Zpfs_s3;\n\t}(Service);\n\t/**\n\t * Upload: local\n\t *\n\t * Upload service with local HDFS storage\n\t * */\n\t/**\n\t * User API for file management\n\t *\n\t * User API for virtual file management and http file upload\n\t * This API contains all the verbs needed to browse, upload and remove files.\n\t * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n\t * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Zpfs_hdfs = exports.Zpfs_hdfs = function (_Service19) {\n\t\t_inherits(Zpfs_hdfs, _Service19);\n\t\n\t\tfunction Zpfs_hdfs() {\n\t\t\t_classCallCheck(this, Zpfs_hdfs);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Zpfs_hdfs).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Zpfs_hdfs, [{\n\t\t\tkey: 'cp',\n\t\n\t\t\t/**\n\t   * Copies a file\n\t   *\n\t   * Copies a file or folder (recursively) to a new location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\t\tvalue: function cp(_ref95) {\n\t\t\t\tvar oldPath = _ref95.oldPath;\n\t\t\t\tvar owner = _ref95.owner;\n\t\t\t\tvar path = _ref95.path;\n\t\t\t\tthis.$publish('cp', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Returns disk usage\n\t   *\n\t   * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'du',\n\t\t\tvalue: function du(_ref96) {\n\t\t\t\tvar owner = _ref96.owner;\n\t\t\t\tvar path = _ref96.path;\n\t\t\t\tthis.$publish('du', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**Requests an upload URL without constraints.*/\n\t\n\t\t}, {\n\t\t\tkey: 'freeUploadUrl',\n\t\t\tvalue: function freeUploadUrl(_ref97) {\n\t\t\t\t_objectDestructuringEmpty(_ref97);\n\t\n\t\t\t\tthis.$publish('freeUploadUrl', {});\n\t\t\t}\n\t\t\t/**\n\t   * Links a file\n\t   *\n\t   * Links a file or folder to another location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'link',\n\t\t\tvalue: function link(_ref98) {\n\t\t\t\tvar oldPath = _ref98.oldPath;\n\t\t\t\tvar owner = _ref98.owner;\n\t\t\t\tvar path = _ref98.path;\n\t\t\t\tthis.$publish('link', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Lists a folder content\n\t   *\n\t   * Returns a paginated list of the folder's content.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'ls',\n\t\t\tvalue: function ls(_ref99) {\n\t\t\t\tvar folder = _ref99.folder;\n\t\t\t\tvar owner = _ref99.owner;\n\t\t\t\tvar page = _ref99.page;\n\t\t\t\tthis.$publish('ls', { folder: folder, owner: owner, page: page });\n\t\t\t}\n\t\t\t/**\n\t   * Creates a folder\n\t   *\n\t   * Creates a new folder.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mkdir',\n\t\t\tvalue: function mkdir(_ref100) {\n\t\t\t\tvar folder = _ref100.folder;\n\t\t\t\tvar owner = _ref100.owner;\n\t\t\t\tvar parents = _ref100.parents;\n\t\t\t\tthis.$publish('mkdir', { folder: folder, owner: owner, parents: parents });\n\t\t\t}\n\t\t\t/**\n\t   * Moves a file\n\t   *\n\t   * Moves a file or folder (recursively) to a new location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mv',\n\t\t\tvalue: function mv(_ref101) {\n\t\t\t\tvar oldPath = _ref101.oldPath;\n\t\t\t\tvar owner = _ref101.owner;\n\t\t\t\tvar path = _ref101.path;\n\t\t\t\tthis.$publish('mv', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Notifies of upload completion\n\t   *\n\t   * The client application calls this verb to notify that it's done uploading to the cloud.\n\t   * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'newFile',\n\t\t\tvalue: function newFile(_ref102) {\n\t\t\t\tvar guid = _ref102.guid;\n\t\t\t\tvar metadata = _ref102.metadata;\n\t\t\t\tvar owner = _ref102.owner;\n\t\t\t\tvar tags = _ref102.tags;\n\t\t\t\tthis.$publish('newFile', { guid: guid, metadata: metadata, owner: owner, tags: tags });\n\t\t\t}\n\t\t\t/**\n\t   * Requests an upload URL\n\t   *\n\t   * Requests an HTTP upload URL.\n\t   * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'newUploadUrl',\n\t\t\tvalue: function newUploadUrl(_ref103) {\n\t\t\t\tvar contentType = _ref103.contentType;\n\t\t\t\tvar owner = _ref103.owner;\n\t\t\t\tvar path = _ref103.path;\n\t\t\t\tthis.$publish('newUploadUrl', { contentType: contentType, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Removes a file\n\t   *\n\t   * Removes a file or folder (recursively).\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'rm',\n\t\t\tvalue: function rm(_ref104) {\n\t\t\t\tvar owner = _ref104.owner;\n\t\t\t\tvar path = _ref104.path;\n\t\t\t\tthis.$publish('rm', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Returns information about a file\n\t   *\n\t   * Returns information about a single file.\n\t   * The entry field will be null if the path does not exist\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'stat',\n\t\t\tvalue: function stat(_ref105) {\n\t\t\t\tvar owner = _ref105.owner;\n\t\t\t\tvar path = _ref105.path;\n\t\t\t\tthis.$publish('stat', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**Updates a file's metadata*/\n\t\n\t\t}, {\n\t\t\tkey: 'updateMeta',\n\t\t\tvalue: function updateMeta(_ref106) {\n\t\t\t\tvar metadata = _ref106.metadata;\n\t\t\t\tvar metadataFiles = _ref106.metadataFiles;\n\t\t\t\tvar owner = _ref106.owner;\n\t\t\t\tvar path = _ref106.path;\n\t\t\t\tthis.$publish('updateMeta', { metadata: metadata, metadataFiles: metadataFiles, owner: owner, path: path });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to Zpfs_hdfsService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'zpfs_hdfs_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Zpfs_hdfs;\n\t}(Service);\n\t/**\n\t * Upload: pseudo-S3\n\t *\n\t * Upload service with pseudo-S3compatible storage\n\t * */\n\t/**\n\t * User API for file management\n\t *\n\t * User API for virtual file management and http file upload\n\t * This API contains all the verbs needed to browse, upload and remove files.\n\t * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n\t * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Zpfs_s3compat = exports.Zpfs_s3compat = function (_Service20) {\n\t\t_inherits(Zpfs_s3compat, _Service20);\n\t\n\t\tfunction Zpfs_s3compat() {\n\t\t\t_classCallCheck(this, Zpfs_s3compat);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Zpfs_s3compat).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Zpfs_s3compat, [{\n\t\t\tkey: 'cp',\n\t\n\t\t\t/**\n\t   * Copies a file\n\t   *\n\t   * Copies a file or folder (recursively) to a new location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\t\tvalue: function cp(_ref107) {\n\t\t\t\tvar oldPath = _ref107.oldPath;\n\t\t\t\tvar owner = _ref107.owner;\n\t\t\t\tvar path = _ref107.path;\n\t\t\t\tthis.$publish('cp', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Returns disk usage\n\t   *\n\t   * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'du',\n\t\t\tvalue: function du(_ref108) {\n\t\t\t\tvar owner = _ref108.owner;\n\t\t\t\tvar path = _ref108.path;\n\t\t\t\tthis.$publish('du', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**Requests an upload URL without constraints.*/\n\t\n\t\t}, {\n\t\t\tkey: 'freeUploadUrl',\n\t\t\tvalue: function freeUploadUrl(_ref109) {\n\t\t\t\t_objectDestructuringEmpty(_ref109);\n\t\n\t\t\t\tthis.$publish('freeUploadUrl', {});\n\t\t\t}\n\t\t\t/**\n\t   * Links a file\n\t   *\n\t   * Links a file or folder to another location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'link',\n\t\t\tvalue: function link(_ref110) {\n\t\t\t\tvar oldPath = _ref110.oldPath;\n\t\t\t\tvar owner = _ref110.owner;\n\t\t\t\tvar path = _ref110.path;\n\t\t\t\tthis.$publish('link', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Lists a folder content\n\t   *\n\t   * Returns a paginated list of the folder's content.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'ls',\n\t\t\tvalue: function ls(_ref111) {\n\t\t\t\tvar folder = _ref111.folder;\n\t\t\t\tvar owner = _ref111.owner;\n\t\t\t\tvar page = _ref111.page;\n\t\t\t\tthis.$publish('ls', { folder: folder, owner: owner, page: page });\n\t\t\t}\n\t\t\t/**\n\t   * Creates a folder\n\t   *\n\t   * Creates a new folder.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mkdir',\n\t\t\tvalue: function mkdir(_ref112) {\n\t\t\t\tvar folder = _ref112.folder;\n\t\t\t\tvar owner = _ref112.owner;\n\t\t\t\tvar parents = _ref112.parents;\n\t\t\t\tthis.$publish('mkdir', { folder: folder, owner: owner, parents: parents });\n\t\t\t}\n\t\t\t/**\n\t   * Moves a file\n\t   *\n\t   * Moves a file or folder (recursively) to a new location.\n\t   * May fail if the target location is not empty.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'mv',\n\t\t\tvalue: function mv(_ref113) {\n\t\t\t\tvar oldPath = _ref113.oldPath;\n\t\t\t\tvar owner = _ref113.owner;\n\t\t\t\tvar path = _ref113.path;\n\t\t\t\tthis.$publish('mv', { oldPath: oldPath, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Notifies of upload completion\n\t   *\n\t   * The client application calls this verb to notify that it's done uploading to the cloud.\n\t   * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'newFile',\n\t\t\tvalue: function newFile(_ref114) {\n\t\t\t\tvar guid = _ref114.guid;\n\t\t\t\tvar metadata = _ref114.metadata;\n\t\t\t\tvar owner = _ref114.owner;\n\t\t\t\tvar tags = _ref114.tags;\n\t\t\t\tthis.$publish('newFile', { guid: guid, metadata: metadata, owner: owner, tags: tags });\n\t\t\t}\n\t\t\t/**\n\t   * Requests an upload URL\n\t   *\n\t   * Requests an HTTP upload URL.\n\t   * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'newUploadUrl',\n\t\t\tvalue: function newUploadUrl(_ref115) {\n\t\t\t\tvar contentType = _ref115.contentType;\n\t\t\t\tvar owner = _ref115.owner;\n\t\t\t\tvar path = _ref115.path;\n\t\t\t\tthis.$publish('newUploadUrl', { contentType: contentType, owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Removes a file\n\t   *\n\t   * Removes a file or folder (recursively).\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'rm',\n\t\t\tvalue: function rm(_ref116) {\n\t\t\t\tvar owner = _ref116.owner;\n\t\t\t\tvar path = _ref116.path;\n\t\t\t\tthis.$publish('rm', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**\n\t   * Returns information about a file\n\t   *\n\t   * Returns information about a single file.\n\t   * The entry field will be null if the path does not exist\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'stat',\n\t\t\tvalue: function stat(_ref117) {\n\t\t\t\tvar owner = _ref117.owner;\n\t\t\t\tvar path = _ref117.path;\n\t\t\t\tthis.$publish('stat', { owner: owner, path: path });\n\t\t\t}\n\t\t\t/**Updates a file's metadata*/\n\t\n\t\t}, {\n\t\t\tkey: 'updateMeta',\n\t\t\tvalue: function updateMeta(_ref118) {\n\t\t\t\tvar metadata = _ref118.metadata;\n\t\t\t\tvar metadataFiles = _ref118.metadataFiles;\n\t\t\t\tvar owner = _ref118.owner;\n\t\t\t\tvar path = _ref118.path;\n\t\t\t\tthis.$publish('updateMeta', { metadata: metadata, metadataFiles: metadataFiles, owner: owner, path: path });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to Zpfs_s3compatService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'zpfs_s3compat_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Zpfs_s3compat;\n\t}(Service);\n\t/**\n\t * User directory service\n\t *\n\t * User directory service\n\t * */\n\t/**\n\t * User API for user information\n\t *\n\t * @access public\n\t * */\n\t\n\t\n\tvar Userdir = exports.Userdir = function (_Service21) {\n\t\t_inherits(Userdir, _Service21);\n\t\n\t\tfunction Userdir() {\n\t\t\t_classCallCheck(this, Userdir);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Userdir).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Userdir, [{\n\t\t\tkey: 'search',\n\t\n\t\t\t/**Searches for users matching the request*/\n\t\t\tvalue: function search(_ref119) {\n\t\t\t\tvar page = _ref119.page;\n\t\t\t\tvar query = _ref119.query;\n\t\t\t\tvar requestId = _ref119.requestId;\n\t\t\t\tthis.$publish('search', { page: page, query: query, requestId: requestId });\n\t\t\t}\n\t\t\t/**Requests public data for the specified users*/\n\t\n\t\t}, {\n\t\t\tkey: 'userInfo',\n\t\t\tvalue: function userInfo(_ref120) {\n\t\t\t\tvar userKeys = _ref120.userKeys;\n\t\t\t\tthis.$publish('userInfo', { userKeys: userKeys });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to UserdirService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'userdir_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Userdir;\n\t}(Service);\n\t/**\n\t * Delegating authentication\n\t *\n\t * This authentication delegates authentication to an external auth provider\n\t * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL\n\t * <br>The response must be in JSON format\n\t *  Each key of the response will be considered a user information field name\n\t *\n\t * */\n\t/**\n\t * End-user API for the delegating authentication\n\t *\n\t * Provisionning verbs.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Delegating = exports.Delegating = function (_Service22) {\n\t\t_inherits(Delegating, _Service22);\n\t\n\t\tfunction Delegating() {\n\t\t\t_classCallCheck(this, Delegating);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Delegating).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Delegating, [{\n\t\t\tkey: 'userInfo',\n\t\n\t\t\t/**\n\t   * Get user info\n\t   *\n\t   * Retrieves cached user info or (if missing) eagerly creates a zetapush key for the user.\n\t   * The returned field 'zetapushKey' is a unique and permanent ID identifying a user in a sandbox.\n\t   * */\n\t\t\tvalue: function userInfo(_ref121) {\n\t\t\t\t_objectDestructuringEmpty(_ref121);\n\t\n\t\t\t\tthis.$publish('userInfo', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to DelegatingService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'delegating_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Delegating;\n\t}(Service);\n\t/**\n\t * Local authentication\n\t *\n\t * Zetapush local authentication\n\t *  The configurer can choose the primary key and mandatory user fields for account creation\n\t *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)\n\t * */\n\t/**\n\t * End-user API for the simple local authentication\n\t *\n\t * These API verbs allow end-users to manage their account.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Simple = exports.Simple = function (_Service23) {\n\t\t_inherits(Simple, _Service23);\n\t\n\t\tfunction Simple() {\n\t\t\t_classCallCheck(this, Simple);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Simple).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Simple, [{\n\t\t\tkey: 'changePassword',\n\t\n\t\t\t/**\n\t   * Changes a password\n\t   *\n\t   * Changes a user password for this authentication realm.\n\t   * The user can be either implicit (the current user) or deduced from the token.\n\t   * The change is effective immediately. However, already logged in users might stay connected.\n\t   * */\n\t\t\tvalue: function changePassword(_ref122) {\n\t\t\t\t_objectDestructuringEmpty(_ref122);\n\t\n\t\t\t\tthis.$publish('changePassword', {});\n\t\t\t}\n\t\t\t/**\n\t   * Checks some account's existence\n\t   *\n\t   * Checks whether the given user already exists in this 'simple' authentication realm.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'checkUser',\n\t\t\tvalue: function checkUser(_ref123) {\n\t\t\t\t_objectDestructuringEmpty(_ref123);\n\t\n\t\t\t\tthis.$publish('checkUser', {});\n\t\t\t}\n\t\t\t/**\n\t   * Creates a user\n\t   *\n\t   * Creates a new user in this 'simple' authentication realm.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'createUser',\n\t\t\tvalue: function createUser(_ref124) {\n\t\t\t\t_objectDestructuringEmpty(_ref124);\n\t\n\t\t\t\tthis.$publish('createUser', {});\n\t\t\t}\n\t\t\t/**\n\t   * Deletes a user\n\t   *\n\t   * Deletes an existing user in this 'simple' authentication realm.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'deleteUser',\n\t\t\tvalue: function deleteUser(_ref125) {\n\t\t\t\t_objectDestructuringEmpty(_ref125);\n\t\n\t\t\t\tthis.$publish('deleteUser', {});\n\t\t\t}\n\t\t\t/**\n\t   * Requests a password reset\n\t   *\n\t   * Requests a password reset for the given unique key.\n\t   * The key must exist and must be given, as it cannot obviously be deduced from the currently logged in user.\n\t   * The returned token needs to be sent to the intended recipient only. The typical use case is to define a macro that requests a reset, generates a email template and emails the user. The macro can then be safely called by a weakly authenticated user.\n\t   * Requesting a reset does not invalidate the password.\n\t   * Requesting a reset again invalidates previous reset requests (only the last token is usable)\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'requestReset',\n\t\t\tvalue: function requestReset(_ref126) {\n\t\t\t\t_objectDestructuringEmpty(_ref126);\n\t\n\t\t\t\tthis.$publish('requestReset', {});\n\t\t\t}\n\t\t\t/**\n\t   * Updates a user\n\t   *\n\t   * Updates an existing user in this 'simple' authentication realm.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'updateUser',\n\t\t\tvalue: function updateUser(_ref127) {\n\t\t\t\t_objectDestructuringEmpty(_ref127);\n\t\n\t\t\t\tthis.$publish('updateUser', {});\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to SimpleService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'simple_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Simple;\n\t}(Service);\n\t/**\n\t * Weak authentication\n\t *\n\t * The weak authentication allows for anonymous authentication of devices\n\t *  Such devices can display a qrcode to allow regular users to take control of them\n\t * */\n\t/**\n\t * User API for weak devices control\n\t *\n\t * User API for control and release of weakly authenticated user sessions.\n\t * @access public\n\t * */\n\t\n\t\n\tvar Weak = exports.Weak = function (_Service24) {\n\t\t_inherits(Weak, _Service24);\n\t\n\t\tfunction Weak() {\n\t\t\t_classCallCheck(this, Weak);\n\t\n\t\t\treturn _possibleConstructorReturn(this, Object.getPrototypeOf(Weak).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(Weak, [{\n\t\t\tkey: 'control',\n\t\n\t\t\t/**\n\t   * Controls a session\n\t   *\n\t   * Takes control of a weak user session, identified by the given public token.\n\t   * The public token has been previously made available by the controlled device, for example by displaying a QRCode.\n\t   * Upon control notification, the client SDK of the controlled session is expected to re-handshake.\n\t   * */\n\t\t\tvalue: function control(_ref128) {\n\t\t\t\tvar fullRights = _ref128.fullRights;\n\t\t\t\tvar publicToken = _ref128.publicToken;\n\t\t\t\tthis.$publish('control', { fullRights: fullRights, publicToken: publicToken });\n\t\t\t}\n\t\t\t/**\n\t   * Releases a session\n\t   *\n\t   * Releases control of a weak user session, identified by the given public token.\n\t   * The weak user session must have been previously controlled by a call to 'control'.\n\t   * */\n\t\n\t\t}, {\n\t\t\tkey: 'release',\n\t\t\tvalue: function release(_ref129) {\n\t\t\t\tvar fullRights = _ref129.fullRights;\n\t\t\t\tvar publicToken = _ref129.publicToken;\n\t\t\t\tthis.$publish('release', { fullRights: fullRights, publicToken: publicToken });\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'DEFAULT_DEPLOYMENT_ID',\n\t\n\t\t\t/**\n\t   * Get default deployment id associated to WeakService\n\t   * @return {string}\n\t   */\n\t\t\tget: function get() {\n\t\t\t\treturn 'weak_0';\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Weak;\n\t}(Service);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Define life cycle connection methods\n\t * @access public\n\t */\n\t\n\tvar ConnectionStatusListener = exports.ConnectionStatusListener = function () {\n\t  function ConnectionStatusListener() {\n\t    _classCallCheck(this, ConnectionStatusListener);\n\t  }\n\t\n\t  _createClass(ConnectionStatusListener, [{\n\t    key: \"onConnectionBroken\",\n\t\n\t    /**\n\t     * Callback fired when connection is broken\n\t     */\n\t    value: function onConnectionBroken() {}\n\t    /**\n\t     * Callback fired when connection is closed\n\t     */\n\t\n\t  }, {\n\t    key: \"onConnectionClosed\",\n\t    value: function onConnectionClosed() {}\n\t    /**\n\t     * Callback fired when connection is established\n\t     */\n\t\n\t  }, {\n\t    key: \"onConnectionEstablished\",\n\t    value: function onConnectionEstablished() {}\n\t    /**\n\t    * Callback fired when connection will close\n\t    */\n\t\n\t  }, {\n\t    key: \"onConnectionWillClose\",\n\t    value: function onConnectionWillClose() {}\n\t    /**\n\t     * Callback fired when an error occurs in handshake step\n\t     * @param {Object} error\n\t     */\n\t\n\t  }, {\n\t    key: \"onFailedHandshake\",\n\t    value: function onFailedHandshake(error) {}\n\t    /**\n\t     * Callback fired when a message is lost\n\t     */\n\t\n\t  }, {\n\t    key: \"onMessageLost\",\n\t    value: function onMessageLost() {}\n\t    /**\n\t     * Callback fired when handshake step succeed\n\t     * @param {Object} authentication\n\t     */\n\t\n\t  }, {\n\t    key: \"onSuccessfulHandshake\",\n\t    value: function onSuccessfulHandshake(authentication) {}\n\t  }]);\n\n\t  return ConnectionStatusListener;\n\t}();\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.TransportLayers = exports.TransportTypes = undefined;\n\texports.FetchLongPollingTransport = FetchLongPollingTransport;\n\t\n\tvar _zetapushCometd = __webpack_require__(7);\n\t\n\t/**\n\t * Implements LongPollingTransport using borwser fetch() API\n\t * @access private\n\t * @return {FetchLongPollingTransport}\n\t */\n\tfunction FetchLongPollingTransport() {\n\t  var _super = new _zetapushCometd.LongPollingTransport();\n\t  var that = _zetapushCometd.Transport.derive(_super);\n\t\n\t  /**\n\t   * Implements transport via fetch() API\n\t   * @param {Object} packet\n\t   */\n\t  that.xhrSend = function (packet) {\n\t    fetch(packet.url, {\n\t      method: 'post',\n\t      body: packet.body,\n\t      headers: Object.assign(packet.headers, {\n\t        'Content-Type': 'application/json;charset=UTF-8'\n\t      })\n\t    }).then(function (response) {\n\t      return response.json();\n\t    }).then(packet.onSuccess).catch(packet.onError);\n\t  };\n\t\n\t  return that;\n\t}\n\t\n\t/**\n\t * CometD Transports enumeration\n\t */\n\tvar TransportTypes = exports.TransportTypes = {\n\t  LONG_POLLING: 'long-polling',\n\t  WEBSOCKET: 'websocket'\n\t};\n\t\n\t/**\n\t * CometD Transports Layers map\n\t */\n\tvar TransportLayers = exports.TransportLayers = [{\n\t  type: TransportTypes.WEBSOCKET,\n\t  Transport: _zetapushCometd.WebSocketTransport\n\t}, {\n\t  type: TransportTypes.LONG_POLLING,\n\t  Transport: FetchLongPollingTransport\n\t}];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t  CallbackPollingTransport: __webpack_require__(8),\n\t  CometD: __webpack_require__(12),\n\t  LongPollingTransport: __webpack_require__(14),\n\t  RequestTransport: __webpack_require__(11),\n\t  Transport: __webpack_require__(9),\n\t  TransportRegistry: __webpack_require__(13),\n\t  Utils: __webpack_require__(10),\n\t  WebSocketTransport: __webpack_require__(15)\n\t}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Transport = __webpack_require__(9);\n\tvar RequestTransport = __webpack_require__(11);\n\t\n\tmodule.exports = function CallbackPollingTransport() {\n\t    var _super = new RequestTransport();\n\t    var _self = Transport.derive(_super);\n\t\n\t    _self.accept = function(version, crossDomain, url) {\n\t        return true;\n\t    };\n\t\n\t    _self.jsonpSend = function(packet) {\n\t        throw 'Abstract';\n\t    };\n\t\n\t    function _failTransportFn(envelope, request, x) {\n\t        var self = this;\n\t        return function() {\n\t            self.transportFailure(envelope, request, 'error', x);\n\t        };\n\t    }\n\t\n\t    _self.transportSend = function(envelope, request) {\n\t        var self = this;\n\t\n\t        // Microsoft Internet Explorer has a 2083 URL max length\n\t        // We must ensure that we stay within that length\n\t        var start = 0;\n\t        var length = envelope.messages.length;\n\t        var lengths = [];\n\t        while (length > 0) {\n\t            // Encode the messages because all brackets, quotes, commas, colons, etc\n\t            // present in the JSON will be URL encoded, taking many more characters\n\t            var json = JSON.stringify(envelope.messages.slice(start, start + length));\n\t            var urlLength = envelope.url.length + encodeURI(json).length;\n\t\n\t            var maxLength = this.getConfiguration().maxURILength;\n\t            if (urlLength > maxLength) {\n\t                if (length === 1) {\n\t                    var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +\n\t                        'for transport ' + this.getType();\n\t                    // Keep the semantic of calling response callbacks asynchronously after the request\n\t                    self.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);\n\t                    return;\n\t                }\n\t\n\t                --length;\n\t                continue;\n\t            }\n\t\n\t            lengths.push(length);\n\t            start += length;\n\t            length = envelope.messages.length - start;\n\t        }\n\t\n\t        // Here we are sure that the messages can be sent within the URL limit\n\t\n\t        var envelopeToSend = envelope;\n\t        if (lengths.length > 1) {\n\t            var begin = 0;\n\t            var end = lengths[0];\n\t            this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));\n\t            envelopeToSend = this._mixin(false, {}, envelope);\n\t            envelopeToSend.messages = envelope.messages.slice(begin, end);\n\t            envelopeToSend.onSuccess = envelope.onSuccess;\n\t            envelopeToSend.onFailure = envelope.onFailure;\n\t\n\t            for (var i = 1; i < lengths.length; ++i) {\n\t                var nextEnvelope = this._mixin(false, {}, envelope);\n\t                begin = end;\n\t                end += lengths[i];\n\t                nextEnvelope.messages = envelope.messages.slice(begin, end);\n\t                nextEnvelope.onSuccess = envelope.onSuccess;\n\t                nextEnvelope.onFailure = envelope.onFailure;\n\t                this.send(nextEnvelope, request.metaConnect);\n\t            }\n\t        }\n\t\n\t        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);\n\t\n\t        try {\n\t            var sameStack = true;\n\t            this.jsonpSend({\n\t                transport: this,\n\t                url: envelopeToSend.url,\n\t                sync: envelopeToSend.sync,\n\t                headers: this.getConfiguration().requestHeaders,\n\t                body: JSON.stringify(envelopeToSend.messages),\n\t                onSuccess: function(responses) {\n\t                    var success = false;\n\t                    try {\n\t                        var received = self.convertToMessages(responses);\n\t                        if (received.length === 0) {\n\t                            self.transportFailure(envelopeToSend, request, {\n\t                                httpCode: 204\n\t                            });\n\t                        } else {\n\t                            success = true;\n\t                            self.transportSuccess(envelopeToSend, request, received);\n\t                        }\n\t                    } catch (x) {\n\t                        self._debug(x);\n\t                        if (!success) {\n\t                            self.transportFailure(envelopeToSend, request, {\n\t                                exception: x\n\t                            });\n\t                        }\n\t                    }\n\t                },\n\t                onError: function(reason, exception) {\n\t                    var failure = {\n\t                        reason: reason,\n\t                        exception: exception\n\t                    };\n\t                    if (sameStack) {\n\t                        // Keep the semantic of calling response callbacks asynchronously after the request\n\t                        self.setTimeout(function() {\n\t                            self.transportFailure(envelopeToSend, request, failure);\n\t                        }, 0);\n\t                    } else {\n\t                        self.transportFailure(envelopeToSend, request, failure);\n\t                    }\n\t                }\n\t            });\n\t            sameStack = false;\n\t        } catch (xx) {\n\t            // Keep the semantic of calling response callbacks asynchronously after the request\n\t            self.setTimeout(function() {\n\t                self.transportFailure(envelopeToSend, request, {\n\t                    exception: xx\n\t                });\n\t            }, 0);\n\t        }\n\t    };\n\t\n\t    return _self;\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Utils = __webpack_require__(10)\n\t\n\t/**\n\t * Base object with the common functionality for transports.\n\t */\n\tmodule.exports = function Transport() {\n\t    var _type;\n\t    var _cometd;\n\t    var _url;\n\t\n\t    /**\n\t     * Function invoked just after a transport has been successfully registered.\n\t     * @param type the type of transport (for example 'long-polling')\n\t     * @param cometd the cometd object this transport has been registered to\n\t     * @see #unregistered()\n\t     */\n\t    this.registered = function(type, cometd) {\n\t        _type = type;\n\t        _cometd = cometd;\n\t    };\n\t\n\t    /**\n\t     * Function invoked just after a transport has been successfully unregistered.\n\t     * @see #registered(type, cometd)\n\t     */\n\t    this.unregistered = function() {\n\t        _type = null;\n\t        _cometd = null;\n\t    };\n\t\n\t    this._debug = function() {\n\t        _cometd._debug.apply(_cometd, arguments);\n\t    };\n\t\n\t    this._mixin = function() {\n\t        return _cometd._mixin.apply(_cometd, arguments);\n\t    };\n\t\n\t    this.getConfiguration = function() {\n\t        return _cometd.getConfiguration();\n\t    };\n\t\n\t    this.getAdvice = function() {\n\t        return _cometd.getAdvice();\n\t    };\n\t\n\t    this.setTimeout = function(funktion, delay) {\n\t        return Utils.setTimeout(_cometd, funktion, delay);\n\t    };\n\t\n\t    this.clearTimeout = function(handle) {\n\t        Utils.clearTimeout(handle);\n\t    };\n\t\n\t    /**\n\t     * Converts the given response into an array of bayeux messages\n\t     * @param response the response to convert\n\t     * @return an array of bayeux messages obtained by converting the response\n\t     */\n\t    this.convertToMessages = function(response) {\n\t        if (Utils.isString(response)) {\n\t            try {\n\t                return JSON.parse(response);\n\t            } catch (x) {\n\t                this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n\t                throw x;\n\t            }\n\t        }\n\t        if (Utils.isArray(response)) {\n\t            return response;\n\t        }\n\t        if (response === undefined || response === null) {\n\t            return [];\n\t        }\n\t        if (response instanceof Object) {\n\t            return [response];\n\t        }\n\t        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n\t    };\n\t\n\t    /**\n\t     * Returns whether this transport can work for the given version and cross domain communication case.\n\t     * @param version a string indicating the transport version\n\t     * @param crossDomain a boolean indicating whether the communication is cross domain\n\t     * @param url the URL to connect to\n\t     * @return true if this transport can work for the given version and cross domain communication case,\n\t     * false otherwise\n\t     */\n\t    this.accept = function(version, crossDomain, url) {\n\t        throw 'Abstract';\n\t    };\n\t\n\t    /**\n\t     * Returns the type of this transport.\n\t     * @see #registered(type, cometd)\n\t     */\n\t    this.getType = function() {\n\t        return _type;\n\t    };\n\t\n\t    this.getURL = function() {\n\t        return _url;\n\t    };\n\t\n\t    this.setURL = function(url) {\n\t        _url = url;\n\t    };\n\t\n\t    this.send = function(envelope, metaConnect) {\n\t        throw 'Abstract';\n\t    };\n\t\n\t    this.reset = function(init) {\n\t        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n\t    };\n\t\n\t    this.abort = function() {\n\t        this._debug('Transport', _type, 'aborted');\n\t    };\n\t\n\t    this.toString = function() {\n\t        return this.getType();\n\t    };\n\t};\n\t\n\tmodule.exports.derive = function(baseObject) {\n\t    function F() {\n\t    }\n\t\n\t    F.prototype = baseObject;\n\t    return new F();\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\texports.isString = function (value) {\n\t    if (value === undefined || value === null) {\n\t        return false;\n\t    }\n\t    return typeof value === 'string' || value instanceof String;\n\t};\n\t\n\texports.isArray = function (value) {\n\t    if (value === undefined || value === null) {\n\t        return false;\n\t    }\n\t    return value instanceof Array;\n\t};\n\t\n\t/**\n\t * Returns whether the given element is contained into the given array.\n\t * @param element the element to check presence for\n\t * @param array the array to check for the element presence\n\t * @return the index of the element, if present, or a negative index if the element is not present\n\t */\n\texports.inArray = function (element, array) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t        if (element === array[i]) {\n\t            return i;\n\t        }\n\t    }\n\t    return -1;\n\t};\n\t\n\texports.setTimeout = function (cometd, funktion, delay) {\n\t    return setTimeout(function() {\n\t        try {\n\t            cometd._debug('Invoking timed function', funktion);\n\t            funktion();\n\t        } catch (x) {\n\t            cometd._debug('Exception invoking timed function', funktion, x);\n\t        }\n\t    }, delay);\n\t};\n\t\n\texports.clearTimeout = function (timeoutHandle) {\n\t    clearTimeout(timeoutHandle);\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Transport = __webpack_require__(9)\n\tvar Utils = __webpack_require__(10)\n\t\n\t/**\n\t * Base object with the common functionality for transports based on requests.\n\t * The key responsibility is to allow at most 2 outstanding requests to the server,\n\t * to avoid that requests are sent behind a long poll.\n\t * To achieve this, we have one reserved request for the long poll, and all other\n\t * requests are serialized one after the other.\n\t */\n\tmodule.exports = function RequestTransport() {\n\t    var _super = new Transport();\n\t    var _self = Transport.derive(_super);\n\t    var _requestIds = 0;\n\t    var _metaConnectRequest = null;\n\t    var _requests = [];\n\t    var _envelopes = [];\n\t\n\t    function _coalesceEnvelopes(envelope) {\n\t        while (_envelopes.length > 0) {\n\t            var envelopeAndRequest = _envelopes[0];\n\t            var newEnvelope = envelopeAndRequest[0];\n\t            var newRequest = envelopeAndRequest[1];\n\t            if (newEnvelope.url === envelope.url &&\n\t                newEnvelope.sync === envelope.sync) {\n\t                _envelopes.shift();\n\t                envelope.messages = envelope.messages.concat(newEnvelope.messages);\n\t                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n\t                continue;\n\t            }\n\t            break;\n\t        }\n\t    }\n\t\n\t    function _transportSend(envelope, request) {\n\t        this.transportSend(envelope, request);\n\t        request.expired = false;\n\t\n\t        if (!envelope.sync) {\n\t            var maxDelay = this.getConfiguration().maxNetworkDelay;\n\t            var delay = maxDelay;\n\t            if (request.metaConnect === true) {\n\t                delay += this.getAdvice().timeout;\n\t            }\n\t\n\t            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\t\n\t            var self = this;\n\t            request.timeout = self.setTimeout(function() {\n\t                request.expired = true;\n\t                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n\t                var failure = {\n\t                    reason: errorMessage\n\t                };\n\t                var xhr = request.xhr;\n\t                failure.httpCode = self.xhrStatus(xhr);\n\t                self.abortXHR(xhr);\n\t                self._debug(errorMessage);\n\t                self.complete(request, false, request.metaConnect);\n\t                envelope.onFailure(xhr, envelope.messages, failure);\n\t            }, delay);\n\t        }\n\t    }\n\t\n\t    function _queueSend(envelope) {\n\t        var requestId = ++_requestIds;\n\t        var request = {\n\t            id: requestId,\n\t            metaConnect: false,\n\t            envelope: envelope\n\t        };\n\t\n\t        // Consider the metaConnect requests which should always be present\n\t        if (_requests.length < this.getConfiguration().maxConnections - 1) {\n\t            _requests.push(request);\n\t            _transportSend.call(this, envelope, request);\n\t        } else {\n\t            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n\t            _envelopes.push([envelope, request]);\n\t        }\n\t    }\n\t\n\t    function _metaConnectComplete(request) {\n\t        var requestId = request.id;\n\t        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);\n\t        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n\t            throw 'Longpoll request mismatch, completing request ' + requestId;\n\t        }\n\t\n\t        // Reset metaConnect request\n\t        _metaConnectRequest = null;\n\t    }\n\t\n\t    function _complete(request, success) {\n\t        var index = Utils.inArray(request, _requests);\n\t        // The index can be negative if the request has been aborted\n\t        if (index >= 0) {\n\t            _requests.splice(index, 1);\n\t        }\n\t\n\t        if (_envelopes.length > 0) {\n\t            var envelopeAndRequest = _envelopes.shift();\n\t            var nextEnvelope = envelopeAndRequest[0];\n\t            var nextRequest = envelopeAndRequest[1];\n\t            this._debug('Transport dequeued request', nextRequest.id);\n\t            if (success) {\n\t                if (this.getConfiguration().autoBatch) {\n\t                    _coalesceEnvelopes.call(this, nextEnvelope);\n\t                }\n\t                _queueSend.call(this, nextEnvelope);\n\t                this._debug('Transport completed request', request.id, nextEnvelope);\n\t            } else {\n\t                // Keep the semantic of calling response callbacks asynchronously after the request\n\t                var self = this;\n\t                self.setTimeout(function() {\n\t                    self.complete(nextRequest, false, nextRequest.metaConnect);\n\t                    var failure = {\n\t                        reason: 'Previous request failed'\n\t                    };\n\t                    var xhr = nextRequest.xhr;\n\t                    failure.httpCode = self.xhrStatus(xhr);\n\t                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n\t                }, 0);\n\t            }\n\t        }\n\t    }\n\t\n\t    _self.complete = function(request, success, metaConnect) {\n\t        if (metaConnect) {\n\t            _metaConnectComplete.call(this, request);\n\t        } else {\n\t            _complete.call(this, request, success);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Performs the actual send depending on the transport type details.\n\t     * @param envelope the envelope to send\n\t     * @param request the request information\n\t     */\n\t    _self.transportSend = function(envelope, request) {\n\t        throw 'Abstract';\n\t    };\n\t\n\t    _self.transportSuccess = function(envelope, request, responses) {\n\t        if (!request.expired) {\n\t            this.clearTimeout(request.timeout);\n\t            this.complete(request, true, request.metaConnect);\n\t            if (responses && responses.length > 0) {\n\t                envelope.onSuccess(responses);\n\t            } else {\n\t                envelope.onFailure(request.xhr, envelope.messages, {\n\t                    httpCode: 204\n\t                });\n\t            }\n\t        }\n\t    };\n\t\n\t    _self.transportFailure = function(envelope, request, failure) {\n\t        if (!request.expired) {\n\t            this.clearTimeout(request.timeout);\n\t            this.complete(request, false, request.metaConnect);\n\t            envelope.onFailure(request.xhr, envelope.messages, failure);\n\t        }\n\t    };\n\t\n\t    function _metaConnectSend(envelope) {\n\t        if (_metaConnectRequest !== null) {\n\t            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n\t        }\n\t\n\t        var requestId = ++_requestIds;\n\t        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);\n\t        var request = {\n\t            id: requestId,\n\t            metaConnect: true,\n\t            envelope: envelope\n\t        };\n\t        _transportSend.call(this, envelope, request);\n\t        _metaConnectRequest = request;\n\t    }\n\t\n\t    _self.send = function(envelope, metaConnect) {\n\t        if (metaConnect) {\n\t            _metaConnectSend.call(this, envelope);\n\t        } else {\n\t            _queueSend.call(this, envelope);\n\t        }\n\t    };\n\t\n\t    _self.abort = function() {\n\t        _super.abort();\n\t        for (var i = 0; i < _requests.length; ++i) {\n\t            var request = _requests[i];\n\t            if (request) {\n\t                this._debug('Aborting request', request);\n\t                if (!this.abortXHR(request.xhr)) {\n\t                    this.transportFailure(request.envelope, request, {reason: 'abort'});\n\t                }\n\t            }\n\t        }\n\t        if (_metaConnectRequest) {\n\t            this._debug('Aborting metaConnect request', _metaConnectRequest);\n\t            if (!this.abortXHR(_metaConnectRequest.xhr)) {\n\t                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});\n\t            }\n\t        }\n\t        this.reset(true);\n\t    };\n\t\n\t    _self.reset = function(init) {\n\t        _super.reset(init);\n\t        _metaConnectRequest = null;\n\t        _requests = [];\n\t        _envelopes = [];\n\t    };\n\t\n\t    _self.abortXHR = function(xhr) {\n\t        if (xhr) {\n\t            try {\n\t                var state = xhr.readyState;\n\t                xhr.abort();\n\t                return state !== XMLHttpRequest.UNSENT;\n\t            } catch (x) {\n\t                this._debug(x);\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    _self.xhrStatus = function(xhr) {\n\t        if (xhr) {\n\t            try {\n\t                return xhr.status;\n\t            } catch (x) {\n\t                this._debug(x);\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    return _self;\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar TransportRegistry = __webpack_require__(13)\n\tvar Utils = __webpack_require__(10)\n\t/**\n\t * The constructor for a CometD object, identified by an optional name.\n\t * The default name is the string 'default'.\n\t * In the rare case a page needs more than one Bayeux conversation,\n\t * a new instance can be created via:\n\t * <pre>\n\t * var bayeuxUrl2 = ...;\n\t *\n\t * // Dojo style\n\t * var cometd2 = new dojox.CometD('another_optional_name');\n\t *\n\t * // jQuery style\n\t * var cometd2 = new $.CometD('another_optional_name');\n\t *\n\t * cometd2.init({url: bayeuxUrl2});\n\t * </pre>\n\t * @param name the optional name of this cometd object\n\t */\n\tmodule.exports = function CometD(name) {\n\t    var _cometd = this;\n\t    var _name = name || 'default';\n\t    var _crossDomain = false;\n\t    var _transports = new TransportRegistry();\n\t    var _transport;\n\t    var _status = 'disconnected';\n\t    var _messageId = 0;\n\t    var _clientId = null;\n\t    var _batch = 0;\n\t    var _messageQueue = [];\n\t    var _internalBatch = false;\n\t    var _listeners = {};\n\t    var _backoff = 0;\n\t    var _scheduledSend = null;\n\t    var _extensions = [];\n\t    var _advice = {};\n\t    var _handshakeProps;\n\t    var _handshakeCallback;\n\t    var _callbacks = {};\n\t    var _remoteCalls = {};\n\t    var _reestablish = false;\n\t    var _connected = false;\n\t    var _unconnectTime = 0;\n\t    var _handshakeMessages = 0;\n\t    var _config = {\n\t        protocol: null,\n\t        stickyReconnect: true,\n\t        connectTimeout: 0,\n\t        maxConnections: 2,\n\t        backoffIncrement: 1000,\n\t        maxBackoff: 60000,\n\t        logLevel: 'info',\n\t        reverseIncomingExtensions: true,\n\t        maxNetworkDelay: 10000,\n\t        requestHeaders: {},\n\t        appendMessageTypeToURL: true,\n\t        autoBatch: false,\n\t        urls: {},\n\t        maxURILength: 2000,\n\t        advice: {\n\t            timeout: 60000,\n\t            interval: 0,\n\t            reconnect: 'retry',\n\t            maxInterval: 0\n\t        }\n\t    };\n\t\n\t    function _fieldValue(object, name) {\n\t        try {\n\t            return object[name];\n\t        } catch (x) {\n\t            return undefined;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Mixes in the given objects into the target object by copying the properties.\n\t     * @param deep if the copy must be deep\n\t     * @param target the target object\n\t     * @param objects the objects whose properties are copied into the target\n\t     */\n\t    this._mixin = function(deep, target, objects) {\n\t        var result = target || {};\n\t\n\t        // Skip first 2 parameters (deep and target), and loop over the others\n\t        for (var i = 2; i < arguments.length; ++i) {\n\t            var object = arguments[i];\n\t\n\t            if (object === undefined || object === null) {\n\t                continue;\n\t            }\n\t\n\t            for (var propName in object) {\n\t                if (object.hasOwnProperty(propName)) {\n\t                    var prop = _fieldValue(object, propName);\n\t                    var targ = _fieldValue(result, propName);\n\t\n\t                    // Avoid infinite loops\n\t                    if (prop === target) {\n\t                        continue;\n\t                    }\n\t                    // Do not mixin undefined values\n\t                    if (prop === undefined) {\n\t                        continue;\n\t                    }\n\t\n\t                    if (deep && typeof prop === 'object' && prop !== null) {\n\t                        if (prop instanceof Array) {\n\t                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n\t                        } else {\n\t                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n\t                            result[propName] = this._mixin(deep, source, prop);\n\t                        }\n\t                    } else {\n\t                        result[propName] = prop;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    };\n\t\n\t    function _isString(value) {\n\t        return Utils.isString(value);\n\t    }\n\t\n\t    function _isFunction(value) {\n\t        if (value === undefined || value === null) {\n\t            return false;\n\t        }\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    function _zeroPad(value, length) {\n\t        var result = '';\n\t        while (--length > 0) {\n\t            if (value >= Math.pow(10, length)) {\n\t                break;\n\t            }\n\t            result += '0';\n\t        }\n\t        result += value;\n\t        return result;\n\t    }\n\t\n\t    function _log(level, args) {\n\t        if ('undefined' !== typeof console) {\n\t            var logger = console[level];\n\t            if (_isFunction(logger)) {\n\t                var now = new Date();\n\t                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n\t                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n\t                logger.apply(console, args);\n\t            }\n\t        }\n\t    }\n\t\n\t    this._warn = function() {\n\t        _log('warn', arguments);\n\t    };\n\t\n\t    this._info = function() {\n\t        if (_config.logLevel !== 'warn') {\n\t            _log('info', arguments);\n\t        }\n\t    };\n\t\n\t    this._debug = function() {\n\t        if (_config.logLevel === 'debug') {\n\t            _log('debug', arguments);\n\t        }\n\t    };\n\t\n\t    function _splitURL(url) {\n\t        // [1] = protocol://,\n\t        // [2] = host:port,\n\t        // [3] = host,\n\t        // [4] = IPv6_host,\n\t        // [5] = IPv4_host,\n\t        // [6] = :port,\n\t        // [7] = port,\n\t        // [8] = uri,\n\t        // [9] = rest (query / fragment)\n\t        return /(^https?:\\/\\/)?(((\\[[^\\]]+\\])|([^:\\/\\?#]+))(:(\\d+))?)?([^\\?#]*)(.*)?/.exec(url);\n\t    }\n\t\n\t    /**\n\t     * Returns whether the given hostAndPort is cross domain.\n\t     * The default implementation checks against window.location.host\n\t     * but this function can be overridden to make it work in non-browser\n\t     * environments.\n\t     *\n\t     * @param hostAndPort the host and port in format host:port\n\t     * @return whether the given hostAndPort is cross domain\n\t     */\n\t    this._isCrossDomain = function(hostAndPort) {\n\t        return hostAndPort && hostAndPort !== window.location.host;\n\t    };\n\t\n\t    function _configure(configuration) {\n\t        _cometd._debug('Configuring cometd object with', configuration);\n\t        // Support old style param, where only the Bayeux server URL was passed\n\t        if (_isString(configuration)) {\n\t            configuration = { url: configuration };\n\t        }\n\t        if (!configuration) {\n\t            configuration = {};\n\t        }\n\t\n\t        _config = _cometd._mixin(false, _config, configuration);\n\t\n\t        var url = _cometd.getURL();\n\t        if (!url) {\n\t            throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n\t        }\n\t\n\t        // Check if we're cross domain.\n\t        var urlParts = _splitURL(url);\n\t        var hostAndPort = urlParts[2];\n\t        var uri = urlParts[8];\n\t        var afterURI = urlParts[9];\n\t        _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\t\n\t        // Check if appending extra path is supported\n\t        if (_config.appendMessageTypeToURL) {\n\t            if (afterURI !== undefined && afterURI.length > 0) {\n\t                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n\t                _config.appendMessageTypeToURL = false;\n\t            } else {\n\t                var uriSegments = uri.split('/');\n\t                var lastSegmentIndex = uriSegments.length - 1;\n\t                if (uri.match(/\\/$/)) {\n\t                    lastSegmentIndex -= 1;\n\t                }\n\t                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n\t                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n\t                    // It will be difficult to add the extra path in this case\n\t                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n\t                    _config.appendMessageTypeToURL = false;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function _removeListener(subscription) {\n\t        if (subscription) {\n\t            var subscriptions = _listeners[subscription.channel];\n\t            if (subscriptions && subscriptions[subscription.id]) {\n\t                delete subscriptions[subscription.id];\n\t                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n\t            }\n\t        }\n\t    }\n\t\n\t    function _removeSubscription(subscription) {\n\t        if (subscription && !subscription.listener) {\n\t            _removeListener(subscription);\n\t        }\n\t    }\n\t\n\t    function _clearSubscriptions() {\n\t        for (var channel in _listeners) {\n\t            if (_listeners.hasOwnProperty(channel)) {\n\t                var subscriptions = _listeners[channel];\n\t                if (subscriptions) {\n\t                    for (var i = 0; i < subscriptions.length; ++i) {\n\t                        _removeSubscription(subscriptions[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function _setStatus(newStatus) {\n\t        if (_status !== newStatus) {\n\t            _cometd._debug('Status', _status, '->', newStatus);\n\t            _status = newStatus;\n\t        }\n\t    }\n\t\n\t    function _isDisconnected() {\n\t        return _status === 'disconnecting' || _status === 'disconnected';\n\t    }\n\t\n\t    function _nextMessageId() {\n\t        var result = ++_messageId;\n\t        return '' + result;\n\t    }\n\t\n\t    function _applyExtension(scope, callback, name, message, outgoing) {\n\t        try {\n\t            return callback.call(scope, message);\n\t        } catch (x) {\n\t            var handler = _cometd.onExtensionException;\n\t            if (_isFunction(handler)) {\n\t                _cometd._debug('Invoking extension exception handler', name, x);\n\t                try {\n\t                    handler.call(_cometd, x, name, outgoing, message);\n\t                } catch (xx) {\n\t                    _cometd._info('Exception during execution of extension exception handler', name, xx);\n\t                }\n\t            } else {\n\t                _cometd._info('Exception during execution of extension', name, x);\n\t            }\n\t            return message;\n\t        }\n\t    }\n\t\n\t    function _applyIncomingExtensions(message) {\n\t        for (var i = 0; i < _extensions.length; ++i) {\n\t            if (message === undefined || message === null) {\n\t                break;\n\t            }\n\t\n\t            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;\n\t            var extension = _extensions[index];\n\t            var callback = extension.extension.incoming;\n\t            if (_isFunction(callback)) {\n\t                var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n\t                message = result === undefined ? message : result;\n\t            }\n\t        }\n\t        return message;\n\t    }\n\t\n\t    function _applyOutgoingExtensions(message) {\n\t        for (var i = 0; i < _extensions.length; ++i) {\n\t            if (message === undefined || message === null) {\n\t                break;\n\t            }\n\t\n\t            var extension = _extensions[i];\n\t            var callback = extension.extension.outgoing;\n\t            if (_isFunction(callback)) {\n\t                var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n\t                message = result === undefined ? message : result;\n\t            }\n\t        }\n\t        return message;\n\t    }\n\t\n\t    function _notify(channel, message) {\n\t        var subscriptions = _listeners[channel];\n\t        if (subscriptions && subscriptions.length > 0) {\n\t            for (var i = 0; i < subscriptions.length; ++i) {\n\t                var subscription = subscriptions[i];\n\t                // Subscriptions may come and go, so the array may have 'holes'\n\t                if (subscription) {\n\t                    try {\n\t                        subscription.callback.call(subscription.scope, message);\n\t                    } catch (x) {\n\t                        var handler = _cometd.onListenerException;\n\t                        if (_isFunction(handler)) {\n\t                            _cometd._debug('Invoking listener exception handler', subscription, x);\n\t                            try {\n\t                                handler.call(_cometd, x, subscription, subscription.listener, message);\n\t                            } catch (xx) {\n\t                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n\t                            }\n\t                        } else {\n\t                            _cometd._info('Exception during execution of listener', subscription, message, x);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function _notifyListeners(channel, message) {\n\t        // Notify direct listeners\n\t        _notify(channel, message);\n\t\n\t        // Notify the globbing listeners\n\t        var channelParts = channel.split('/');\n\t        var last = channelParts.length - 1;\n\t        for (var i = last; i > 0; --i) {\n\t            var channelPart = channelParts.slice(0, i).join('/') + '/*';\n\t            // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n\t            // so we stop at the first non recursive globbing\n\t            if (i === last) {\n\t                _notify(channelPart, message);\n\t            }\n\t            // Add the recursive globber and notify\n\t            channelPart += '*';\n\t            _notify(channelPart, message);\n\t        }\n\t    }\n\t\n\t    function _cancelDelayedSend() {\n\t        if (_scheduledSend !== null) {\n\t            Utils.clearTimeout(_scheduledSend);\n\t        }\n\t        _scheduledSend = null;\n\t    }\n\t\n\t    function _delayedSend(operation, delay) {\n\t        _cancelDelayedSend();\n\t        var time = _advice.interval + delay;\n\t        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n\t        _scheduledSend = Utils.setTimeout(_cometd, operation, time);\n\t    }\n\t\n\t    // Needed to break cyclic dependencies between function definitions\n\t    var _handleMessages;\n\t    var _handleFailure;\n\t\n\t    /**\n\t     * Delivers the messages to the CometD server\n\t     * @param sync whether the send is synchronous\n\t     * @param messages the array of messages to send\n\t     * @param metaConnect true if this send is on /meta/connect\n\t     * @param extraPath an extra path to append to the Bayeux server URL\n\t     */\n\t    function _send(sync, messages, metaConnect, extraPath) {\n\t        // We must be sure that the messages have a clientId.\n\t        // This is not guaranteed since the handshake may take time to return\n\t        // (and hence the clientId is not known yet) and the application\n\t        // may create other messages.\n\t        for (var i = 0; i < messages.length; ++i) {\n\t            var message = messages[i];\n\t            var messageId = message.id;\n\t\n\t            if (_clientId) {\n\t                message.clientId = _clientId;\n\t            }\n\t\n\t            message = _applyOutgoingExtensions(message);\n\t            if (message !== undefined && message !== null) {\n\t                // Extensions may have modified the message id, but we need to own it.\n\t                message.id = messageId;\n\t                messages[i] = message;\n\t            } else {\n\t                delete _callbacks[messageId];\n\t                messages.splice(i--, 1);\n\t            }\n\t        }\n\t\n\t        if (messages.length === 0) {\n\t            return;\n\t        }\n\t\n\t        var url = _cometd.getURL();\n\t        if (_config.appendMessageTypeToURL) {\n\t            // If url does not end with '/', then append it\n\t            if (!url.match(/\\/$/)) {\n\t                url = url + '/';\n\t            }\n\t            if (extraPath) {\n\t                url = url + extraPath;\n\t            }\n\t        }\n\t\n\t        var envelope = {\n\t            url: url,\n\t            sync: sync,\n\t            messages: messages,\n\t            onSuccess: function(rcvdMessages) {\n\t                try {\n\t                    _handleMessages.call(_cometd, rcvdMessages);\n\t                } catch (x) {\n\t                    _cometd._info('Exception during handling of messages', x);\n\t                }\n\t            },\n\t            onFailure: function(conduit, messages, failure) {\n\t                try {\n\t                    var transport = _cometd.getTransport();\n\t                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n\t                    _handleFailure.call(_cometd, conduit, messages, failure);\n\t                } catch (x) {\n\t                    _cometd._info('Exception during handling of failure', x);\n\t                }\n\t            }\n\t        };\n\t        _cometd._debug('Send', envelope);\n\t        _transport.send(envelope, metaConnect);\n\t    }\n\t\n\t    function _queueSend(message) {\n\t        if (_batch > 0 || _internalBatch === true) {\n\t            _messageQueue.push(message);\n\t        } else {\n\t            _send(false, [message], false);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Sends a complete bayeux message.\n\t     * This method is exposed as a public so that extensions may use it\n\t     * to send bayeux message directly, for example in case of re-sending\n\t     * messages that have already been sent but that for some reason must\n\t     * be resent.\n\t     */\n\t    this.send = _queueSend;\n\t\n\t    function _resetBackoff() {\n\t        _backoff = 0;\n\t    }\n\t\n\t    function _increaseBackoff() {\n\t        if (_backoff < _config.maxBackoff) {\n\t            _backoff += _config.backoffIncrement;\n\t        }\n\t        return _backoff;\n\t    }\n\t\n\t    /**\n\t     * Starts a the batch of messages to be sent in a single request.\n\t     * @see #_endBatch(sendMessages)\n\t     */\n\t    function _startBatch() {\n\t        ++_batch;\n\t        _cometd._debug('Starting batch, depth', _batch);\n\t    }\n\t\n\t    function _flushBatch() {\n\t        var messages = _messageQueue;\n\t        _messageQueue = [];\n\t        if (messages.length > 0) {\n\t            _send(false, messages, false);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Ends the batch of messages to be sent in a single request,\n\t     * optionally sending messages present in the message queue depending\n\t     * on the given argument.\n\t     * @see #_startBatch()\n\t     */\n\t    function _endBatch() {\n\t        --_batch;\n\t        _cometd._debug('Ending batch, depth', _batch);\n\t        if (_batch < 0) {\n\t            throw 'Calls to startBatch() and endBatch() are not paired';\n\t        }\n\t\n\t        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n\t            _flushBatch();\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Sends the connect message\n\t     */\n\t    function _connect() {\n\t        if (!_isDisconnected()) {\n\t            var bayeuxMessage = {\n\t                id: _nextMessageId(),\n\t                channel: '/meta/connect',\n\t                connectionType: _transport.getType()\n\t            };\n\t\n\t            // In case of reload or temporary loss of connection\n\t            // we want the next successful connect to return immediately\n\t            // instead of being held by the server, so that connect listeners\n\t            // can be notified that the connection has been re-established\n\t            if (!_connected) {\n\t                bayeuxMessage.advice = { timeout: 0 };\n\t            }\n\t\n\t            _setStatus('connecting');\n\t            _cometd._debug('Connect sent', bayeuxMessage);\n\t            _send(false, [bayeuxMessage], true, 'connect');\n\t            _setStatus('connected');\n\t        }\n\t    }\n\t\n\t    function _delayedConnect(delay) {\n\t        _setStatus('connecting');\n\t        _delayedSend(function() {\n\t            _connect();\n\t        }, delay);\n\t    }\n\t\n\t    function _updateAdvice(newAdvice) {\n\t        if (newAdvice) {\n\t            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n\t            _cometd._debug('New advice', _advice);\n\t        }\n\t    }\n\t\n\t    function _disconnect(abort) {\n\t        _cancelDelayedSend();\n\t        if (abort && _transport) {\n\t            _transport.abort();\n\t        }\n\t        _clientId = null;\n\t        _setStatus('disconnected');\n\t        _batch = 0;\n\t        _resetBackoff();\n\t        _transport = null;\n\t\n\t        // Fail any existing queued message\n\t        if (_messageQueue.length > 0) {\n\t            var messages = _messageQueue;\n\t            _messageQueue = [];\n\t            _handleFailure.call(_cometd, undefined, messages, {\n\t                reason: 'Disconnected'\n\t            });\n\t        }\n\t    }\n\t\n\t    function _notifyTransportFailure(oldTransport, newTransport, failure) {\n\t        var handler = _cometd.onTransportException;\n\t        if (_isFunction(handler)) {\n\t            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n\t            try {\n\t                handler.call(_cometd, failure, oldTransport, newTransport);\n\t            } catch (x) {\n\t                _cometd._info('Exception during execution of transport exception handler', x);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Sends the initial handshake message\n\t     */\n\t    function _handshake(handshakeProps, handshakeCallback) {\n\t        if (_isFunction(handshakeProps)) {\n\t            handshakeCallback = handshakeProps;\n\t            handshakeProps = undefined;\n\t        }\n\t\n\t        _clientId = null;\n\t\n\t        _clearSubscriptions();\n\t\n\t        // Reset the transports if we're not retrying the handshake\n\t        if (_isDisconnected()) {\n\t            _transports.reset(true);\n\t            _updateAdvice(_config.advice);\n\t        } else {\n\t            // We are retrying the handshake, either because another handshake failed\n\t            // and we're backing off, or because the server timed us out and asks us to\n\t            // re-handshake: in both cases, make sure that if the handshake succeeds\n\t            // the next action is a connect.\n\t            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n\t        }\n\t\n\t        _batch = 0;\n\t\n\t        // Mark the start of an internal batch.\n\t        // This is needed because handshake and connect are async.\n\t        // It may happen that the application calls init() then subscribe()\n\t        // and the subscribe message is sent before the connect message, if\n\t        // the subscribe message is not held until the connect message is sent.\n\t        // So here we start a batch to hold temporarily any message until\n\t        // the connection is fully established.\n\t        _internalBatch = true;\n\t\n\t        // Save the properties provided by the user, so that\n\t        // we can reuse them during automatic re-handshake\n\t        _handshakeProps = handshakeProps;\n\t        _handshakeCallback = handshakeCallback;\n\t\n\t        var version = '1.0';\n\t\n\t        // Figure out the transports to send to the server\n\t        var url = _cometd.getURL();\n\t        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\t\n\t        var bayeuxMessage = {\n\t            id: _nextMessageId(),\n\t            version: version,\n\t            minimumVersion: version,\n\t            channel: '/meta/handshake',\n\t            supportedConnectionTypes: transportTypes,\n\t            advice: {\n\t                timeout: _advice.timeout,\n\t                interval: _advice.interval\n\t            }\n\t        };\n\t        // Do not allow the user to override important fields.\n\t        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\t\n\t        // Save the callback.\n\t        _cometd._putCallback(message.id, handshakeCallback);\n\t\n\t        // Pick up the first available transport as initial transport\n\t        // since we don't know if the server supports it\n\t        if (!_transport) {\n\t            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n\t            if (!_transport) {\n\t                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n\t                _cometd._warn(failure);\n\t                throw failure;\n\t            }\n\t        }\n\t\n\t        _cometd._debug('Initial transport is', _transport.getType());\n\t\n\t        // We started a batch to hold the application messages,\n\t        // so here we must bypass it and send immediately.\n\t        _setStatus('handshaking');\n\t        _cometd._debug('Handshake sent', message);\n\t        _send(false, [message], false, 'handshake');\n\t    }\n\t\n\t    function _delayedHandshake(delay) {\n\t        _setStatus('handshaking');\n\t\n\t        // We will call _handshake() which will reset _clientId, but we want to avoid\n\t        // that between the end of this method and the call to _handshake() someone may\n\t        // call publish() (or other methods that call _queueSend()).\n\t        _internalBatch = true;\n\t\n\t        _delayedSend(function() {\n\t            _handshake(_handshakeProps, _handshakeCallback);\n\t        }, delay);\n\t    }\n\t\n\t    function _notifyCallback(callback, message) {\n\t        try {\n\t            callback.call(_cometd, message);\n\t        } catch (x) {\n\t            var handler = _cometd.onCallbackException;\n\t            if (_isFunction(handler)) {\n\t                _cometd._debug('Invoking callback exception handler', x);\n\t                try {\n\t                    handler.call(_cometd, x, message);\n\t                } catch (xx) {\n\t                    _cometd._info('Exception during execution of callback exception handler', xx);\n\t                }\n\t            } else {\n\t                _cometd._info('Exception during execution of message callback', x);\n\t            }\n\t        }\n\t    }\n\t\n\t    this._getCallback = function(messageId) {\n\t        return _callbacks[messageId];\n\t    };\n\t\n\t    this._putCallback = function(messageId, callback) {\n\t        var result = this._getCallback(messageId);\n\t        if (_isFunction(callback)) {\n\t            _callbacks[messageId] = callback;\n\t        }\n\t        return result;\n\t    };\n\t\n\t    function _handleCallback(message) {\n\t        var callback = _cometd._getCallback([message.id]);\n\t        if (_isFunction(callback)) {\n\t            delete _callbacks[message.id];\n\t            _notifyCallback(callback, message);\n\t        }\n\t    }\n\t\n\t    function _handleRemoteCall(message) {\n\t        var context = _remoteCalls[message.id];\n\t        delete _remoteCalls[message.id];\n\t        _cometd._debug('Handling remote call response for', message, 'with context', context);\n\t        if (context) {\n\t            // Clear the timeout, if present.\n\t            var timeout = context.timeout;\n\t            if (timeout) {\n\t                Utils.clearTimeout(timeout);\n\t            }\n\t\n\t            var callback = context.callback;\n\t            if (_isFunction(callback)) {\n\t                _notifyCallback(callback, message);\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t\n\t    function _failHandshake(message) {\n\t        _handleCallback(message);\n\t        _notifyListeners('/meta/handshake', message);\n\t        _notifyListeners('/meta/unsuccessful', message);\n\t\n\t        // Only try again if we haven't been disconnected and\n\t        // the advice permits us to retry the handshake\n\t        var retry = !_isDisconnected() && _advice.reconnect !== 'none';\n\t        if (retry) {\n\t            _increaseBackoff();\n\t            _delayedHandshake();\n\t        } else {\n\t            _disconnect(true);\n\t        }\n\t    }\n\t\n\t    function _handshakeResponse(message) {\n\t        if (message.successful) {\n\t            // Save clientId, figure out transport, then follow the advice to connect\n\t            _clientId = message.clientId;\n\t\n\t            var url = _cometd.getURL();\n\t            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);\n\t            if (newTransport === null) {\n\t                var failure = 'Could not negotiate transport with server; client=[' +\n\t                    _transports.findTransportTypes(message.version, _crossDomain, url) +\n\t                    '], server=[' + message.supportedConnectionTypes + ']';\n\t                var oldTransport = _cometd.getTransport();\n\t                _notifyTransportFailure(oldTransport.getType(), null, {\n\t                    reason: failure,\n\t                    connectionType: oldTransport.getType(),\n\t                    transport: oldTransport\n\t                });\n\t                _cometd._warn(failure);\n\t                _disconnect(true);\n\t                return;\n\t            } else if (_transport !== newTransport) {\n\t                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n\t                _transport = newTransport;\n\t            }\n\t\n\t            // End the internal batch and allow held messages from the application\n\t            // to go to the server (see _handshake() where we start the internal batch).\n\t            _internalBatch = false;\n\t            _flushBatch();\n\t\n\t            // Here the new transport is in place, as well as the clientId, so\n\t            // the listeners can perform a publish() if they want.\n\t            // Notify the listeners before the connect below.\n\t            message.reestablish = _reestablish;\n\t            _reestablish = true;\n\t\n\t            _handleCallback(message);\n\t            _notifyListeners('/meta/handshake', message);\n\t\n\t            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n\t            switch (action) {\n\t                case 'retry':\n\t                    _resetBackoff();\n\t                    _delayedConnect();\n\t                    break;\n\t                case 'none':\n\t                    _disconnect(true);\n\t                    break;\n\t                default:\n\t                    throw 'Unrecognized advice action ' + action;\n\t            }\n\t        } else {\n\t            _failHandshake(message);\n\t        }\n\t    }\n\t\n\t    function _handshakeFailure(message) {\n\t        var version = '1.0';\n\t        var url = _cometd.getURL();\n\t        var oldTransport = _cometd.getTransport();\n\t        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\t        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n\t        if (!newTransport) {\n\t            _notifyTransportFailure(oldTransport.getType(), null, message.failure);\n\t            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');\n\t            _disconnect(true);\n\t            _failHandshake(message);\n\t        } else {\n\t            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());\n\t            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);\n\t            _failHandshake(message);\n\t            _transport = newTransport;\n\t        }\n\t    }\n\t\n\t    function _failConnect(message) {\n\t        // Notify the listeners after the status change but before the next action\n\t        _notifyListeners('/meta/connect', message);\n\t        _notifyListeners('/meta/unsuccessful', message);\n\t\n\t        // This may happen when the server crashed, the current clientId\n\t        // will be invalid, and the server will ask to handshake again\n\t        // Listeners can call disconnect(), so check the state after they run\n\t        var action = _isDisconnected() ? 'none' : _advice.reconnect;\n\t        switch (action) {\n\t            case 'retry':\n\t                _delayedConnect();\n\t                _increaseBackoff();\n\t                break;\n\t            case 'handshake':\n\t                // The current transport may be failed (e.g. network disconnection)\n\t                // Reset the transports so the new handshake picks up the right one\n\t                _transports.reset(true);\n\t                _resetBackoff();\n\t                _delayedHandshake();\n\t                break;\n\t            case 'none':\n\t                _disconnect(true);\n\t                break;\n\t            default:\n\t                throw 'Unrecognized advice action' + action;\n\t        }\n\t    }\n\t\n\t    function _connectResponse(message) {\n\t        _connected = message.successful;\n\t\n\t        if (_connected) {\n\t            _notifyListeners('/meta/connect', message);\n\t\n\t            // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n\t            // and the server will hold the request, so when a response returns\n\t            // we immediately call the server again (long polling)\n\t            // Listeners can call disconnect(), so check the state after they run\n\t            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n\t            switch (action) {\n\t                case 'retry':\n\t                    _resetBackoff();\n\t                    _delayedConnect();\n\t                    break;\n\t                case 'none':\n\t                    // Wait for the /meta/disconnect to arrive.\n\t                    _disconnect(false);\n\t                    break;\n\t                default:\n\t                    throw 'Unrecognized advice action ' + action;\n\t            }\n\t        } else {\n\t            _failConnect(message);\n\t        }\n\t    }\n\t\n\t    function _connectFailure(message) {\n\t        _connected = false;\n\t        _failConnect(message);\n\t    }\n\t\n\t    function _failDisconnect(message) {\n\t        _disconnect(true);\n\t        _handleCallback(message);\n\t        _notifyListeners('/meta/disconnect', message);\n\t        _notifyListeners('/meta/unsuccessful', message);\n\t    }\n\t\n\t    function _disconnectResponse(message) {\n\t        if (message.successful) {\n\t            // Wait for the /meta/connect to arrive.\n\t            _disconnect(false);\n\t            _handleCallback(message);\n\t            _notifyListeners('/meta/disconnect', message);\n\t        } else {\n\t            _failDisconnect(message);\n\t        }\n\t    }\n\t\n\t    function _disconnectFailure(message) {\n\t        _failDisconnect(message);\n\t    }\n\t\n\t    function _failSubscribe(message) {\n\t        var subscriptions = _listeners[message.subscription];\n\t        if (subscriptions) {\n\t            for (var i = subscriptions.length - 1; i >= 0; --i) {\n\t                var subscription = subscriptions[i];\n\t                if (subscription && !subscription.listener) {\n\t                    delete subscriptions[i];\n\t                    _cometd._debug('Removed failed subscription', subscription);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        _handleCallback(message);\n\t        _notifyListeners('/meta/subscribe', message);\n\t        _notifyListeners('/meta/unsuccessful', message);\n\t    }\n\t\n\t    function _subscribeResponse(message) {\n\t        if (message.successful) {\n\t            _handleCallback(message);\n\t            _notifyListeners('/meta/subscribe', message);\n\t        } else {\n\t            _failSubscribe(message);\n\t        }\n\t    }\n\t\n\t    function _subscribeFailure(message) {\n\t        _failSubscribe(message);\n\t    }\n\t\n\t    function _failUnsubscribe(message) {\n\t        _handleCallback(message);\n\t        _notifyListeners('/meta/unsubscribe', message);\n\t        _notifyListeners('/meta/unsuccessful', message);\n\t    }\n\t\n\t    function _unsubscribeResponse(message) {\n\t        if (message.successful) {\n\t            _handleCallback(message);\n\t            _notifyListeners('/meta/unsubscribe', message);\n\t        } else {\n\t            _failUnsubscribe(message);\n\t        }\n\t    }\n\t\n\t    function _unsubscribeFailure(message) {\n\t        _failUnsubscribe(message);\n\t    }\n\t\n\t    function _failMessage(message) {\n\t        if (!_handleRemoteCall(message)) {\n\t            _handleCallback(message);\n\t            _notifyListeners('/meta/publish', message);\n\t            _notifyListeners('/meta/unsuccessful', message);\n\t        }\n\t    }\n\t\n\t    function _messageResponse(message) {\n\t        if (message.data !== undefined) {\n\t            if (!_handleRemoteCall(message)) {\n\t                _notifyListeners(message.channel, message);\n\t                if (_handshakeMessages > 0) {\n\t                    --_handshakeMessages;\n\t                    if (_handshakeMessages === 0) {\n\t                        _cometd._debug('Processed last handshake-delivered message');\n\t                        _delayedConnect(0);\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            if (message.successful === undefined) {\n\t                _cometd._warn('Unknown Bayeux Message', message);\n\t            } else {\n\t                if (message.successful) {\n\t                    _handleCallback(message);\n\t                    _notifyListeners('/meta/publish', message);\n\t                } else {\n\t                    _failMessage(message);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function _messageFailure(failure) {\n\t        _failMessage(failure);\n\t    }\n\t\n\t    function _receive(message) {\n\t        _unconnectTime = 0;\n\t\n\t        message = _applyIncomingExtensions(message);\n\t        if (message === undefined || message === null) {\n\t            return;\n\t        }\n\t\n\t        _updateAdvice(message.advice);\n\t\n\t        var channel = message.channel;\n\t        switch (channel) {\n\t            case '/meta/handshake':\n\t                _handshakeResponse(message);\n\t                break;\n\t            case '/meta/connect':\n\t                _connectResponse(message);\n\t                break;\n\t            case '/meta/disconnect':\n\t                _disconnectResponse(message);\n\t                break;\n\t            case '/meta/subscribe':\n\t                _subscribeResponse(message);\n\t                break;\n\t            case '/meta/unsubscribe':\n\t                _unsubscribeResponse(message);\n\t                break;\n\t            default:\n\t                _messageResponse(message);\n\t                break;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Receives a message.\n\t     * This method is exposed as a public so that extensions may inject\n\t     * messages simulating that they had been received.\n\t     */\n\t    this.receive = _receive;\n\t\n\t    _handleMessages = function(rcvdMessages) {\n\t        _cometd._debug('Received', rcvdMessages);\n\t\n\t        for (var i = 0; i < rcvdMessages.length; ++i) {\n\t            var message = rcvdMessages[i];\n\t            _receive(message);\n\t        }\n\t    };\n\t\n\t    _handleFailure = function(conduit, messages, failure) {\n\t        _cometd._debug('handleFailure', conduit, messages, failure);\n\t\n\t        failure.transport = conduit;\n\t        for (var i = 0; i < messages.length; ++i) {\n\t            var message = messages[i];\n\t            var failureMessage = {\n\t                id: message.id,\n\t                successful: false,\n\t                channel: message.channel,\n\t                failure: failure\n\t            };\n\t            failure.message = message;\n\t            switch (message.channel) {\n\t                case '/meta/handshake':\n\t                    _handshakeFailure(failureMessage);\n\t                    break;\n\t                case '/meta/connect':\n\t                    _connectFailure(failureMessage);\n\t                    break;\n\t                case '/meta/disconnect':\n\t                    _disconnectFailure(failureMessage);\n\t                    break;\n\t                case '/meta/subscribe':\n\t                    failureMessage.subscription = message.subscription;\n\t                    _subscribeFailure(failureMessage);\n\t                    break;\n\t                case '/meta/unsubscribe':\n\t                    failureMessage.subscription = message.subscription;\n\t                    _unsubscribeFailure(failureMessage);\n\t                    break;\n\t                default:\n\t                    _messageFailure(failureMessage);\n\t                    break;\n\t            }\n\t        }\n\t    };\n\t\n\t    function _hasSubscriptions(channel) {\n\t        var subscriptions = _listeners[channel];\n\t        if (subscriptions) {\n\t            for (var i = 0; i < subscriptions.length; ++i) {\n\t                if (subscriptions[i]) {\n\t                    return true;\n\t                }\n\t            }\n\t        }\n\t        return false;\n\t    }\n\t\n\t    function _resolveScopedCallback(scope, callback) {\n\t        var delegate = {\n\t            scope: scope,\n\t            method: callback\n\t        };\n\t        if (_isFunction(scope)) {\n\t            delegate.scope = undefined;\n\t            delegate.method = scope;\n\t        } else {\n\t            if (_isString(callback)) {\n\t                if (!scope) {\n\t                    throw 'Invalid scope ' + scope;\n\t                }\n\t                delegate.method = scope[callback];\n\t                if (!_isFunction(delegate.method)) {\n\t                    throw 'Invalid callback ' + callback + ' for scope ' + scope;\n\t                }\n\t            } else if (!_isFunction(callback)) {\n\t                throw 'Invalid callback ' + callback;\n\t            }\n\t        }\n\t        return delegate;\n\t    }\n\t\n\t    function _addListener(channel, scope, callback, isListener) {\n\t        // The data structure is a map<channel, subscription[]>, where each subscription\n\t        // holds the callback to be called and its scope.\n\t\n\t        var delegate = _resolveScopedCallback(scope, callback);\n\t        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\t\n\t        var subscription = {\n\t            channel: channel,\n\t            scope: delegate.scope,\n\t            callback: delegate.method,\n\t            listener: isListener\n\t        };\n\t\n\t        var subscriptions = _listeners[channel];\n\t        if (!subscriptions) {\n\t            subscriptions = [];\n\t            _listeners[channel] = subscriptions;\n\t        }\n\t\n\t        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.\n\t        // Note that if:\n\t        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');\n\t        // then:\n\t        // hc==3, a.join()=='a',,'c', a.length==3\n\t        subscription.id = subscriptions.push(subscription) - 1;\n\t\n\t        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\t\n\t        // For backward compatibility: we used to return [channel, subscription.id]\n\t        subscription[0] = channel;\n\t        subscription[1] = subscription.id;\n\t\n\t        return subscription;\n\t    }\n\t\n\t    //\n\t    // PUBLIC API\n\t    //\n\t\n\t    /**\n\t     * Registers the given transport under the given transport type.\n\t     * The optional index parameter specifies the \"priority\" at which the\n\t     * transport is registered (where 0 is the max priority).\n\t     * If a transport with the same type is already registered, this function\n\t     * does nothing and returns false.\n\t     * @param type the transport type\n\t     * @param transport the transport object\n\t     * @param index the index at which this transport is to be registered\n\t     * @return true if the transport has been registered, false otherwise\n\t     * @see #unregisterTransport(type)\n\t     */\n\t    this.registerTransport = function(type, transport, index) {\n\t        var result = _transports.add(type, transport, index);\n\t        if (result) {\n\t            this._debug('Registered transport', type);\n\t\n\t            if (_isFunction(transport.registered)) {\n\t                transport.registered(type, this);\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Unregisters the transport with the given transport type.\n\t     * @param type the transport type to unregister\n\t     * @return the transport that has been unregistered,\n\t     * or null if no transport was previously registered under the given transport type\n\t     */\n\t    this.unregisterTransport = function(type) {\n\t        var transport = _transports.remove(type);\n\t        if (transport !== null) {\n\t            this._debug('Unregistered transport', type);\n\t\n\t            if (_isFunction(transport.unregistered)) {\n\t                transport.unregistered();\n\t            }\n\t        }\n\t        return transport;\n\t    };\n\t\n\t    this.unregisterTransports = function() {\n\t        _transports.clear();\n\t    };\n\t\n\t    /**\n\t     * @return an array of all registered transport types\n\t     */\n\t    this.getTransportTypes = function() {\n\t        return _transports.getTransportTypes();\n\t    };\n\t\n\t    this.findTransport = function(name) {\n\t        return _transports.find(name);\n\t    };\n\t\n\t    /**\n\t     * @returns the TransportRegistry object\n\t     */\n\t    this.getTransportRegistry = function() {\n\t        return _transports;\n\t    };\n\t\n\t    /**\n\t     * Configures the initial Bayeux communication with the Bayeux server.\n\t     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n\t     * of type string containing the URL of the Bayeux server.\n\t     * @param configuration the configuration object\n\t     */\n\t    this.configure = function(configuration) {\n\t        _configure.call(this, configuration);\n\t    };\n\t\n\t    /**\n\t     * Configures and establishes the Bayeux communication with the Bayeux server\n\t     * via a handshake and a subsequent connect.\n\t     * @param configuration the configuration object\n\t     * @param handshakeProps an object to be merged with the handshake message\n\t     * @see #configure(configuration)\n\t     * @see #handshake(handshakeProps)\n\t     */\n\t    this.init = function(configuration, handshakeProps) {\n\t        this.configure(configuration);\n\t        this.handshake(handshakeProps);\n\t    };\n\t\n\t    /**\n\t     * Establishes the Bayeux communication with the Bayeux server\n\t     * via a handshake and a subsequent connect.\n\t     * @param handshakeProps an object to be merged with the handshake message\n\t     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n\t     */\n\t    this.handshake = function(handshakeProps, handshakeCallback) {\n\t        _setStatus('disconnected');\n\t        _reestablish = false;\n\t        _handshake(handshakeProps, handshakeCallback);\n\t    };\n\t\n\t    /**\n\t     * Disconnects from the Bayeux server.\n\t     * It is possible to suggest to attempt a synchronous disconnect, but this feature\n\t     * may only be available in certain transports (for example, long-polling may support\n\t     * it, callback-polling certainly does not).\n\t     * @param sync whether attempt to perform a synchronous disconnect\n\t     * @param disconnectProps an object to be merged with the disconnect message\n\t     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n\t     */\n\t    this.disconnect = function(sync, disconnectProps, disconnectCallback) {\n\t        if (_isDisconnected()) {\n\t            return;\n\t        }\n\t\n\t        if (typeof sync !== 'boolean') {\n\t            disconnectCallback = disconnectProps;\n\t            disconnectProps = sync;\n\t            sync = false;\n\t        }\n\t        if (_isFunction(disconnectProps)) {\n\t            disconnectCallback = disconnectProps;\n\t            disconnectProps = undefined;\n\t        }\n\t\n\t        var bayeuxMessage = {\n\t            id: _nextMessageId(),\n\t            channel: '/meta/disconnect'\n\t        };\n\t        // Do not allow the user to override important fields.\n\t        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\t\n\t        // Save the callback.\n\t        _cometd._putCallback(message.id, disconnectCallback);\n\t\n\t        _setStatus('disconnecting');\n\t        _send(sync === true, [message], false, 'disconnect');\n\t    };\n\t\n\t    /**\n\t     * Marks the start of a batch of application messages to be sent to the server\n\t     * in a single request, obtaining a single response containing (possibly) many\n\t     * application reply messages.\n\t     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n\t     * If startBatch() is called multiple times, then an equal number of endBatch()\n\t     * calls must be made to close and send the batch of messages.\n\t     * @see #endBatch()\n\t     */\n\t    this.startBatch = function() {\n\t        _startBatch();\n\t    };\n\t\n\t    /**\n\t     * Marks the end of a batch of application messages to be sent to the server\n\t     * in a single request.\n\t     * @see #startBatch()\n\t     */\n\t    this.endBatch = function() {\n\t        _endBatch();\n\t    };\n\t\n\t    /**\n\t     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n\t     * and {@link #endBatch()} calls.\n\t     * @param scope the scope of the callback, may be omitted\n\t     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n\t     */\n\t    this.batch = function(scope, callback) {\n\t        var delegate = _resolveScopedCallback(scope, callback);\n\t        this.startBatch();\n\t        try {\n\t            delegate.method.call(delegate.scope);\n\t            this.endBatch();\n\t        } catch (x) {\n\t            this._info('Exception during execution of batch', x);\n\t            this.endBatch();\n\t            throw x;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Adds a listener for bayeux messages, performing the given callback in the given scope\n\t     * when a message for the given channel arrives.\n\t     * @param channel the channel the listener is interested to\n\t     * @param scope the scope of the callback, may be omitted\n\t     * @param callback the callback to call when a message is sent to the channel\n\t     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n\t     * @see #removeListener(subscription)\n\t     */\n\t    this.addListener = function(channel, scope, callback) {\n\t        if (arguments.length < 2) {\n\t            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n\t        }\n\t        if (!_isString(channel)) {\n\t            throw 'Illegal argument type: channel must be a string';\n\t        }\n\t\n\t        return _addListener(channel, scope, callback, true);\n\t    };\n\t\n\t    /**\n\t     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n\t     * @param subscription the subscription to unsubscribe.\n\t     * @see #addListener(channel, scope, callback)\n\t     */\n\t    this.removeListener = function(subscription) {\n\t        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n\t        if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n\t            throw 'Invalid argument: expected subscription, not ' + subscription;\n\t        }\n\t\n\t        _removeListener(subscription);\n\t    };\n\t\n\t    /**\n\t     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n\t     * {@link #subscribe(channel, scope, callback)}.\n\t     */\n\t    this.clearListeners = function() {\n\t        _listeners = {};\n\t    };\n\t\n\t    /**\n\t     * Subscribes to the given channel, performing the given callback in the given scope\n\t     * when a message for the channel arrives.\n\t     * @param channel the channel to subscribe to\n\t     * @param scope the scope of the callback, may be omitted\n\t     * @param callback the callback to call when a message is sent to the channel\n\t     * @param subscribeProps an object to be merged with the subscribe message\n\t     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n\t     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n\t     */\n\t    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n\t        if (arguments.length < 2) {\n\t            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n\t        }\n\t        if (!_isString(channel)) {\n\t            throw 'Illegal argument type: channel must be a string';\n\t        }\n\t        if (_isDisconnected()) {\n\t            throw 'Illegal state: already disconnected';\n\t        }\n\t\n\t        // Normalize arguments\n\t        if (_isFunction(scope)) {\n\t            subscribeCallback = subscribeProps;\n\t            subscribeProps = callback;\n\t            callback = scope;\n\t            scope = undefined;\n\t        }\n\t        if (_isFunction(subscribeProps)) {\n\t            subscribeCallback = subscribeProps;\n\t            subscribeProps = undefined;\n\t        }\n\t\n\t        // Only send the message to the server if this client has not yet subscribed to the channel\n\t        var send = !_hasSubscriptions(channel);\n\t\n\t        var subscription = _addListener(channel, scope, callback, false);\n\t\n\t        if (send) {\n\t            // Send the subscription message after the subscription registration to avoid\n\t            // races where the server would send a message to the subscribers, but here\n\t            // on the client the subscription has not been added yet to the data structures\n\t            var bayeuxMessage = {\n\t                id: _nextMessageId(),\n\t                channel: '/meta/subscribe',\n\t                subscription: channel\n\t            };\n\t            // Do not allow the user to override important fields.\n\t            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\t\n\t            // Save the callback.\n\t            _cometd._putCallback(message.id, subscribeCallback);\n\t\n\t            _queueSend(message);\n\t        }\n\t\n\t        return subscription;\n\t    };\n\t\n\t    /**\n\t     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n\t     * @param subscription the subscription to unsubscribe.\n\t     * @param unsubscribeProps an object to be merged with the unsubscribe message\n\t     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n\t     */\n\t    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n\t        if (arguments.length < 1) {\n\t            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n\t        }\n\t        if (_isDisconnected()) {\n\t            throw 'Illegal state: already disconnected';\n\t        }\n\t\n\t        if (_isFunction(unsubscribeProps)) {\n\t            unsubscribeCallback = unsubscribeProps;\n\t            unsubscribeProps = undefined;\n\t        }\n\t\n\t        // Remove the local listener before sending the message\n\t        // This ensures that if the server fails, this client does not get notifications\n\t        this.removeListener(subscription);\n\t\n\t        var channel = subscription.channel;\n\t        // Only send the message to the server if this client unsubscribes the last subscription\n\t        if (!_hasSubscriptions(channel)) {\n\t            var bayeuxMessage = {\n\t                id: _nextMessageId(),\n\t                channel: '/meta/unsubscribe',\n\t                subscription: channel\n\t            };\n\t            // Do not allow the user to override important fields.\n\t            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\t\n\t            // Save the callback.\n\t            _cometd._putCallback(message.id, unsubscribeCallback);\n\t\n\t            _queueSend(message);\n\t        }\n\t    };\n\t\n\t    this.resubscribe = function(subscription, subscribeProps) {\n\t        _removeSubscription(subscription);\n\t        if (subscription) {\n\t            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n\t        }\n\t        return undefined;\n\t    };\n\t\n\t    /**\n\t     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n\t     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n\t     */\n\t    this.clearSubscriptions = function() {\n\t        _clearSubscriptions();\n\t    };\n\t\n\t    /**\n\t     * Publishes a message on the given channel, containing the given content.\n\t     * @param channel the channel to publish the message to\n\t     * @param content the content of the message\n\t     * @param publishProps an object to be merged with the publish message\n\t     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n\t     */\n\t    this.publish = function(channel, content, publishProps, publishCallback) {\n\t        if (arguments.length < 1) {\n\t            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n\t        }\n\t        if (!_isString(channel)) {\n\t            throw 'Illegal argument type: channel must be a string';\n\t        }\n\t        if (/^\\/meta\\//.test(channel)) {\n\t            throw 'Illegal argument: cannot publish to meta channels';\n\t        }\n\t        if (_isDisconnected()) {\n\t            throw 'Illegal state: already disconnected';\n\t        }\n\t\n\t        if (_isFunction(content)) {\n\t            publishCallback = content;\n\t            content = publishProps = {};\n\t        } else if (_isFunction(publishProps)) {\n\t            publishCallback = publishProps;\n\t            publishProps = {};\n\t        }\n\t\n\t        var bayeuxMessage = {\n\t            id: _nextMessageId(),\n\t            channel: channel,\n\t            data: content\n\t        };\n\t        // Do not allow the user to override important fields.\n\t        var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\t\n\t        // Save the callback.\n\t        _cometd._putCallback(message.id, publishCallback);\n\t\n\t        _queueSend(message);\n\t    };\n\t\n\t    this.remoteCall = function(target, content, timeout, callback) {\n\t        if (arguments.length < 1) {\n\t            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n\t        }\n\t        if (!_isString(target)) {\n\t            throw 'Illegal argument type: target must be a string';\n\t        }\n\t        if (_isDisconnected()) {\n\t            throw 'Illegal state: already disconnected';\n\t        }\n\t\n\t        if (_isFunction(content)) {\n\t            callback = content;\n\t            content = {};\n\t            timeout = _config.maxNetworkDelay;\n\t        } else if (_isFunction(timeout)) {\n\t            callback = timeout;\n\t            timeout = _config.maxNetworkDelay;\n\t        }\n\t\n\t        if (typeof timeout !== 'number') {\n\t            throw 'Illegal argument type: timeout must be a number';\n\t        }\n\t\n\t        if (!target.match(/^\\//)) {\n\t            target = '/' + target;\n\t        }\n\t        var channel = '/service' + target;\n\t\n\t        var bayeuxMessage = {\n\t            id: _nextMessageId(),\n\t            channel: channel,\n\t            data: content\n\t        };\n\t\n\t        var context = {\n\t            callback: callback\n\t        };\n\t        if (timeout > 0) {\n\t            context.timeout = Utils.setTimeout(_cometd, function() {\n\t                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');\n\t                _failMessage({\n\t                    id: bayeuxMessage.id,\n\t                    error: '406::timeout',\n\t                    successful: false,\n\t                    failure: {\n\t                        message : bayeuxMessage,\n\t                        reason: 'Remote Call Timeout'\n\t                    }\n\t                });\n\t            }, timeout);\n\t            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');\n\t        }\n\t        _remoteCalls[bayeuxMessage.id] = context;\n\t\n\t        _queueSend(bayeuxMessage);\n\t    };\n\t\n\t    /**\n\t     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n\t     */\n\t    this.getStatus = function() {\n\t        return _status;\n\t    };\n\t\n\t    /**\n\t     * Returns whether this instance has been disconnected.\n\t     */\n\t    this.isDisconnected = _isDisconnected;\n\t\n\t    /**\n\t     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n\t     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n\t     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n\t     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n\t     * @param period the backoff period to set\n\t     * @see #getBackoffIncrement()\n\t     */\n\t    this.setBackoffIncrement = function(period) {\n\t        _config.backoffIncrement = period;\n\t    };\n\t\n\t    /**\n\t     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n\t     * @see #setBackoffIncrement(period)\n\t     */\n\t    this.getBackoffIncrement = function() {\n\t        return _config.backoffIncrement;\n\t    };\n\t\n\t    /**\n\t     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n\t     */\n\t    this.getBackoffPeriod = function() {\n\t        return _backoff;\n\t    };\n\t\n\t    /**\n\t     * Increases the backoff period up to the maximum value configured.\n\t     * @returns the backoff period after increment\n\t     * @see getBackoffIncrement\n\t     */\n\t    this.increaseBackoffPeriod = function() {\n\t        return _increaseBackoff();\n\t    };\n\t\n\t    /**\n\t     * Resets the backoff period to zero.\n\t     */\n\t    this.resetBackoffPeriod = function() {\n\t        _resetBackoff();\n\t    };\n\t\n\t    /**\n\t     * Sets the log level for console logging.\n\t     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n\t     * less verbose to more verbose.\n\t     * @param level the log level string\n\t     */\n\t    this.setLogLevel = function(level) {\n\t        _config.logLevel = level;\n\t    };\n\t\n\t    /**\n\t     * Registers an extension whose callbacks are called for every incoming message\n\t     * (that comes from the server to this client implementation) and for every\n\t     * outgoing message (that originates from this client implementation for the\n\t     * server).\n\t     * The format of the extension object is the following:\n\t     * <pre>\n\t     * {\n\t     *     incoming: function(message) { ... },\n\t     *     outgoing: function(message) { ... }\n\t     * }\n\t     * </pre>\n\t     * Both properties are optional, but if they are present they will be called\n\t     * respectively for each incoming message and for each outgoing message.\n\t     * @param name the name of the extension\n\t     * @param extension the extension to register\n\t     * @return true if the extension was registered, false otherwise\n\t     * @see #unregisterExtension(name)\n\t     */\n\t    this.registerExtension = function(name, extension) {\n\t        if (arguments.length < 2) {\n\t            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n\t        }\n\t        if (!_isString(name)) {\n\t            throw 'Illegal argument type: extension name must be a string';\n\t        }\n\t\n\t        var existing = false;\n\t        for (var i = 0; i < _extensions.length; ++i) {\n\t            var existingExtension = _extensions[i];\n\t            if (existingExtension.name === name) {\n\t                existing = true;\n\t                break;\n\t            }\n\t        }\n\t        if (!existing) {\n\t            _extensions.push({\n\t                name: name,\n\t                extension: extension\n\t            });\n\t            this._debug('Registered extension', name);\n\t\n\t            // Callback for extensions\n\t            if (_isFunction(extension.registered)) {\n\t                extension.registered(name, this);\n\t            }\n\t\n\t            return true;\n\t        } else {\n\t            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n\t            return false;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Unregister an extension previously registered with\n\t     * {@link #registerExtension(name, extension)}.\n\t     * @param name the name of the extension to unregister.\n\t     * @return true if the extension was unregistered, false otherwise\n\t     */\n\t    this.unregisterExtension = function(name) {\n\t        if (!_isString(name)) {\n\t            throw 'Illegal argument type: extension name must be a string';\n\t        }\n\t\n\t        var unregistered = false;\n\t        for (var i = 0; i < _extensions.length; ++i) {\n\t            var extension = _extensions[i];\n\t            if (extension.name === name) {\n\t                _extensions.splice(i, 1);\n\t                unregistered = true;\n\t                this._debug('Unregistered extension', name);\n\t\n\t                // Callback for extensions\n\t                var ext = extension.extension;\n\t                if (_isFunction(ext.unregistered)) {\n\t                    ext.unregistered();\n\t                }\n\t\n\t                break;\n\t            }\n\t        }\n\t        return unregistered;\n\t    };\n\t\n\t    /**\n\t     * Find the extension registered with the given name.\n\t     * @param name the name of the extension to find\n\t     * @return the extension found or null if no extension with the given name has been registered\n\t     */\n\t    this.getExtension = function(name) {\n\t        for (var i = 0; i < _extensions.length; ++i) {\n\t            var extension = _extensions[i];\n\t            if (extension.name === name) {\n\t                return extension.extension;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t\n\t    /**\n\t     * Returns the name assigned to this CometD object, or the string 'default'\n\t     * if no name has been explicitly passed as parameter to the constructor.\n\t     */\n\t    this.getName = function() {\n\t        return _name;\n\t    };\n\t\n\t    /**\n\t     * Returns the clientId assigned by the Bayeux server during handshake.\n\t     */\n\t    this.getClientId = function() {\n\t        return _clientId;\n\t    };\n\t\n\t    /**\n\t     * Returns the URL of the Bayeux server.\n\t     */\n\t    this.getURL = function() {\n\t        if (_transport) {\n\t            var url = _transport.getURL();\n\t            if (url) {\n\t                return url;\n\t            }\n\t            url = _config.urls[_transport.getType()];\n\t            if (url) {\n\t                return url;\n\t            }\n\t        }\n\t        return _config.url;\n\t    };\n\t\n\t    this.getTransport = function() {\n\t        return _transport;\n\t    };\n\t\n\t    this.getConfiguration = function() {\n\t        return this._mixin(true, {}, _config);\n\t    };\n\t\n\t    this.getAdvice = function() {\n\t        return this._mixin(true, {}, _advice);\n\t    };\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/**\n\t * A registry for transports used by the CometD object.\n\t */\n\tmodule.exports = function TransportRegistry() {\n\t    var _types = [];\n\t    var _transports = {};\n\t\n\t    this.getTransportTypes = function() {\n\t        return _types.slice(0);\n\t    };\n\t\n\t    this.findTransportTypes = function(version, crossDomain, url) {\n\t        var result = [];\n\t        for (var i = 0; i < _types.length; ++i) {\n\t            var type = _types[i];\n\t            if (_transports[type].accept(version, crossDomain, url) === true) {\n\t                result.push(type);\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t\n\t    this.negotiateTransport = function(types, version, crossDomain, url) {\n\t        for (var i = 0; i < _types.length; ++i) {\n\t            var type = _types[i];\n\t            for (var j = 0; j < types.length; ++j) {\n\t                if (type === types[j]) {\n\t                    var transport = _transports[type];\n\t                    if (transport.accept(version, crossDomain, url) === true) {\n\t                        return transport;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t\n\t    this.add = function(type, transport, index) {\n\t        var existing = false;\n\t        for (var i = 0; i < _types.length; ++i) {\n\t            if (_types[i] === type) {\n\t                existing = true;\n\t                break;\n\t            }\n\t        }\n\t\n\t        if (!existing) {\n\t            if (typeof index !== 'number') {\n\t                _types.push(type);\n\t            } else {\n\t                _types.splice(index, 0, type);\n\t            }\n\t            _transports[type] = transport;\n\t        }\n\t\n\t        return !existing;\n\t    };\n\t\n\t    this.find = function(type) {\n\t        for (var i = 0; i < _types.length; ++i) {\n\t            if (_types[i] === type) {\n\t                return _transports[type];\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t\n\t    this.remove = function(type) {\n\t        for (var i = 0; i < _types.length; ++i) {\n\t            if (_types[i] === type) {\n\t                _types.splice(i, 1);\n\t                var transport = _transports[type];\n\t                delete _transports[type];\n\t                return transport;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t\n\t    this.clear = function() {\n\t        _types = [];\n\t        _transports = {};\n\t    };\n\t\n\t    this.reset = function(init) {\n\t        for (var i = 0; i < _types.length; ++i) {\n\t            _transports[_types[i]].reset(init);\n\t        }\n\t    };\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Transport = __webpack_require__(9);\n\tvar RequestTransport = __webpack_require__(11);\n\t\n\tmodule.exports = function LongPollingTransport() {\n\t    var _super = new RequestTransport();\n\t    var _self = Transport.derive(_super);\n\t    // By default, support cross domain\n\t    var _supportsCrossDomain = true;\n\t\n\t    _self.accept = function(version, crossDomain, url) {\n\t        return _supportsCrossDomain || !crossDomain;\n\t    };\n\t\n\t    _self.xhrSend = function(packet) {\n\t        throw 'Abstract';\n\t    };\n\t\n\t    _self.transportSend = function(envelope, request) {\n\t        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\t\n\t        var self = this;\n\t        try {\n\t            var sameStack = true;\n\t            request.xhr = this.xhrSend({\n\t                transport: this,\n\t                url: envelope.url,\n\t                sync: envelope.sync,\n\t                headers: this.getConfiguration().requestHeaders,\n\t                body: JSON.stringify(envelope.messages),\n\t                onSuccess: function(response) {\n\t                    self._debug('Transport', self.getType(), 'received response', response);\n\t                    var success = false;\n\t                    try {\n\t                        var received = self.convertToMessages(response);\n\t                        if (received.length === 0) {\n\t                            _supportsCrossDomain = false;\n\t                            self.transportFailure(envelope, request, {\n\t                                httpCode: 204\n\t                            });\n\t                        } else {\n\t                            success = true;\n\t                            self.transportSuccess(envelope, request, received);\n\t                        }\n\t                    } catch (x) {\n\t                        self._debug(x);\n\t                        if (!success) {\n\t                            _supportsCrossDomain = false;\n\t                            var failure = {\n\t                                exception: x\n\t                            };\n\t                            failure.httpCode = self.xhrStatus(request.xhr);\n\t                            self.transportFailure(envelope, request, failure);\n\t                        }\n\t                    }\n\t                },\n\t                onError: function(reason, exception) {\n\t                    self._debug('Transport', self.getType(), 'received error', reason, exception);\n\t                    _supportsCrossDomain = false;\n\t                    var failure = {\n\t                        reason: reason,\n\t                        exception: exception\n\t                    };\n\t                    failure.httpCode = self.xhrStatus(request.xhr);\n\t                    if (sameStack) {\n\t                        // Keep the semantic of calling response callbacks asynchronously after the request\n\t                        self.setTimeout(function() {\n\t                            self.transportFailure(envelope, request, failure);\n\t                        }, 0);\n\t                    } else {\n\t                        self.transportFailure(envelope, request, failure);\n\t                    }\n\t                }\n\t            });\n\t            sameStack = false;\n\t        } catch (x) {\n\t            _supportsCrossDomain = false;\n\t            // Keep the semantic of calling response callbacks asynchronously after the request\n\t            self.setTimeout(function() {\n\t                self.transportFailure(envelope, request, {\n\t                    exception: x\n\t                });\n\t            }, 0);\n\t        }\n\t    };\n\t\n\t    _self.reset = function(init) {\n\t        _super.reset(init);\n\t        _supportsCrossDomain = true;\n\t    };\n\t\n\t    return _self;\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Transport = __webpack_require__(9)\n\tvar Utils = __webpack_require__(10)\n\t\n\tmodule.exports = function WebSocketTransport() {\n\t    var _super = new Transport();\n\t    var _self = Transport.derive(_super);\n\t    var _cometd;\n\t    // By default WebSocket is supported\n\t    var _webSocketSupported = true;\n\t    // Whether we were able to establish a WebSocket connection\n\t    var _webSocketConnected = false;\n\t    var _stickyReconnect = true;\n\t    // The context contains the envelopes that have been sent\n\t    // and the timeouts for the messages that have been sent.\n\t    var _context = null;\n\t    var _connecting = null;\n\t    var _connected = false;\n\t    var _successCallback = null;\n\t\n\t    _self.reset = function(init) {\n\t        _super.reset(init);\n\t        _webSocketSupported = true;\n\t        if (init) {\n\t            _webSocketConnected = false;\n\t        }\n\t        _stickyReconnect = true;\n\t        _context = null;\n\t        _connecting = null;\n\t        _connected = false;\n\t    };\n\t\n\t    function _forceClose(context, event) {\n\t        if (context) {\n\t            this.webSocketClose(context, event.code, event.reason);\n\t            // Force immediate failure of pending messages to trigger reconnect.\n\t            // This is needed because the server may not reply to our close()\n\t            // and therefore the onclose function is never called.\n\t            this.onClose(context, event);\n\t        }\n\t    }\n\t\n\t    function _sameContext(context) {\n\t        return context === _connecting || context === _context;\n\t    }\n\t\n\t    function _storeEnvelope(context, envelope, metaConnect) {\n\t        var messageIds = [];\n\t        for (var i = 0; i < envelope.messages.length; ++i) {\n\t            var message = envelope.messages[i];\n\t            if (message.id) {\n\t                messageIds.push(message.id);\n\t            }\n\t        }\n\t        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n\t        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n\t    }\n\t\n\t    function _websocketConnect(context) {\n\t        // We may have multiple attempts to open a WebSocket\n\t        // connection, for example a /meta/connect request that\n\t        // may take time, along with a user-triggered publish.\n\t        // Early return if we are already connecting.\n\t        if (_connecting) {\n\t            return;\n\t        }\n\t\n\t        // Mangle the URL, changing the scheme from 'http' to 'ws'.\n\t        var url = _cometd.getURL().replace(/^http/, 'ws');\n\t        this._debug('Transport', this.getType(), 'connecting to URL', url);\n\t\n\t        try {\n\t            var protocol = _cometd.getConfiguration().protocol;\n\t            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n\t            _connecting = context;\n\t        } catch (x) {\n\t            _webSocketSupported = false;\n\t            this._debug('Exception while creating WebSocket object', x);\n\t            throw x;\n\t        }\n\t\n\t        // By default use sticky reconnects.\n\t        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\t\n\t        var self = this;\n\t        var connectTimeout = _cometd.getConfiguration().connectTimeout;\n\t        if (connectTimeout > 0) {\n\t            context.connectTimer = self.setTimeout(function() {\n\t                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n\t                // The connection was not opened, close anyway.\n\t                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n\t            }, connectTimeout);\n\t        }\n\t\n\t        var onopen = function() {\n\t            _cometd._debug('WebSocket onopen', context);\n\t            if (context.connectTimer) {\n\t                self.clearTimeout(context.connectTimer);\n\t            }\n\t\n\t            if (_sameContext(context)) {\n\t                _connecting = null;\n\t                _context = context;\n\t                _webSocketConnected = true;\n\t                self.onOpen(context);\n\t            } else {\n\t                // We have a valid connection already, close this one.\n\t                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n\t                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n\t            }\n\t        };\n\t\n\t        // This callback is invoked when the server sends the close frame.\n\t        // The close frame for a connection may arrive *after* another\n\t        // connection has been opened, so we must make sure that actions\n\t        // are performed only if it's the same connection.\n\t        var onclose = function(event) {\n\t            event = event || {code: 1000};\n\t            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\t\n\t            if (context.connectTimer) {\n\t                self.clearTimeout(context.connectTimer);\n\t            }\n\t\n\t            self.onClose(context, event);\n\t        };\n\t\n\t        var onmessage = function(wsMessage) {\n\t            _cometd._debug('WebSocket onmessage', wsMessage, context);\n\t            self.onMessage(context, wsMessage);\n\t        };\n\t\n\t        context.webSocket.onopen = onopen;\n\t        context.webSocket.onclose = onclose;\n\t        context.webSocket.onerror = function() {\n\t            // Clients should call onclose(), but if they do not we do it here for safety.\n\t            onclose({code: 1000, reason: 'Error'});\n\t        };\n\t        context.webSocket.onmessage = onmessage;\n\t\n\t        this._debug('Transport', this.getType(), 'configured callbacks on', context);\n\t    }\n\t\n\t    function _webSocketSend(context, envelope, metaConnect) {\n\t        var json = JSON.stringify(envelope.messages);\n\t        context.webSocket.send(json);\n\t        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);\n\t\n\t        // Manage the timeout waiting for the response.\n\t        var maxDelay = this.getConfiguration().maxNetworkDelay;\n\t        var delay = maxDelay;\n\t        if (metaConnect) {\n\t            delay += this.getAdvice().timeout;\n\t            _connected = true;\n\t        }\n\t\n\t        var self = this;\n\t        var messageIds = [];\n\t        for (var i = 0; i < envelope.messages.length; ++i) {\n\t            (function() {\n\t                var message = envelope.messages[i];\n\t                if (message.id) {\n\t                    messageIds.push(message.id);\n\t                    context.timeouts[message.id] = self.setTimeout(function() {\n\t                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n\t                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n\t                    }, delay);\n\t                }\n\t            })();\n\t        }\n\t\n\t        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n\t    }\n\t\n\t    _self._notifySuccess = function(fn, messages) {\n\t        fn.call(this, messages);\n\t    };\n\t\n\t    _self._notifyFailure = function(fn, context, messages, failure) {\n\t        fn.call(this, context, messages, failure);\n\t    };\n\t\n\t    function _send(context, envelope, metaConnect) {\n\t        try {\n\t            if (context === null) {\n\t                context = _connecting || {\n\t                        envelopes: {},\n\t                        timeouts: {}\n\t                    };\n\t                _storeEnvelope.call(this, context, envelope, metaConnect);\n\t                _websocketConnect.call(this, context);\n\t            } else {\n\t                _storeEnvelope.call(this, context, envelope, metaConnect);\n\t                _webSocketSend.call(this, context, envelope, metaConnect);\n\t            }\n\t        } catch (x) {\n\t            // Keep the semantic of calling response callbacks asynchronously after the request.\n\t            var self = this;\n\t            self.setTimeout(function() {\n\t                _forceClose.call(self, context, {\n\t                    code: 1000,\n\t                    reason: 'Exception',\n\t                    exception: x\n\t                });\n\t            }, 0);\n\t        }\n\t    }\n\t\n\t    _self.onOpen = function(context) {\n\t        var envelopes = context.envelopes;\n\t        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n\t        for (var key in envelopes) {\n\t            if (envelopes.hasOwnProperty(key)) {\n\t                var element = envelopes[key];\n\t                var envelope = element[0];\n\t                var metaConnect = element[1];\n\t                // Store the success callback, which is independent from the envelope,\n\t                // so that it can be used to notify arrival of messages.\n\t                _successCallback = envelope.onSuccess;\n\t                _webSocketSend.call(this, context, envelope, metaConnect);\n\t            }\n\t        }\n\t    };\n\t\n\t    _self.onMessage = function(context, wsMessage) {\n\t        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\t\n\t        var close = false;\n\t        var messages = this.convertToMessages(wsMessage.data);\n\t        var messageIds = [];\n\t        for (var i = 0; i < messages.length; ++i) {\n\t            var message = messages[i];\n\t\n\t            // Detect if the message is a response to a request we made.\n\t            // If it's a meta message, for sure it's a response; otherwise it's\n\t            // a publish message and publish responses don't have the data field.\n\t            if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n\t                if (message.id) {\n\t                    messageIds.push(message.id);\n\t\n\t                    var timeout = context.timeouts[message.id];\n\t                    if (timeout) {\n\t                        this.clearTimeout(timeout);\n\t                        delete context.timeouts[message.id];\n\t                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if ('/meta/connect' === message.channel) {\n\t                _connected = false;\n\t            }\n\t            if ('/meta/disconnect' === message.channel && !_connected) {\n\t                close = true;\n\t            }\n\t        }\n\t\n\t        // Remove the envelope corresponding to the messages.\n\t        var removed = false;\n\t        var envelopes = context.envelopes;\n\t        for (var j = 0; j < messageIds.length; ++j) {\n\t            var id = messageIds[j];\n\t            for (var key in envelopes) {\n\t                if (envelopes.hasOwnProperty(key)) {\n\t                    var ids = key.split(',');\n\t                    var index = Utils.inArray(id, ids);\n\t                    if (index >= 0) {\n\t                        removed = true;\n\t                        ids.splice(index, 1);\n\t                        var envelope = envelopes[key][0];\n\t                        var metaConnect = envelopes[key][1];\n\t                        delete envelopes[key];\n\t                        if (ids.length > 0) {\n\t                            envelopes[ids.join(',')] = [envelope, metaConnect];\n\t                        }\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (removed) {\n\t            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n\t        }\n\t\n\t        this._notifySuccess(_successCallback, messages);\n\t\n\t        if (close) {\n\t            this.webSocketClose(context, 1000, 'Disconnect');\n\t        }\n\t    };\n\t\n\t    _self.onClose = function(context, event) {\n\t        this._debug('Transport', this.getType(), 'closed', context, event);\n\t\n\t        if (_sameContext(context)) {\n\t            // Remember if we were able to connect.\n\t            // This close event could be due to server shutdown,\n\t            // and if it restarts we want to try websocket again.\n\t            _webSocketSupported = _stickyReconnect && _webSocketConnected;\n\t            _connecting = null;\n\t            _context = null;\n\t        }\n\t\n\t        var timeouts = context.timeouts;\n\t        context.timeouts = {};\n\t        for (var id in timeouts) {\n\t            if (timeouts.hasOwnProperty(id)) {\n\t                this.clearTimeout(timeouts[id]);\n\t            }\n\t        }\n\t\n\t        var envelopes = context.envelopes;\n\t        context.envelopes = {};\n\t        for (var key in envelopes) {\n\t            if (envelopes.hasOwnProperty(key)) {\n\t                var envelope = envelopes[key][0];\n\t                var metaConnect = envelopes[key][1];\n\t                if (metaConnect) {\n\t                    _connected = false;\n\t                }\n\t                var failure = {\n\t                    websocketCode: event.code,\n\t                    reason: event.reason\n\t                };\n\t                if (event.exception) {\n\t                    failure.exception = event.exception;\n\t                }\n\t                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n\t            }\n\t        }\n\t    };\n\t\n\t    _self.registered = function(type, cometd) {\n\t        _super.registered(type, cometd);\n\t        _cometd = cometd;\n\t    };\n\t\n\t    _self.accept = function(version, crossDomain, url) {\n\t        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n\t        // Using !! to return a boolean (and not the WebSocket object).\n\t        return _webSocketSupported && !('undefined' === typeof WebSocket) && _cometd.websocketEnabled !== false;\n\t    };\n\t\n\t    _self.send = function(envelope, metaConnect) {\n\t        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);\n\t        _send.call(this, _context, envelope, metaConnect);\n\t    };\n\t\n\t    _self.webSocketClose = function(context, code, reason) {\n\t        try {\n\t            if (context.webSocket) {\n\t                context.webSocket.close(code, reason);\n\t            }\n\t        } catch (x) {\n\t            this._debug(x);\n\t        }\n\t    };\n\t\n\t    _self.abort = function() {\n\t        _super.abort();\n\t        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n\t        this.reset(true);\n\t    };\n\t\n\t    return _self;\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Client = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _index = __webpack_require__(17);\n\t\n\tvar _clientHelper = __webpack_require__(18);\n\t\n\tvar _connectionStatus = __webpack_require__(5);\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Client config object.\n\t * @typedef {Object} ClientConfig\n\t * @property {string} apiUrl - Api Url\n\t * @property {string} sandboxId - Sandbox id\n\t * @property {boolean} forceHttps - Force end to end HTTPS connection\n\t * @property {function():AbstractHandshake} credentials - Return credentials properties\n\t * @property {string} resource - Client resource id\n\t * @property {Array} transports - Client transports list\n\t */\n\t\n\t/**\n\t * ZetaPush Client to connect\n\t * @access public\n\t * @example\n\t * // Securized client with token based connection\n\t * const client = new ZetaPush.Client({\n\t *   sandboxId: '<YOUR-SANDBOX-ID>',\n\t *   credentials() {\n\t *     return ZetaPush.Authentication.weak({\n\t *       token: null\n\t  *    })\n\t *   }\n\t * })\n\t * @example\n\t * // Client with credentials based connection\n\t * const client = new ZetaPush.Client({\n\t *   sandboxId: '<YOUR-SANDBOX-ID>',\n\t *   credentials() {\n\t *     return ZetaPush.Authentication.simple({\n\t *       login: '<USER-LOGIN>',\n\t *       password: '<USER-PASSWORD>'\n\t  *    })\n\t *   }\n\t * })\n\t */\n\t\n\tvar Client = exports.Client = function () {\n\t  /**\n\t   * @param {ClientConfig} config\n\t   * Create a new ZetaPush client\n\t   */\n\t\n\t  function Client(_ref) {\n\t    var _ref$apiUrl = _ref.apiUrl;\n\t    var apiUrl = _ref$apiUrl === undefined ? _index.API_URL : _ref$apiUrl;\n\t    var sandboxId = _ref.sandboxId;\n\t    var _ref$forceHttps = _ref.forceHttps;\n\t    var forceHttps = _ref$forceHttps === undefined ? (0, _index.isHttpsProtocol)() : _ref$forceHttps;\n\t    var credentials = _ref.credentials;\n\t    var resource = _ref.resource;\n\t    var transports = _ref.transports;\n\t\n\t    _classCallCheck(this, Client);\n\t\n\t    /**\n\t     * @access private\n\t     * @type {ClientHelper}\n\t     */\n\t    this.helper = new _clientHelper.ClientHelper({\n\t      apiUrl: apiUrl,\n\t      sandboxId: sandboxId,\n\t      forceHttps: forceHttps,\n\t      credentials: credentials,\n\t      resource: resource,\n\t      transports: transports\n\t    });\n\t  }\n\t  /**\n\t   * Is client connected to ZetaPush\n\t   * @return {boolean}\n\t   */\n\t\n\t\n\t  _createClass(Client, [{\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return this.helper.isConnected();\n\t    }\n\t    /**\n\t     * Connect client to ZetaPush\n\t     */\n\t\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      this.helper.connect();\n\t    }\n\t    /**\n\t     * Disonnect client from ZetaPush\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.helper.disconnect();\n\t    }\n\t    /**\n\t     * Get the client sandbox id\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'getSandboxId',\n\t    value: function getSandboxId() {\n\t      return this.helper.getSandboxId();\n\t    }\n\t    /**\n\t     * Get the client resource\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'getResource',\n\t    value: function getResource() {\n\t      return this.helper.getResource();\n\t    }\n\t    /**\n\t     * Get the client user id\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'getUserId',\n\t    value: function getUserId() {\n\t      return this.helper.getUserId();\n\t    }\n\t    /**\n\t     * Remove all subscriptions\n\t     * @param {Object} service\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(service) {\n\t      if (!service.$subscriptions) {\n\t        throw new TypeError('Missing $subscriptions property in service');\n\t      }\n\t      return this.helper.unsubscribe(service.$subscriptions);\n\t    }\n\t    /**\n\t     * Create a publish/subscribe for a service type\n\t     * @param {{type: class, deploymentId: string, listener: Object}} parameters\n\t     * @return {Object} service\n\t     */\n\t\n\t  }, {\n\t    key: 'createService',\n\t    value: function createService(_ref2) {\n\t      var type = _ref2.type;\n\t      var listener = _ref2.listener;\n\t      var _ref2$deploymentId = _ref2.deploymentId;\n\t      var deploymentId = _ref2$deploymentId === undefined ? type.DEFAULT_DEPLOYMENT_ID : _ref2$deploymentId;\n\t\n\t      return this.helper.createService({ deploymentId: deploymentId, listener: listener, type: type });\n\t    }\n\t    /**\n\t     * Set new client resource value\n\t     * @param {string} resource\n\t     */\n\t\n\t  }, {\n\t    key: 'setResource',\n\t    value: function setResource(resource) {\n\t      this.helper.setResource(resource);\n\t    }\n\t    /**\n\t     * Add a connection listener to handle life cycle connection events\n\t     * @param {ConnectionStatusListener} listener\n\t     * @return {number} handler\n\t     */\n\t\n\t  }, {\n\t    key: 'addConnectionStatusListener',\n\t    value: function addConnectionStatusListener(listener) {\n\t      return this.helper.addConnectionStatusListener(listener);\n\t    }\n\t    /**\n\t     * Remove a connection status listener\n\t     * @param {number} handler\n\t     */\n\t\n\t  }, {\n\t    key: 'removeConnectionStatusListener',\n\t    value: function removeConnectionStatusListener(handler) {\n\t      return this.helper.removeConnectionStatusListener(handler);\n\t    }\n\t    /**\n\t     * Set logging level\n\t     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n\t     * less verbose to more verbose.\n\t     * @param {string} level\n\t     */\n\t\n\t  }, {\n\t    key: 'setLogLevel',\n\t    value: function setLogLevel(level) {\n\t      this.helper.setLogLevel(level);\n\t    }\n\t  }]);\n\t\n\t  return Client;\n\t}();\n\t\n\t/**\n\t * Add shorthand connection status method\n\t */\n\t\n\t\n\tObject.getOwnPropertyNames(_connectionStatus.ConnectionStatusListener.prototype).forEach(function (method) {\n\t  // Only implements unsupported methods\n\t  if (!Client.prototype.hasOwnProperty(method)) {\n\t    Client.prototype[method] = function addListener(listener) {\n\t      return this.addConnectionStatusListener(_defineProperty({}, method, listener));\n\t    };\n\t  }\n\t});\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Match unsecure pattern web\n\t * @type {RegExp}\n\t */\n\tvar UNSECURE_PATTERN = /^http:\\/\\/|^\\/\\//;\n\t\n\t/**\n\t* Default ZetaPush API URL\n\t* @access private\n\t*/\n\tvar API_URL = exports.API_URL = 'https://api.zpush.io/';\n\t\n\t/**\n\t * @access private\n\t * @param {Array<Object>} list\n\t * @return {Object}\n\t */\n\tvar shuffle = exports.shuffle = function shuffle(list) {\n\t  var index = Math.floor(Math.random() * list.length);\n\t  return list[index];\n\t};\n\t\n\t/**\n\t * @access private\n\t * @param {string} url\n\t * @param {boolean} forceHttps\n\t * @return {string}\n\t */\n\tvar getSecureUrl = exports.getSecureUrl = function getSecureUrl(url, forceHttps) {\n\t  return forceHttps ? url.replace(UNSECURE_PATTERN, 'https://') : url;\n\t};\n\t\n\t/**\n\t * @access private\n\t * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean}} parameters\n\t * @return {Promise}\n\t */\n\tvar getServers = exports.getServers = function getServers(_ref) {\n\t  var apiUrl = _ref.apiUrl;\n\t  var sandboxId = _ref.sandboxId;\n\t  var forceHttps = _ref.forceHttps;\n\t\n\t  var secureApiUrl = getSecureUrl(apiUrl, forceHttps);\n\t  var url = '' + secureApiUrl + sandboxId;\n\t  return fetch(url).then(function (response) {\n\t    return response.json();\n\t  }).then(function (_ref2) {\n\t    var servers = _ref2.servers;\n\t\n\t    // TODO: Replace by a server side implementation when available\n\t    return servers.map(function (server) {\n\t      return getSecureUrl(server, forceHttps);\n\t    });\n\t  });\n\t};\n\t\n\t/**\n\t * @access private\n\t * @return {boolean}\n\t */\n\tvar isHttpsProtocol = exports.isHttpsProtocol = function isHttpsProtocol() {\n\t  return 'https:' === location.protocol;\n\t};\n\t\n\t/**\n\t * @access  private\n\t * @return {boolean}\n\t */\n\tvar isPrototypeOf = exports.isPrototypeOf = function isPrototypeOf(derived, parent) {\n\t  var prototype = Object.getPrototypeOf(derived);\n\t  var is = false;\n\t  while (!(is || prototype === null)) {\n\t    is = prototype === parent;\n\t    prototype = Object.getPrototypeOf(prototype);\n\t  }\n\t  return is;\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ClientHelper = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _zetapushCometd = __webpack_require__(7);\n\t\n\tvar _cometd = __webpack_require__(6);\n\t\n\tvar _connectionStatus = __webpack_require__(5);\n\t\n\tvar _services = __webpack_require__(4);\n\t\n\tvar _index = __webpack_require__(17);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * CometD Messages enumeration\n\t */\n\tvar Message = {\n\t  RECONNECT_HANDSHAKE_VALUE: 'handshake',\n\t  RECONNECT_NONE_VALUE: 'none',\n\t  RECONNECT_RETRY_VALUE: 'retry'\n\t};\n\t\n\t/**\n\t * Get all transport types\n\t */\n\tvar AllTransports = Object.values(_cometd.TransportTypes);\n\t\n\t/**\n\t * Provide utilities and abstraction on CometD Transport layer\n\t * @access private\n\t */\n\t\n\tvar ClientHelper = exports.ClientHelper = function () {\n\t  /**\n\t   * Create a new ZetaPush client helper\n\t   */\n\t\n\t  function ClientHelper(_ref) {\n\t    var _this = this;\n\t\n\t    var apiUrl = _ref.apiUrl;\n\t    var sandboxId = _ref.sandboxId;\n\t    var _ref$forceHttps = _ref.forceHttps;\n\t    var forceHttps = _ref$forceHttps === undefined ? false : _ref$forceHttps;\n\t    var credentials = _ref.credentials;\n\t    var _ref$resource = _ref.resource;\n\t    var resource = _ref$resource === undefined ? null : _ref$resource;\n\t    var _ref$transports = _ref.transports;\n\t    var transports = _ref$transports === undefined ? AllTransports : _ref$transports;\n\t\n\t    _classCallCheck(this, ClientHelper);\n\t\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t    this.sandboxId = sandboxId;\n\t    /**\n\t     * @access private\n\t     * @type {function():AbstractHandshake}\n\t     */\n\t    this.credentials = credentials;\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t    this.resource = resource;\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t    this.userId = null;\n\t    /**\n\t     * @access private\n\t     * @type {Promise}\n\t     */\n\t    this.servers = (0, _index.getServers)({ apiUrl: apiUrl, sandboxId: sandboxId, forceHttps: forceHttps });\n\t    /**\n\t     * @access private\n\t     * @type {Array<Object>}\n\t     */\n\t    this.connectionListeners = [];\n\t    /**\n\t     * @access private\n\t     * @type {boolean}\n\t     */\n\t    this.connected = false;\n\t    /**\n\t     * @access private\n\t     * @type {boolean}\n\t     */\n\t    this.wasConnected = false;\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t    this.serverUrl = null;\n\t    /**\n\t     * @access private\n\t     * @type {Array<Object>}\n\t     */\n\t    this.subscribeQueue = [];\n\t    /**\n\t     * @access private\n\t     * @type {CometD}\n\t     */\n\t    this.cometd = new _zetapushCometd.CometD();\n\t\n\t    // Filter transports layers\n\t    _cometd.TransportLayers.filter(function (_ref2) {\n\t      var type = _ref2.type;\n\t\n\t      return transports.includes(type);\n\t    }).forEach(function (_ref3) {\n\t      var type = _ref3.type;\n\t      var Transport = _ref3.Transport;\n\t\n\t      _this.cometd.registerTransport(type, new Transport());\n\t    });\n\t\n\t    // Handle transport exception\n\t    this.cometd.onTransportException = function (cometd, transport) {\n\t      if (_cometd.TransportTypes.LONG_POLLING === transport) {\n\t        // Try to find an other available server\n\t        // Remove the current one from the _serverList array\n\t        _this.updateServerUrl();\n\t      }\n\t    };\n\t\n\t    this.cometd.addListener('/meta/handshake', function (_ref4) {\n\t      var ext = _ref4.ext;\n\t      var successful = _ref4.successful;\n\t      var advice = _ref4.advice;\n\t      var error = _ref4.error;\n\t\n\t      _this.cometd._debug('ClientHelper::/meta/handshake', { ext: ext, successful: successful, advice: advice, error: error });\n\t      if (successful) {\n\t        var _ext$authentication = ext.authentication;\n\t        var authentication = _ext$authentication === undefined ? null : _ext$authentication;\n\t\n\t        _this.initialized(authentication);\n\t      } else {\n\t        _this.handshakeFailure(error);\n\t      }\n\t    });\n\t\n\t    this.cometd.addListener('/meta/handshake', function (_ref5) {\n\t      var advice = _ref5.advice;\n\t      var error = _ref5.error;\n\t      var ext = _ref5.ext;\n\t      var successful = _ref5.successful;\n\t\n\t      _this.cometd._debug('ClientHelper::/meta/handshake', { ext: ext, successful: successful, advice: advice, error: error });\n\t      // AuthNegotiation\n\t      if (!successful) {\n\t        if ('undefined' === typeof advice) {\n\t          return;\n\t        }\n\t        if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {\n\t          _this.authenticationFailed(error);\n\t        } else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {\n\t          _this.negotiate(ext);\n\t        }\n\t      }\n\t    });\n\t\n\t    this.cometd.addListener('/meta/connect', function (_ref6) {\n\t      var advice = _ref6.advice;\n\t      var channel = _ref6.channel;\n\t      var successful = _ref6.successful;\n\t\n\t      _this.cometd._debug('ClientHelper::/meta/connect', { advice: advice, channel: channel, successful: successful });\n\t      // ConnectionListener\n\t      if (_this.cometd.isDisconnected()) {\n\t        _this.connected = false;\n\t        // Notify connection will close\n\t        _this.connectionWillClose();\n\t      } else {\n\t        _this.wasConnected = _this.connected;\n\t        _this.connected = successful;\n\t        if (!_this.wasConnected && _this.connected) {\n\t          _this.cometd.batch(_this, function () {\n\t            // Unqueue subscriptions\n\t            _this.subscribeQueue.forEach(function (_ref7) {\n\t              var prefix = _ref7.prefix;\n\t              var listener = _ref7.listener;\n\t              var subscriptions = _ref7.subscriptions;\n\t\n\t              _this.subscribe(prefix, listener, subscriptions);\n\t            });\n\t          });\n\t          // Notify connection is established\n\t          _this.connectionEstablished();\n\t        } else if (_this.wasConnected && !_this.connected) {\n\t          // Notify connection is broken\n\t          _this.connectionBroken();\n\t        }\n\t      }\n\t    });\n\t\n\t    this.cometd.addListener('/meta/disconnect', function (_ref8) {\n\t      var channel = _ref8.channel;\n\t      var successful = _ref8.successful;\n\t\n\t      _this.cometd._debug('ClientHelper::/meta/disconnect', { channel: channel, successful: successful });\n\t      if (_this.cometd.isDisconnected()) {\n\t        _this.connected = false;\n\t        // Notify connection is closed\n\t        _this.connectionClosed();\n\t      }\n\t    });\n\t  }\n\t  /**\n\t   * Is client connected to ZetaPush\n\t   * @return boolean\n\t   */\n\t\n\t\n\t  _createClass(ClientHelper, [{\n\t    key: 'isConnected',\n\t    value: function isConnected() {\n\t      return !this.cometd.isDisconnected();\n\t    }\n\t    /**\n\t     * Connect client using CometD Transport\n\t     */\n\t\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      this.servers.then(function (servers) {\n\t        _this2.serverUrl = (0, _index.shuffle)(servers);\n\t\n\t        _this2.cometd.configure({\n\t          url: _this2.serverUrl + '/strd',\n\t          backoffIncrement: 1000,\n\t          maxBackoff: 60000,\n\t          appendMessageTypeToURL: false\n\t        });\n\t\n\t        _this2.cometd.handshake(_this2.getHandshakeFields());\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when connection is established\n\t     */\n\t\n\t  }, {\n\t    key: 'connectionEstablished',\n\t    value: function connectionEstablished() {\n\t      this.connectionListeners.filter(function (_ref9) {\n\t        var enabled = _ref9.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref10) {\n\t        var listener = _ref10.listener;\n\t\n\t        listener.onConnectionEstablished();\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when connection is broken\n\t     */\n\t\n\t  }, {\n\t    key: 'connectionBroken',\n\t    value: function connectionBroken() {\n\t      this.connectionListeners.filter(function (_ref11) {\n\t        var enabled = _ref11.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref12) {\n\t        var listener = _ref12.listener;\n\t\n\t        listener.onConnectionBroken();\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when a message is lost\n\t     */\n\t\n\t  }, {\n\t    key: 'messageLost',\n\t    value: function messageLost(channel, data) {\n\t      this.connectionListeners.filter(function (_ref13) {\n\t        var enabled = _ref13.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref14) {\n\t        var listener = _ref14.listener;\n\t\n\t        listener.onMessageLost(channel, data);\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when connection will close\n\t     */\n\t\n\t  }, {\n\t    key: 'connectionWillClose',\n\t    value: function connectionWillClose() {\n\t      this.connectionListeners.filter(function (_ref15) {\n\t        var enabled = _ref15.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref16) {\n\t        var listener = _ref16.listener;\n\t\n\t        listener.onConnectionWillClose();\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when connection is closed\n\t     */\n\t\n\t  }, {\n\t    key: 'connectionClosed',\n\t    value: function connectionClosed() {\n\t      this.userId = null;\n\t      this.connectionListeners.filter(function (_ref17) {\n\t        var enabled = _ref17.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref18) {\n\t        var listener = _ref18.listener;\n\t\n\t        listener.onConnectionClosed();\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when connection is established\n\t     */\n\t\n\t  }, {\n\t    key: 'initialized',\n\t    value: function initialized(authentication) {\n\t      if (authentication) {\n\t        this.userId = authentication.userId;\n\t      }\n\t      this.connectionListeners.filter(function (_ref19) {\n\t        var enabled = _ref19.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref20) {\n\t        var listener = _ref20.listener;\n\t\n\t        listener.onSuccessfulHandshake(authentication);\n\t      });\n\t    }\n\t    /**\n\t     * Notify listeners when handshake step succeed\n\t     */\n\t\n\t  }, {\n\t    key: 'authenticationFailed',\n\t    value: function authenticationFailed(error) {\n\t      this.userId = null;\n\t      this.connectionListeners.filter(function (_ref21) {\n\t        var enabled = _ref21.enabled;\n\t        return enabled;\n\t      }).forEach(function (_ref22) {\n\t        var listener = _ref22.listener;\n\t\n\t        listener.onFailedHandshake(error);\n\t      });\n\t    }\n\t    /**\n\t     * Manage handshake failure case\n\t     */\n\t\n\t  }, {\n\t    key: 'handshakeFailure',\n\t    value: function handshakeFailure() {\n\t      this.userId = null;\n\t    }\n\t    /**\n\t    * Remove current server url from the server list and shuffle for another one\n\t    */\n\t\n\t  }, {\n\t    key: 'updateServerUrl',\n\t    value: function updateServerUrl() {\n\t      var _this3 = this;\n\t\n\t      this.servers.then(function (servers) {\n\t        var index = servers.indexOf(_this3.serverUrl);\n\t        if (index > -1) {\n\t          servers.splice(index, 1);\n\t        }\n\t        if (servers.length === 0) {\n\t          // No more server available\n\t        } else {\n\t          _this3.serverUrl = (0, _index.shuffle)(servers);\n\t          _this3.cometd.configure({\n\t            url: _this3.serverUrl + '/strd'\n\t          });\n\t          setTimeout(function () {\n\t            _this3.cometd.handshake(_this3.getHandshakeFields());\n\t          }, 250);\n\t        }\n\t      });\n\t    }\n\t    /**\n\t     * Negociate authentication\n\t     */\n\t\n\t  }, {\n\t    key: 'negotiate',\n\t    value: function negotiate(ext) {\n\t      this.cometd._debug('ClientHelper::negotiate', ext);\n\t    }\n\t    /**\n\t     * Disconnect CometD client\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.cometd.disconnect(true);\n\t    }\n\t    /**\n\t     * Get CometD handshake parameters\n\t     * @return {Object}\n\t     */\n\t\n\t  }, {\n\t    key: 'getHandshakeFields',\n\t    value: function getHandshakeFields() {\n\t      var handshake = this.credentials();\n\t      return handshake.getHandshakeFields(this);\n\t    }\n\t    /**\n\t     * Set a new handshake factory methods\n\t     * @param {function():AbstractHandshake} credentials\n\t     */\n\t\n\t  }, {\n\t    key: 'setCredentials',\n\t    value: function setCredentials(credentials) {\n\t      this.credentials = credentials;\n\t    }\n\t    /**\n\t     * Get sandbox id\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'getSandboxId',\n\t    value: function getSandboxId() {\n\t      return this.sandboxId;\n\t    }\n\t    /**\n\t     * Get resource\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'getResource',\n\t    value: function getResource() {\n\t      return this.resource;\n\t    }\n\t    /**\n\t     * Get user id\n\t     * @return {string}\n\t     */\n\t\n\t  }, {\n\t    key: 'getUserId',\n\t    value: function getUserId() {\n\t      return this.userId;\n\t    }\n\t    /**\n\t     * Subsribe all methods defined in the listener for the given prefixed channel\n\t     * @param {string} prefix - Channel prefix\n\t     * @param {Object} listener\n\t     * @param {Object} subscriptions\n\t     * @return {Object} subscriptions\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(prefix, listener) {\n\t      var subscriptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t      var _getQueuedSubscriptio = this.getQueuedSubscription(subscriptions);\n\t\n\t      var queued = _getQueuedSubscriptio.queued;\n\t\n\t      if (!queued) {\n\t        // Store arguments to renew subscriptions on connection\n\t        this.subscribeQueue.push({ prefix: prefix, listener: listener, subscriptions: subscriptions });\n\t      }\n\t      // Subscribe if user is connected\n\t      if (!this.cometd.isDisconnected()) {\n\t        for (var method in listener) {\n\t          if (listener.hasOwnProperty(method)) {\n\t            var channel = prefix + '/' + method;\n\t            subscriptions[method] = this.cometd.subscribe(channel, listener[method]);\n\t          }\n\t        }\n\t      }\n\t      return subscriptions;\n\t    }\n\t    /**\n\t     * Remove all subscriptions\n\t     * @param {Object} subscriptions\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {\n\t      var subscriptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      // Unsubscribe\n\t      for (var method in subscriptions) {\n\t        if (subscriptions.hasOwnProperty(method)) {\n\t          var subscription = subscriptions[method];\n\t          this.cometd.unsubscribe(subscription);\n\t        }\n\t      }\n\t      // Remove subscription from queue\n\t\n\t      var _getQueuedSubscriptio2 = this.getQueuedSubscription(subscriptions);\n\t\n\t      var index = _getQueuedSubscriptio2.index;\n\t      var queued = _getQueuedSubscriptio2.queued;\n\t\n\t      if (queued) {\n\t        this.subscribeQueue.splice(index, 1);\n\t      }\n\t    }\n\t    /**\n\t     * Get queued subscription index\n\t     * @return {Object} index\n\t     */\n\t\n\t  }, {\n\t    key: 'getQueuedSubscription',\n\t    value: function getQueuedSubscription() {\n\t      var subscriptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var index = this.subscribeQueue.findIndex(function (element) {\n\t        return subscriptions === element.subscriptions;\n\t      });\n\t      return {\n\t        index: index,\n\t        queued: -1 < index\n\t      };\n\t    }\n\t    /**\n\t     * Get a publisher for a macro service\n\t     * @param {string} prefix - Channel prefix\n\t     * @return {Function} publisher\n\t     */\n\t\n\t  }, {\n\t    key: 'getMacroPublisher',\n\t    value: function getMacroPublisher(prefix) {\n\t      var _this4 = this;\n\t\n\t      return function (name, parameters) {\n\t        var hardFail = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\t        var debug = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];\n\t\n\t        var channel = prefix + '/call';\n\t        _this4.publish(channel, {\n\t          name: name,\n\t          parameters: parameters,\n\t          hardFail: hardFail,\n\t          debug: debug\n\t        });\n\t      };\n\t    }\n\t    /**\n\t     * Get a publisher for a service\n\t     * @param {string} prefix - Channel prefix\n\t     * @return {Function} publisher\n\t     */\n\t\n\t  }, {\n\t    key: 'getServicePublisher',\n\t    value: function getServicePublisher(prefix) {\n\t      var _this5 = this;\n\t\n\t      return function (method, parameters) {\n\t        var channel = prefix + '/' + method;\n\t        _this5.publish(channel, parameters);\n\t      };\n\t    }\n\t    /**\n\t     * @param {{deploymentId: string, listener: Object, type: class}} parameters\n\t     * @return {Object} service\n\t     */\n\t\n\t  }, {\n\t    key: 'createService',\n\t    value: function createService(_ref23) {\n\t      var deploymentId = _ref23.deploymentId;\n\t      var listener = _ref23.listener;\n\t      var type = _ref23.type;\n\t\n\t      var isMacroType = (0, _index.isPrototypeOf)(type, _services.Macro);\n\t      var prefix = '/service/' + this.getSandboxId() + '/' + deploymentId;\n\t      var $publish = isMacroType ? this.getMacroPublisher(prefix) : this.getServicePublisher(prefix);\n\t      var service = new type({ $publish: $publish });\n\t      // Store subscription in service instance\n\t      service.$subscriptions = this.subscribe(prefix, listener);\n\t      return service;\n\t    }\n\t    /**\n\t     * Unsubcribe all subscriptions defined in given subscriptions object\n\t     * @param {Object} subscriptions\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(subscriptions) {\n\t      for (var method in subscriptions) {\n\t        if (subscriptions.hasOwnProperty(method)) {\n\t          this.cometd.unsubscribe(subscriptions[method]);\n\t        }\n\t      }\n\t    }\n\t    /**\n\t     * Add a connection listener to handle life cycle connection events\n\t     * @param {ConnectionStatusListener} listener\n\t     * @return {number} handler\n\t     */\n\t\n\t  }, {\n\t    key: 'addConnectionStatusListener',\n\t    value: function addConnectionStatusListener(listener) {\n\t      this.connectionListeners.push({\n\t        enabled: true,\n\t        listener: Object.assign(new _connectionStatus.ConnectionStatusListener(), listener)\n\t      });\n\t      return this.connectionListeners.length - 1;\n\t    }\n\t    /**\n\t     * Remove a connection status listener\n\t     */\n\t\n\t  }, {\n\t    key: 'removeConnectionStatusListener',\n\t    value: function removeConnectionStatusListener(handler) {\n\t      var listener = this.connectionListeners[handler];\n\t      if (listener) {\n\t        listener.enabled = false;\n\t      }\n\t    }\n\t    /**\n\t     * Wrap CometdD publish method\n\t     * @param {String} channel\n\t     * @param {Object} parameters\n\t     */\n\t\n\t  }, {\n\t    key: 'publish',\n\t    value: function publish(channel) {\n\t      var parameters = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      this.cometd.publish(channel, parameters);\n\t    }\n\t    /**\n\t     * Set logging level for CometD client\n\t     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n\t     * less verbose to more verbose.\n\t     * @param {string} level\n\t     */\n\t\n\t  }, {\n\t    key: 'setLogLevel',\n\t    value: function setLogLevel(level) {\n\t      this.cometd.setLogLevel(level);\n\t    }\n\t  }]);\n\n\t  return ClientHelper;\n\t}();\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.WeakClient = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _client = __webpack_require__(16);\n\t\n\tvar _handshake = __webpack_require__(3);\n\t\n\tvar _tokenPersistence = __webpack_require__(20);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t * WeakClient config object.\n\t * @typedef {Object} WeakClientConfig\n\t * @property {string} apiUrl - Api Url\n\t * @property {string} deploymentId - Authentication deployment id\n\t * @property {string} sandboxId - Sandbox id\n\t * @property {boolean} forceHttps - Force end to end HTTPS connection\n\t * @property {string} resource - Client resource id\n\t * @property {Array} transports - Client transports list\n\t */\n\t\n\t/**\n\t * @access public\n\t * @extends {Client}\n\t * @example\n\t * // Create a new WeakClient\n\t * const client = new ZetaPush.WeakClient({\n\t *   sandboxId: '<YOUR-SANDBOX-ID>'\n\t * })\n\t */\n\t\n\tvar WeakClient = exports.WeakClient = function (_Client) {\n\t  _inherits(WeakClient, _Client);\n\t\n\t  /**\n\t   * Create a new ZetaPush smart client\n\t   * @param {WeakClientConfig} config\n\t   */\n\t\n\t  function WeakClient(_ref) {\n\t    var apiUrl = _ref.apiUrl;\n\t    var sandboxId = _ref.sandboxId;\n\t    var deploymentId = _ref.deploymentId;\n\t    var forceHttps = _ref.forceHttps;\n\t    var resource = _ref.resource;\n\t    var transports = _ref.transports;\n\t\n\t    _classCallCheck(this, WeakClient);\n\t\n\t    var credentials = function credentials() {\n\t      var token = _this.getToken();\n\t      var handshake = _handshake.Authentication.weak({\n\t        deploymentId: deploymentId,\n\t        token: token\n\t      });\n\t      return handshake;\n\t    };\n\t    /**\n\t     * Call Client constructor with specific parameters\n\t     */\n\t\n\t    // Handle successful handshake\n\t\n\t    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(WeakClient).call(this, { apiUrl: apiUrl, sandboxId: sandboxId, forceHttps: forceHttps, credentials: credentials, resource: resource, transports: transports }));\n\t\n\t    var onSuccessfulHandshake = function onSuccessfulHandshake(_ref2) {\n\t      var publicToken = _ref2.publicToken;\n\t      var userId = _ref2.userId;\n\t      var token = _ref2.token;\n\t\n\t      if (token) {\n\t        _this.strategy.set({ token: token });\n\t      }\n\t    };\n\t    _this.addConnectionStatusListener({ onSuccessfulHandshake: onSuccessfulHandshake });\n\t    /**\n\t     * @access private\n\t     * @type {TokenPersistenceStrategy}\n\t     */\n\t    _this.strategy = new _tokenPersistence.LocalStorageTokenPersistenceStrategy();\n\t    return _this;\n\t  }\n\t  /**\n\t   * @return {string} The stored token\n\t   */\n\t\n\t\n\t  _createClass(WeakClient, [{\n\t    key: 'getToken',\n\t    value: function getToken() {\n\t      return this.strategy.get();\n\t    }\n\t  }]);\n\n\t  return WeakClient;\n\t}(_client.Client);\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @type {string}\n\t */\n\tvar ZETAPUSH_TOKEN_KEY = 'zetapush.token';\n\t\n\t/**\n\t * Provide abstraction for token persistence\n\t * @access protected\n\t */\n\t\n\tvar AbstractTokenPersistenceStrategy = exports.AbstractTokenPersistenceStrategy = function () {\n\t  /**\n\t   * @param {{key: string}} parameters\n\t   */\n\t\n\t  function AbstractTokenPersistenceStrategy() {\n\t    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    var _ref$key = _ref.key;\n\t    var key = _ref$key === undefined ? ZETAPUSH_TOKEN_KEY : _ref$key;\n\t\n\t    _classCallCheck(this, AbstractTokenPersistenceStrategy);\n\t\n\t    /**\n\t     * @access private\n\t     * @type {string}\n\t     */\n\t    this.key = key;\n\t  }\n\t  /**\n\t   * @abstract\n\t   * @return {string} The stored token\n\t   */\n\t\n\t\n\t  _createClass(AbstractTokenPersistenceStrategy, [{\n\t    key: 'get',\n\t    value: function get() {}\n\t    /**\n\t     * @abstract\n\t     * @param {{token: string}} parameters\n\t     */\n\t\n\t  }, {\n\t    key: 'set',\n\t    value: function set(_ref2) {\n\t      var token = _ref2.token;\n\t    }\n\t  }]);\n\t\n\t  return AbstractTokenPersistenceStrategy;\n\t}();\n\t\n\t/**\n\t * @access protected\n\t * @extends {AbstractTokenPersistenceStrategy}\n\t */\n\t\n\t\n\tvar LocalStorageTokenPersistenceStrategy = exports.LocalStorageTokenPersistenceStrategy = function (_AbstractTokenPersist) {\n\t  _inherits(LocalStorageTokenPersistenceStrategy, _AbstractTokenPersist);\n\t\n\t  function LocalStorageTokenPersistenceStrategy() {\n\t    _classCallCheck(this, LocalStorageTokenPersistenceStrategy);\n\t\n\t    return _possibleConstructorReturn(this, Object.getPrototypeOf(LocalStorageTokenPersistenceStrategy).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(LocalStorageTokenPersistenceStrategy, [{\n\t    key: 'get',\n\t\n\t    /**\n\t     * @override\n\t     * @return {string} The stored token\n\t     */\n\t    value: function get() {\n\t      return localStorage.getItem(this.key);\n\t    }\n\t    /**\n\t     * @override\n\t     * @param {{token: string}} parameters\n\t     */\n\t\n\t  }, {\n\t    key: 'set',\n\t    value: function set(_ref3) {\n\t      var token = _ref3.token;\n\t\n\t      localStorage.setItem(this.key, token);\n\t    }\n\t  }]);\n\t\n\t  return LocalStorageTokenPersistenceStrategy;\n\t}(AbstractTokenPersistenceStrategy);\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** zetapush.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ece421f4a66eb3981f62\n **/","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/whatwg-fetch/fetch.js\n ** module id = 1\n ** module chunks = 0\n **/","import * as services from './services/index'\n\nexport { Authentication } from './authentication/handshake'\nexport { ConnectionStatusListener } from './connection/connection-status'\nexport { TransportTypes } from './connection/cometd'\nexport { Client } from './client'\nexport { WeakClient } from './weak-client'\nexport { services }\n\n/**\n * SDK Version\n * @type {string}\n */\nexport const VERSION = '2.0.0-rc.2'\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/index.js\n **/","import { Delegating, Simple, Weak } from '../services'\n\n/**\n * ZetaPush deployables names\n */\nconst DeployableNames = {\n  AUTH_SIMPLE: 'simple',\n  AUTH_WEAK: 'weak',\n  AUTH_DELEGATING: 'delegating'\n}\n\n/**\n * Provide abstraction over CometD handshake data structure\n * @access public\n */\nexport class AbstractHandshake {\n  /**\n   * Create a new handshake manager\n   * @param {{authType: string, sandboxId: string, deploymentId: string}} parameters\n   */\n  constructor({ authType, sandboxId, deploymentId }) {\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.authType = authType\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access protected\n     * @type {string}\n     */\n    this.deploymentId = deploymentId\n  }\n  /**\n   * @param {ClientHelper} client\n   * @return {Object}\n   */\n  getHandshakeFields(client) {\n    const authentication = {\n      data: this.authData,\n      type: `${client.getSandboxId()}.${this.deploymentId}.${this.authType}`,\n      version: this.authVersion\n    }\n    if (client.getResource()) {\n      authentication.resource = client.getResource()\n    }\n    return {\n      ext: {\n        authentication\n      }\n    }\n  }\n  /**\n   * Get auth version\n   * @return {string}\n   */\n  get authVersion() {\n    return 'none'\n  }\n\n}\n\n/**\n * Provide abstraction over CometD token base handshake data structure\n * @access public\n * @extends {AbstractHandshake}\n */\nexport class TokenHandshake extends AbstractHandshake {\n  /**\n   * @param {{authType: string, deploymentId: string, token: string}} parameters\n   */\n  constructor({ authType, deploymentId, token }) {\n    super({ deploymentId, authType })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.token = token\n  }\n  /**\n   * @return {token: string}\n   */\n  get authData() {\n    const { token } = this\n    return {\n      token\n    }\n  }\n\n}\n\n/**\n * Provide abstraction over CometD credentials based handshake data structure\n * @access public\n * @extends {AbstractHandshake}\n */\nexport class CredentialsHandshake extends AbstractHandshake {\n\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   */\n  constructor({ authType, deploymentId, login, password }) {\n    super({ authType, deploymentId })\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.login = login\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.password = password\n  }\n  /**\n   * Get auth data\n   * @return {login: string, password: string}\n   */\n  get authData() {\n    const { login, password } = this\n    return {\n      login, password\n    }\n  }\n\n}\n\n/**\n * Factory to create handshake\n * @access public\n */\nexport class Authentication {\n  /**\n   * @param {{deploymentId: string, login: string, password: string}} parameters\n   * @return {CredentialsHandshake}\n   */\n  static simple({ deploymentId = Simple.DEFAULT_DEPLOYMENT_ID, login, password }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_SIMPLE,\n      deploymentId,\n      login,\n      password\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   */\n  static weak({ deploymentId = Weak.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_WEAK,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{deploymentId: string, token: string}} parameters\n   * @return {TokenHandshake}\n   */\n  static delegating({ deploymentId = Delegating.DEFAULT_DEPLOYMENT_ID, token }) {\n    return Authentication.create({\n      authType: DeployableNames.AUTH_DELEGATING,\n      deploymentId,\n      login: token,\n      password: null\n    })\n  }\n  /**\n   * @param {{authType: string, deploymentId: string, login: string, password: string}} parameters\n   * @return {TokenHandshake|CredentialsHandshake}\n   */\n  static create({ authType, deploymentId, login, password }) {\n    if (null === password) {\n      return new TokenHandshake({ authType, deploymentId, token: login })\n    }\n    return new CredentialsHandshake({ authType, deploymentId, login, password  })\n  }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/authentication/handshake.js\n **/","/**\n * @access protected\n */\nexport class Service {\n\tconstructor({ $publish }) {\n\t\tthis.$publish = $publish\n\t}\n}\n/**\n * Data aggregation\n *\n * Provides data aggregation over time and across different items\n *  User devices push items data on developer-defined categories\n *  This service automatically aggregates the data\n * Raw data is not available for reading, only the generated aggregation result\n *\n * */\n/**\n * User API for item aggregation\n *\n * Users can push data and be notified of aggregated data.\n * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.\n * @access public\n * */\nexport class Aggreg extends Service {\n\t/**\n\t * Get default deployment id associated to AggregService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'aggreg_0'\n\t}\n\t/**\n\t * Pushes some data\n\t *\n\t * Pushes the given data.\n\t * All the items are processed according to the defined rules.\n\t * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.\n\t * */\n\tpush({items,owner}) { this.$publish('push', {items,owner})}\n}\n/**\n * Data stacks\n *\n * Stacks are a per-user named persistent queue of data\n *  An administrator creates a stack service\n *  End-users can push data on an arbitrary number of their own arbitrary named stacks\n * */\n/**\n * Data stack user API\n *\n * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.\n * Stack names are arbitrary and do not need to be explicitly initialized.\n * @access public\n * */\nexport class Stack extends Service {\n\t/**\n\t * Get default deployment id associated to StackService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'stack_0'\n\t}\n\t/**\n\t * Lists the listeners\n\t *\n\t * Returns the whole list of listeners for the given stack.\n\t * */\n\tgetListeners({owner,stack}) { this.$publish('getListeners', {owner,stack})}\n\t/**\n\t * Lists content\n\t *\n\t * Returns a paginated list of contents for the given stack.\n\t * Content is sorted according to the statically configured order.\n\t * */\n\tlist({owner,page,stack}) { this.$publish('list', {owner,page,stack})}\n\t/**\n\t * Empties a stack\n\t *\n\t * Removes all items from the given stack.\n\t * */\n\tpurge({owner,stack}) { this.$publish('purge', {owner,stack})}\n\t/**\n\t * Pushes an item\n\t *\n\t * Pushes an item onto the given stack.\n\t * The stack does not need to be created.\n\t * */\n\tpush({stack,data,owner}) { this.$publish('push', {stack,data,owner})}\n\t/**\n\t * Removes items\n\t *\n\t * Removes the item with the given guid from the given stack.\n\t * */\n\tremove({guids,owner,stack}) { this.$publish('remove', {guids,owner,stack})}\n\t/**\n\t * Sets the listeners\n\t *\n\t * Sets the listeners for the given stack.\n\t * */\n\tsetListeners({listeners,owner,stack}) { this.$publish('setListeners', {listeners,owner,stack})}\n\t/**\n\t * Updates an item\n\t *\n\t * Updates an existing item of the given stack.\n\t * The item MUST exist prior to the call.\n\t * */\n\tupdate({guid,stack,data,owner}) { this.$publish('update', {guid,stack,data,owner})}\n}\n/**\n * Echo\n *\n * Echo\n * */\n/**\n * Echo service\n *\n * Simple echo service, for development purposes.\n * @access public\n * */\nexport class Echo extends Service {\n\t/**\n\t * Get default deployment id associated to EchoService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'echo_0'\n\t}\n\t/**\n\t * Echoes an object\n\t *\n\t * Echoes an object: the server will echo that object on channel 'echo' for the current user.\n\t * */\n\techo({}) { this.$publish('echo', {})}\n}\n/**\n * Game engine\n *\n * Abstract Game Engine\n *  Concrete game engines are remote cometd clients or internal macros\n * */\n/**\n * Game Engine API\n *\n * The Game Engine API is for game engine clients, not end-users.\n * @access public\n * */\nexport class GameEngine extends Service {\n\t/**\n\t * Get default deployment id associated to GameEngineService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Notify the result for a join request\n\t *\n\t * A Game Engine notifies the STR of the result of a join request that it received on join_callback\n\t * */\n\tjoin_result({callerId,error,msgId,payload}) { this.$publish('join_result', {callerId,error,msgId,payload})}\n\t/**\n\t * Notify the result for an organization request\n\t *\n\t * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback\n\t * */\n\torganize_result({callerId,error,msgId,payload}) { this.$publish('organize_result', {callerId,error,msgId,payload})}\n\t/**\n\t * Registers a game engine\n\t *\n\t * A client registers itself to the STR as a Game Engine.\n\t * The STR may, from now on, dispatch game of the given game type to said client.\n\t * Unregistration is done automatically on logoff.\n\t * */\n\tregister({gameInfo,location,maxGames}) { this.$publish('register', {gameInfo,location,maxGames})}\n\t/**\n\t * Notify the result for a start request\n\t *\n\t * A Game Engine notifies the STR of the result of a start request that it received on start_callback\n\t * */\n\tstart_result({gameId}) { this.$publish('start_result', {gameId})}\n\t/**\n\t * Notify a game event\n\t *\n\t * A Game Engine notifies the STR of some arbitrary game event.\n\t * */\n\tstate({data,gameId,status}) { this.$publish('state', {data,gameId,status})}\n\t/**\n\t * Notify the result for an unjoin request\n\t *\n\t * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback\n\t * */\n\tunjoin_result({callerId,error,msgId,payload}) { this.$publish('unjoin_result', {callerId,error,msgId,payload})}\n}\n/**\n * User API for games\n *\n * Users can list, start, join games, and play.\n * @access public\n * */\nexport class Game extends Service {\n\t/**\n\t * Get default deployment id associated to GameService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'game_0'\n\t}\n\t/**\n\t * Lists game types\n\t *\n\t * Returns the list of game types supported by the server and the currently registered game engines.\n\t * */\n\tavailable({}) { this.$publish('available', {})}\n\t/**A user joins a game*/\n\tjoin({gameId,role,userId,userName}) { this.$publish('join', {gameId,role,userId,userName})}\n\t/**Organizes a game*/\n\torganize({type,owner,options}) { this.$publish('organize', {type,owner,options})}\n\t/**Gives some command to the game engine*/\n\tplay({data,gameId,userId}) { this.$publish('play', {data,gameId,userId})}\n\t/**Starts a game*/\n\tstart({gameId}) { this.$publish('start', {gameId})}\n\t/**A user cancels joining a game*/\n\tunjoin({gameId,role,userId,userName}) { this.$publish('unjoin', {gameId,role,userId,userName})}\n}\n/**\n * Generic Data Access\n *\n * Generic Data Access Service : NoSQL storage\n * */\n/**\n * GDA User API\n *\n * User API for Generic Data Access.\n * Data is stored on a per-user basis.\n * Users can put, get, list their data.\n * @access public\n * */\nexport class Gda extends Service {\n\t/**\n\t * Get default deployment id associated to GdaService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'gda_0'\n\t}\n\t/**\n\t * Asks for a data row\n\t *\n\t * Returns a full data row.\n\t * */\n\tget({key,owner,table}) { this.$publish('get', {key,owner,table})}\n\t/**\n\t * Asks for a data cell\n\t *\n\t * Returns a precise list of cells from a column in a data row.\n\t * */\n\tgetCells({column,key,key2,owner,table}) { this.$publish('getCells', {column,key,key2,owner,table})}\n\t/**\n\t * Increments an integer value\n\t *\n\t * Increments a cell 64-bit signed integer value and returns the result in the data field.\n\t * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.\n\t * */\n\tinc({table,data,key,key2,owner,column}) { this.$publish('inc', {table,data,key,key2,owner,column})}\n\t/**\n\t * Asks for a list of rows\n\t *\n\t * Returns a paginated list of rows from the given table.\n\t * */\n\tlist({columns,owner,page,table}) { this.$publish('list', {columns,owner,page,table})}\n\t/**\n\t * Puts some data into a cell\n\t *\n\t * Creates or replaces the contents of a particular cell.\n\t * */\n\tput({column,data,key,key2,owner,table}) { this.$publish('put', {column,data,key,key2,owner,table})}\n\t/**\n\t * Puts several rows\n\t *\n\t * Creates or replaces the (maybe partial) contents of a collection of rows.\n\t * This method only creates or replaces cells for non-null input values.\n\t * */\n\tputs({owner,rows,table}) { this.$publish('puts', {owner,rows,table})}\n\t/**\n\t * Asks for a range of rows\n\t *\n\t * Returns a paginated range of rows from the given table.\n\t * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t * You can specify partial keys for the start and stop fields.\n\t * */\n\trange({columns,owner,page,start,stop,table}) { this.$publish('range', {columns,owner,page,start,stop,table})}\n\t/**\n\t * Reduces a range of rows\n\t *\n\t * Returns a computed single reduced result from a range of rows from the given table.\n\t * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).\n\t * You can specify partial keys for the start and stop fields.\n\t * */\n\treduce({}) { this.$publish('reduce', {})}\n\t/**\n\t * Removes one cell inside a column of a row\n\t *\n\t * Removes only one cell of the given column of the given row from the given table.\n\t * */\n\tremoveCell({column,key,key2,owner,table}) { this.$publish('removeCell', {column,key,key2,owner,table})}\n\t/**\n\t * Removes one full column of a row\n\t *\n\t * Removes all cells of the given column of the given row from the given table.\n\t * */\n\tremoveColumn({column,key,owner,table}) { this.$publish('removeColumn', {column,key,owner,table})}\n\t/**\n\t * Removes a range of rows\n\t *\n\t * Removes the specified columns of the given range of rows from the given table.\n\t * */\n\tremoveRange({columns,owner,start,stop,table}) { this.$publish('removeRange', {columns,owner,start,stop,table})}\n\t/**\n\t * Removes one full row\n\t *\n\t * Removes all columns of the given row from the given table.\n\t * */\n\tremoveRow({key,owner,table}) { this.$publish('removeRow', {key,owner,table})}\n}\n/**\n * Groups Management\n *\n * Groups management for users, grants on resources, remote commands on devices\n *  This is where you can configure rights for any resource\n *\n * */\n/**\n * User API for remote control\n *\n * @access public\n * */\nexport class Remoting extends Service {\n\t/**\n\t * Get default deployment id associated to RemotingService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds a listener\n\t *\n\t * A user requests notifications from a device owned by anyone who granted him the right authorizations.\n\t * Whenever the device calls 'notify', notifications will be sent to the caller of this verb.\n\t * */\n\taddListener({cmd,data,from,fromResource,owner,resource}) { this.$publish('addListener', {cmd,data,from,fromResource,owner,resource})}\n\t/**Response to 'getCapabilities'*/\n\tcapabilities({answeringResource,askingResource,capabilities}) { this.$publish('capabilities', {answeringResource,askingResource,capabilities})}\n\t/**\n\t * Executes a command\n\t *\n\t * A user executes a command on a device owned by anyone who granted him the right authorizations.\n\t * The command is issued on channel 'command'\n\t * */\n\texecute({resource,cmd,data,owner}) { this.$publish('execute', {resource,cmd,data,owner})}\n\t/**\n\t * Requests capabilities\n\t *\n\t * A user requests all his devices for the whole list of their capabilities.\n\t * Devices are expected to answer on channel 'capabilities'\n\t * */\n\tgetCapabilities({}) { this.$publish('getCapabilities', {})}\n\t/**\n\t * Notifies of some event\n\t *\n\t * A device notifies the registered users/devices on this channel.\n\t * The server forwards the notification to said users.\n\t * */\n\tnotify({cmd,data,from,fromResource,owner,resource}) { this.$publish('notify', {cmd,data,from,fromResource,owner,resource})}\n\t/**\n\t * Pings devices\n\t *\n\t * A user requests all devices (of all owners) on which he has authorizations to respond on channel 'pong'\n\t * */\n\tping({action}) { this.$publish('ping', {action})}\n\t/**Response to ping*/\n\tpong({action,available,owner,resource,uid,user}) { this.$publish('pong', {action,available,owner,resource,uid,user})}\n\t/**\n\t * Removes a listener\n\t *\n\t * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations\n\t * */\n\tremoveListener({cmd,data,from,fromResource,owner,resource}) { this.$publish('removeListener', {cmd,data,from,fromResource,owner,resource})}\n}\n/**\n * User API for groups and rights.\n *\n * Groups are stored per user.\n * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.\n * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.\n * @access public\n * */\nexport class GroupManagement extends Service {\n\t/**\n\t * Get default deployment id associated to GroupManagementService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'groups_0'\n\t}\n\t/**\n\t * Adds me to a group\n\t *\n\t * Adds me (the caller) to a group.\n\t * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\taddMe({group,owner}) { this.$publish('addMe', {group,owner})}\n\t/**\n\t * Adds a user to a group\n\t *\n\t * Adds the given user to the given group.\n\t * Addition may fail if the given group does not already exist.\n\t * */\n\taddUser({user,group,owner}) { this.$publish('addUser', {user,group,owner})}\n\t/**Adds users to a group*/\n\taddUsers({users,group,owner}) { this.$publish('addUsers', {users,group,owner})}\n\t/**\n\t * Lists my owned groups, with details\n\t *\n\t * Returns the whole list of groups owned by the current user, with their members\n\t * */\n\tallGroups({owner}) { this.$publish('allGroups', {owner})}\n\t/**\n\t * Creates a group\n\t *\n\t * Creates a group owned by the current user.\n\t * Group creation may fail if the group already exists.\n\t * */\n\tcreateGroup({group,groupName,owner}) { this.$publish('createGroup', {group,groupName,owner})}\n\t/**\n\t * Removes a group\n\t *\n\t * Removes the given group owned by the current user or the given owner.\n\t * Also removes all grants to that group.\n\t * */\n\tdelGroup({group,owner}) { this.$publish('delGroup', {group,owner})}\n\t/**Removes a user from a group*/\n\tdelUser({group,owner,user}) { this.$publish('delUser', {group,owner,user})}\n\t/**Removes users from a group*/\n\tdelUsers({group,groupName,owner,users}) { this.$publish('delUsers', {group,groupName,owner,users})}\n\t/**\n\t * Tests for a group's existence\n\t *\n\t * Returns whether a group exists or not.\n\t * */\n\texists({group,owner}) { this.$publish('exists', {group,owner})}\n\t/**\n\t * Grants a right to a group\n\t *\n\t * The granting API does not do any check when storing permissions.\n\t * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.\n\t * */\n\tgrant({action,group,owner,resource}) { this.$publish('grant', {action,group,owner,resource})}\n\t/**\n\t * Lists the group users\n\t *\n\t * Returns the whole list of users configured inside the given group.\n\t * */\n\tgroupUsers({group,owner}) { this.$publish('groupUsers', {group,owner})}\n\t/**\n\t * Lists my owned groups\n\t *\n\t * Returns the whole list of groups owned by the current user\n\t * */\n\tgroups({owner}) { this.$publish('groups', {owner})}\n\t/**\n\t * Lists rights for a group\n\t *\n\t * This API lists explicitly configured rights.\n\t * Effective rights include configured rights, implicit rights and inherited rights.\n\t * */\n\tlistGrants({group,owner}) { this.$publish('listGrants', {group,owner})}\n\t/**\n\t * Lists presences for a group\n\t *\n\t * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.\n\t * The current implementation does not include information about the particular devices users are connected with.\n\t * If a user is connected twice with two different devices, two identical entries will be returned.\n\t * */\n\tlistPresences({group,owner}) { this.$publish('listPresences', {group,owner})}\n\t/**\n\t * Tests membership\n\t *\n\t * Tests whether I (the caller) am a member of the given group.\n\t * This verb exists so that users can determine if they are part of a group without being granted particular rights.\n\t * The 'user' field is implicitly set to the current user's key.\n\t * */\n\tmemberOf({hardFail,group,owner}) { this.$publish('memberOf', {hardFail,group,owner})}\n\t/**\n\t * Grants rights to a group\n\t *\n\t * Grant several rights at once.\n\t * */\n\tmgrant({actions,group,owner,resource}) { this.$publish('mgrant', {actions,group,owner,resource})}\n\t/**Revokes rights for a group*/\n\tmrevoke({actions,group,owner,resource}) { this.$publish('mrevoke', {actions,group,owner,resource})}\n\t/**\n\t * Lists the groups I am part of\n\t *\n\t * Returns the whole list of groups the current user is part of.\n\t * Groups may be owned by anyone, including the current user.\n\t * */\n\tmyGroups({owner}) { this.$publish('myGroups', {owner})}\n\t/**Revokes a right for a group*/\n\trevoke({action,group,owner,resource}) { this.$publish('revoke', {action,group,owner,resource})}\n}\n/**\n * HTTP client\n *\n * Web-service client\n *  An admin records URL templates that can be called by users\n *  Calls are not configurable by end-users\n *  However an admin may leverage the macro service to achieve URL, headers and body configurability\n * */\n/**\n * User API for http requests\n *\n * @access public\n * */\nexport class Httpclient extends Service {\n\t/**\n\t * Get default deployment id associated to HttpclientService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'httpclient_0'\n\t}\n\t/**\n\t * Makes a predefined request\n\t *\n\t * Lookups a predefined request by name, and executes it.\n\t * */\n\tcall({name,requestId}) { this.$publish('call', {name,requestId})}\n\t/**\n\t * Makes a parameterized request\n\t *\n\t * Executes an HTTP request with the given url, method, headers and body.\n\t * */\n\trequest({}) { this.$publish('request', {})}\n}\n/**\n * Macros\n *\n * Macro-command service\n *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc\n *\n *\n *  End-users play them, with contextual parameters\n * */\n/**\n * User API for macro execution\n *\n * Simple errors are reported as usual.\n * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual 'error' channel, errors are put in the returned 'MacroCompletion' result.\n * This behavior can be tuned on a per-call basis with the hardFail parameter.\n * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE\n * @access public\n * */\nexport class Macro extends Service {\n\t/**\n\t * Get default deployment id associated to MacroService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'macro_0'\n\t}\n\t/**\n\t * Plays a previously recorded macro\n\t *\n\t * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.\n\t * You can override the default notification channel when defining the macro.\n\t * */\n\tcall({debug,hardFail,name,parameters}) { this.$publish('call', {debug,hardFail,name,parameters})}\n\t/**\n\t * Plays a previously recorded macro and returns the result.\n\t *\n\t * Use this verb when you want to synchronously call a macro from inside another macro.\n\t * */\n\tfunc({}) { this.$publish('func', {})}\n\t/**\n\t * Similar to func, with the ability to impersonate any user at will.\n\t *\n\t * Use this verb when you do not want to use or cannot use the standard rights system and wish to bypass it completely.\n\t * Use this verb sparingly, as it can give the caller any right on any resource.\n\t * */\n\tsudo({}) { this.$publish('sudo', {})}\n}\n/**\n * Mail sender\n *\n * Sends email through SMTP\n * */\n/**\n * Mail service user API\n *\n * This service is statically configured with an outgoing SMTP server.\n * Users call the API here to actually send emails.\n * @access public\n * */\nexport class Sendmail extends Service {\n\t/**\n\t * Get default deployment id associated to SendmailService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sendmail_0'\n\t}\n\t/**\n\t * Sends an email\n\t *\n\t * Sends an email with the given body to the intended recipients.\n\t * */\n\tsend({}) { this.$publish('send', {})}\n}\n/**\n * Messaging service\n *\n * Messaging service\n * */\n/**\n * Messaging service\n *\n * Simple and flexible user-to-user or user-to-group messaging service.\n * @access public\n * */\nexport class Messaging extends Service {\n\t/**\n\t * Get default deployment id associated to MessagingService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'messaging_0'\n\t}\n\t/**\n\t * Sends a message to a target\n\t *\n\t * Sends the given message to the specified target on the given (optional) channel.\n\t * The administratively given default channel name is used when none is provided in the message itself.\n\t * */\n\tsend({target,channel,data}) { this.$publish('send', {target,channel,data})}\n}\n/**\n * Producer consumer\n *\n * Producer consumer service\n *  Users can submit tasks and other users consume them\n * */\n/**\n * Producer / consumer real-time API\n *\n * Task producers submits their tasks.\n * The server dispatches the tasks.\n * Consumers process them and report completion back to the server.\n * Tasks are global to the service (i.e. NOT per user).\n * @access public\n * */\nexport class Queue extends Service {\n\t/**\n\t * Get default deployment id associated to QueueService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'queue_0'\n\t}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be returned to the caller.\n\t * When called from inside a macro, the comsumer generated result is available for further use.\n\t * */\n\tcall({description,originBusinessId,originDeploymentId,data,owner}) { this.$publish('call', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Notifies completion of a task\n\t *\n\t * Consumer API.\n\t * The tasker notifies completion of the given task to the server.\n\t * The tasker can optionally include a result or an error code.\n\t * */\n\tdone({result,success,taskId}) { this.$publish('done', {result,success,taskId})}\n\t/**\n\t * Registers a consumer\n\t *\n\t * Consumer API.\n\t * Registers the current user resource as an available task consumer.\n\t * Tasks will be then dispatched to that consumer.\n\t * */\n\tregister({capacity}) { this.$publish('register', {capacity})}\n\t/**\n\t * Submits a task\n\t *\n\t * Producer API.\n\t * A task producer submits the given task to the server.\n\t * The server will find a tasker with processing capacity and dispatch the task.\n\t * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).\n\t * This verb will return immediately : you can use this API to asynchronously submit a task.\n\t * */\n\tsubmit({description,originBusinessId,originDeploymentId,data,owner}) { this.$publish('submit', {description,originBusinessId,originDeploymentId,data,owner})}\n\t/**\n\t * Unregisters a consumer\n\t *\n\t * Consumer API.\n\t * Unregisters the current user resource as an available task consumer.\n\t * All non finished tasks are returned to the server.\n\t * */\n\tunregister({}) { this.$publish('unregister', {})}\n}\n/**\n * SMS via OVH\n *\n * SMS sender, to send text messages to mobile phones\n * This SMS sending service uses the OVH API\n *\n * */\n/**\n * SMS service\n *\n * User API for SMS.\n * @access public\n * */\nexport class Sms_ovh extends Service {\n\t/**\n\t * Get default deployment id associated to Sms_ovhService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'sms_ovh_0'\n\t}\n\t/**\n\t * Sends an SMS\n\t *\n\t * Sends the given message to the given recipients.\n\t * */\n\tsend({}) { this.$publish('send', {})}\n}\n/**\n * Scheduler\n *\n * Scheduler service\n *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)\n * */\n/**\n * User API for the Scheduler\n *\n * User endpoints for scheduling : users can schedule, list and delete tasks.\n * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.\n * Tasks are run on the server and thus can call api verbs marked as server-only.\n * @access public\n * */\nexport class Cron extends Service {\n\t/**\n\t * Get default deployment id associated to CronService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'cron_0'\n\t}\n\t/**\n\t * List the configured tasks\n\t *\n\t * Returns a paginated list of the asking user's tasks.\n\t * */\n\tlist({owner,page,start,stop}) { this.$publish('list', {owner,page,start,stop})}\n\t/**\n\t * Schedules a task\n\t *\n\t * Schedules a task for later execution.\n\t * If a task already exists with the same cronName, this new task completely replaces it.\n\t * A task can be scheduled with a cron-like syntax for repetitive or one-shot execution.\n\t * Wildcards are not allowed for minutes and hours.\n\t * When scheduling for one-shot execution, the time must be at least two minutes into the future.\n\t * */\n\tschedule({}) { this.$publish('schedule', {})}\n\t/**\n\t * Removes a scheduled task\n\t *\n\t * Removes a previously scheduled task.\n\t * Does absolutely nothing if asked to remove a non-existent task.\n\t * */\n\tunschedule({cronName,owner}) { this.$publish('unschedule', {cronName,owner})}\n}\n/**\n * Search engine\n *\n * ElasticSearch engine, to index and search data\n *  An admin creates indices\n *  Users index and search documents\n *\n * */\n/**\n * ElasticSearch Service\n *\n * This API is a very thin wrapper around ElasticSearch's API.\n * @access public\n * */\nexport class Search extends Service {\n\t/**\n\t * Get default deployment id associated to SearchService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'search_0'\n\t}\n\t/**\n\t * Deletes data\n\t *\n\t * Deletes a document from the elasticsearch engine by id.\n\t * */\n\tdelete({id,index,type}) { this.$publish('delete', {id,index,type})}\n\t/**\n\t * Gets data\n\t *\n\t * Retrieves a document from the elasticsearch engine by id.\n\t * */\n\tget({id,index,type}) { this.$publish('get', {id,index,type})}\n\t/**\n\t * Indexes data\n\t *\n\t * Inserts or updates a document into the elasticsearch engine.\n\t * */\n\tindex({data,id,index,type}) { this.$publish('index', {data,id,index,type})}\n\t/**Searches for data*/\n\tsearch({indices,page,query,sort}) { this.$publish('search', {indices,page,query,sort})}\n}\n/**\n * Template engine\n *\n * Template engine to produce documents from parameterized templates\n * <br>An admin creates templates\n * <br> Users produce documents\n * <br>The implementation uses the <a href='http://freemarker\n * org/'>freemarker</a> engine\n *\n * */\n/**\n * User API for templates\n *\n * Users use this API to evaluate pre-configured templates.\n * @access public\n * */\nexport class Template extends Service {\n\t/**\n\t * Get default deployment id associated to TemplateService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'template_0'\n\t}\n\t/**\n\t * Evaluates a template\n\t *\n\t * Evaluates the given template and returns the result as a string.\n\t * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.\n\t * */\n\tevaluate({data,languageTag,name,requestId}) { this.$publish('evaluate', {data,languageTag,name,requestId})}\n}\n/**\n * Upload: S3\n *\n * Upload service with S3 storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3 extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3Service\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,owner,path}) { this.$publish('cp', {oldPath,owner,path})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({owner,path}) { this.$publish('du', {owner,path})}\n\t/**Requests an upload URL without constraints.*/\n\tfreeUploadUrl({}) { this.$publish('freeUploadUrl', {})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,owner,path}) { this.$publish('link', {oldPath,owner,path})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({folder,owner,parents}) { this.$publish('mkdir', {folder,owner,parents})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,owner,path}) { this.$publish('mv', {oldPath,owner,path})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({guid,metadata,owner,tags}) { this.$publish('newFile', {guid,metadata,owner,tags})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,owner,path}) { this.$publish('newUploadUrl', {contentType,owner,path})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({owner,path}) { this.$publish('rm', {owner,path})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({owner,path}) { this.$publish('stat', {owner,path})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({metadata,metadataFiles,owner,path}) { this.$publish('updateMeta', {metadata,metadataFiles,owner,path})}\n}\n/**\n * Upload: local\n *\n * Upload service with local HDFS storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_hdfs extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_hdfsService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_hdfs_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,owner,path}) { this.$publish('cp', {oldPath,owner,path})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({owner,path}) { this.$publish('du', {owner,path})}\n\t/**Requests an upload URL without constraints.*/\n\tfreeUploadUrl({}) { this.$publish('freeUploadUrl', {})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,owner,path}) { this.$publish('link', {oldPath,owner,path})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({folder,owner,parents}) { this.$publish('mkdir', {folder,owner,parents})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,owner,path}) { this.$publish('mv', {oldPath,owner,path})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({guid,metadata,owner,tags}) { this.$publish('newFile', {guid,metadata,owner,tags})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,owner,path}) { this.$publish('newUploadUrl', {contentType,owner,path})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({owner,path}) { this.$publish('rm', {owner,path})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({owner,path}) { this.$publish('stat', {owner,path})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({metadata,metadataFiles,owner,path}) { this.$publish('updateMeta', {metadata,metadataFiles,owner,path})}\n}\n/**\n * Upload: pseudo-S3\n *\n * Upload service with pseudo-S3compatible storage\n * */\n/**\n * User API for file management\n *\n * User API for virtual file management and http file upload\n * This API contains all the verbs needed to browse, upload and remove files.\n * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.\n * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.\n * @access public\n * */\nexport class Zpfs_s3compat extends Service {\n\t/**\n\t * Get default deployment id associated to Zpfs_s3compatService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'zpfs_s3compat_0'\n\t}\n\t/**\n\t * Copies a file\n\t *\n\t * Copies a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tcp({oldPath,owner,path}) { this.$publish('cp', {oldPath,owner,path})}\n\t/**\n\t * Returns disk usage\n\t *\n\t * Returns an recursively aggregated number of used bytes, starting at the given path.\n\t * */\n\tdu({owner,path}) { this.$publish('du', {owner,path})}\n\t/**Requests an upload URL without constraints.*/\n\tfreeUploadUrl({}) { this.$publish('freeUploadUrl', {})}\n\t/**\n\t * Links a file\n\t *\n\t * Links a file or folder to another location.\n\t * May fail if the target location is not empty.\n\t * */\n\tlink({oldPath,owner,path}) { this.$publish('link', {oldPath,owner,path})}\n\t/**\n\t * Lists a folder content\n\t *\n\t * Returns a paginated list of the folder's content.\n\t * */\n\tls({folder,owner,page}) { this.$publish('ls', {folder,owner,page})}\n\t/**\n\t * Creates a folder\n\t *\n\t * Creates a new folder.\n\t * May fail if the target location is not empty.\n\t * */\n\tmkdir({folder,owner,parents}) { this.$publish('mkdir', {folder,owner,parents})}\n\t/**\n\t * Moves a file\n\t *\n\t * Moves a file or folder (recursively) to a new location.\n\t * May fail if the target location is not empty.\n\t * */\n\tmv({oldPath,owner,path}) { this.$publish('mv', {oldPath,owner,path})}\n\t/**\n\t * Notifies of upload completion\n\t *\n\t * The client application calls this verb to notify that it's done uploading to the cloud.\n\t * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.\n\t * */\n\tnewFile({guid,metadata,owner,tags}) { this.$publish('newFile', {guid,metadata,owner,tags})}\n\t/**\n\t * Requests an upload URL\n\t *\n\t * Requests an HTTP upload URL.\n\t * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.\n\t * */\n\tnewUploadUrl({contentType,owner,path}) { this.$publish('newUploadUrl', {contentType,owner,path})}\n\t/**\n\t * Removes a file\n\t *\n\t * Removes a file or folder (recursively).\n\t * */\n\trm({owner,path}) { this.$publish('rm', {owner,path})}\n\t/**\n\t * Returns information about a file\n\t *\n\t * Returns information about a single file.\n\t * The entry field will be null if the path does not exist\n\t * */\n\tstat({owner,path}) { this.$publish('stat', {owner,path})}\n\t/**Updates a file's metadata*/\n\tupdateMeta({metadata,metadataFiles,owner,path}) { this.$publish('updateMeta', {metadata,metadataFiles,owner,path})}\n}\n/**\n * User directory service\n *\n * User directory service\n * */\n/**\n * User API for user information\n *\n * @access public\n * */\nexport class Userdir extends Service {\n\t/**\n\t * Get default deployment id associated to UserdirService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'userdir_0'\n\t}\n\t/**Searches for users matching the request*/\n\tsearch({page,query,requestId}) { this.$publish('search', {page,query,requestId})}\n\t/**Requests public data for the specified users*/\n\tuserInfo({userKeys}) { this.$publish('userInfo', {userKeys})}\n}\n/**\n * Delegating authentication\n *\n * This authentication delegates authentication to an external auth provider\n * <br>When a zetapush client handshakes with a delegated authentication, the 'token' field given by the client is sent to the configured remote server as part of the URL\n * <br>The response must be in JSON format\n *  Each key of the response will be considered a user information field name\n *\n * */\n/**\n * End-user API for the delegating authentication\n *\n * Provisionning verbs.\n * @access public\n * */\nexport class Delegating extends Service {\n\t/**\n\t * Get default deployment id associated to DelegatingService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'delegating_0'\n\t}\n\t/**\n\t * Get user info\n\t *\n\t * Retrieves cached user info or (if missing) eagerly creates a zetapush key for the user.\n\t * The returned field 'zetapushKey' is a unique and permanent ID identifying a user in a sandbox.\n\t * */\n\tuserInfo({}) { this.$publish('userInfo', {})}\n}\n/**\n * Local authentication\n *\n * Zetapush local authentication\n *  The configurer can choose the primary key and mandatory user fields for account creation\n *  The field 'zetapushKey' is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the <b>__userKey</b> pseudo-constant)\n * */\n/**\n * End-user API for the simple local authentication\n *\n * These API verbs allow end-users to manage their account.\n * @access public\n * */\nexport class Simple extends Service {\n\t/**\n\t * Get default deployment id associated to SimpleService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'simple_0'\n\t}\n\t/**\n\t * Changes a password\n\t *\n\t * Changes a user password for this authentication realm.\n\t * The user can be either implicit (the current user) or deduced from the token.\n\t * The change is effective immediately. However, already logged in users might stay connected.\n\t * */\n\tchangePassword({}) { this.$publish('changePassword', {})}\n\t/**\n\t * Checks some account's existence\n\t *\n\t * Checks whether the given user already exists in this 'simple' authentication realm.\n\t * */\n\tcheckUser({}) { this.$publish('checkUser', {})}\n\t/**\n\t * Creates a user\n\t *\n\t * Creates a new user in this 'simple' authentication realm.\n\t * */\n\tcreateUser({}) { this.$publish('createUser', {})}\n\t/**\n\t * Deletes a user\n\t *\n\t * Deletes an existing user in this 'simple' authentication realm.\n\t * */\n\tdeleteUser({}) { this.$publish('deleteUser', {})}\n\t/**\n\t * Requests a password reset\n\t *\n\t * Requests a password reset for the given unique key.\n\t * The key must exist and must be given, as it cannot obviously be deduced from the currently logged in user.\n\t * The returned token needs to be sent to the intended recipient only. The typical use case is to define a macro that requests a reset, generates a email template and emails the user. The macro can then be safely called by a weakly authenticated user.\n\t * Requesting a reset does not invalidate the password.\n\t * Requesting a reset again invalidates previous reset requests (only the last token is usable)\n\t * */\n\trequestReset({}) { this.$publish('requestReset', {})}\n\t/**\n\t * Updates a user\n\t *\n\t * Updates an existing user in this 'simple' authentication realm.\n\t * */\n\tupdateUser({}) { this.$publish('updateUser', {})}\n}\n/**\n * Weak authentication\n *\n * The weak authentication allows for anonymous authentication of devices\n *  Such devices can display a qrcode to allow regular users to take control of them\n * */\n/**\n * User API for weak devices control\n *\n * User API for control and release of weakly authenticated user sessions.\n * @access public\n * */\nexport class Weak extends Service {\n\t/**\n\t * Get default deployment id associated to WeakService\n\t * @return {string}\n\t */\n\tstatic get DEFAULT_DEPLOYMENT_ID() {\n\t\treturn 'weak_0'\n\t}\n\t/**\n\t * Controls a session\n\t *\n\t * Takes control of a weak user session, identified by the given public token.\n\t * The public token has been previously made available by the controlled device, for example by displaying a QRCode.\n\t * Upon control notification, the client SDK of the controlled session is expected to re-handshake.\n\t * */\n\tcontrol({fullRights,publicToken}) { this.$publish('control', {fullRights,publicToken})}\n\t/**\n\t * Releases a session\n\t *\n\t * Releases control of a weak user session, identified by the given public token.\n\t * The weak user session must have been previously controlled by a call to 'control'.\n\t * */\n\trelease({fullRights,publicToken}) { this.$publish('release', {fullRights,publicToken})}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/services/index.js\n **/","/**\n * Define life cycle connection methods\n * @access public\n */\nexport class ConnectionStatusListener {\n  /**\n   * Callback fired when connection is broken\n   */\n  onConnectionBroken() {}\n  /**\n   * Callback fired when connection is closed\n   */\n  onConnectionClosed() {}\n  /**\n   * Callback fired when connection is established\n   */\n  onConnectionEstablished() {}\n  /**\n  * Callback fired when connection will close\n  */\n  onConnectionWillClose() {}\n  /**\n   * Callback fired when an error occurs in handshake step\n   * @param {Object} error\n   */\n  onFailedHandshake(error) {}\n  /**\n   * Callback fired when a message is lost\n   */\n  onMessageLost() {}\n  /**\n   * Callback fired when handshake step succeed\n   * @param {Object} authentication\n   */\n  onSuccessfulHandshake(authentication) {}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/connection/connection-status.js\n **/","import { Transport, LongPollingTransport, WebSocketTransport } from 'zetapush-cometd'\n\n/**\n * Implements LongPollingTransport using borwser fetch() API\n * @access private\n * @return {FetchLongPollingTransport}\n */\nexport function FetchLongPollingTransport() {\n  const _super = new LongPollingTransport()\n  const that = Transport.derive(_super)\n\n  /**\n   * Implements transport via fetch() API\n   * @param {Object} packet\n   */\n  that.xhrSend = function (packet) {\n    fetch(packet.url, {\n      method: 'post',\n      body: packet.body,\n      headers: Object.assign(packet.headers, {\n        'Content-Type': 'application/json;charset=UTF-8'\n      })\n    })\n    .then((response) => {\n      return response.json()\n    })\n    .then(packet.onSuccess)\n    .catch(packet.onError)\n  }\n\n  return that\n}\n\n/**\n * CometD Transports enumeration\n */\nexport const TransportTypes = {\n  LONG_POLLING: 'long-polling',\n  WEBSOCKET: 'websocket'\n}\n\n/**\n * CometD Transports Layers map\n */\nexport const TransportLayers = [{\n  type: TransportTypes.WEBSOCKET,\n  Transport: WebSocketTransport\n}, {\n  type: TransportTypes.LONG_POLLING,\n  Transport: FetchLongPollingTransport\n}]\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/connection/cometd.js\n **/","module.exports = {\n  CallbackPollingTransport: require('./lib/CallbackPollingTransport'),\n  CometD: require('./lib/CometD'),\n  LongPollingTransport: require('./lib/LongPollingTransport'),\n  RequestTransport: require('./lib/RequestTransport'),\n  Transport: require('./lib/Transport'),\n  TransportRegistry: require('./lib/TransportRegistry'),\n  Utils: require('./lib/Utils'),\n  WebSocketTransport: require('./lib/WebSocketTransport')\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/index.js\n ** module id = 7\n ** module chunks = 0\n **/","var Transport = require('./Transport');\nvar RequestTransport = require('./RequestTransport');\n\nmodule.exports = function CallbackPollingTransport() {\n    var _super = new RequestTransport();\n    var _self = Transport.derive(_super);\n\n    _self.accept = function(version, crossDomain, url) {\n        return true;\n    };\n\n    _self.jsonpSend = function(packet) {\n        throw 'Abstract';\n    };\n\n    function _failTransportFn(envelope, request, x) {\n        var self = this;\n        return function() {\n            self.transportFailure(envelope, request, 'error', x);\n        };\n    }\n\n    _self.transportSend = function(envelope, request) {\n        var self = this;\n\n        // Microsoft Internet Explorer has a 2083 URL max length\n        // We must ensure that we stay within that length\n        var start = 0;\n        var length = envelope.messages.length;\n        var lengths = [];\n        while (length > 0) {\n            // Encode the messages because all brackets, quotes, commas, colons, etc\n            // present in the JSON will be URL encoded, taking many more characters\n            var json = JSON.stringify(envelope.messages.slice(start, start + length));\n            var urlLength = envelope.url.length + encodeURI(json).length;\n\n            var maxLength = this.getConfiguration().maxURILength;\n            if (urlLength > maxLength) {\n                if (length === 1) {\n                    var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +\n                        'for transport ' + this.getType();\n                    // Keep the semantic of calling response callbacks asynchronously after the request\n                    self.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);\n                    return;\n                }\n\n                --length;\n                continue;\n            }\n\n            lengths.push(length);\n            start += length;\n            length = envelope.messages.length - start;\n        }\n\n        // Here we are sure that the messages can be sent within the URL limit\n\n        var envelopeToSend = envelope;\n        if (lengths.length > 1) {\n            var begin = 0;\n            var end = lengths[0];\n            this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));\n            envelopeToSend = this._mixin(false, {}, envelope);\n            envelopeToSend.messages = envelope.messages.slice(begin, end);\n            envelopeToSend.onSuccess = envelope.onSuccess;\n            envelopeToSend.onFailure = envelope.onFailure;\n\n            for (var i = 1; i < lengths.length; ++i) {\n                var nextEnvelope = this._mixin(false, {}, envelope);\n                begin = end;\n                end += lengths[i];\n                nextEnvelope.messages = envelope.messages.slice(begin, end);\n                nextEnvelope.onSuccess = envelope.onSuccess;\n                nextEnvelope.onFailure = envelope.onFailure;\n                this.send(nextEnvelope, request.metaConnect);\n            }\n        }\n\n        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);\n\n        try {\n            var sameStack = true;\n            this.jsonpSend({\n                transport: this,\n                url: envelopeToSend.url,\n                sync: envelopeToSend.sync,\n                headers: this.getConfiguration().requestHeaders,\n                body: JSON.stringify(envelopeToSend.messages),\n                onSuccess: function(responses) {\n                    var success = false;\n                    try {\n                        var received = self.convertToMessages(responses);\n                        if (received.length === 0) {\n                            self.transportFailure(envelopeToSend, request, {\n                                httpCode: 204\n                            });\n                        } else {\n                            success = true;\n                            self.transportSuccess(envelopeToSend, request, received);\n                        }\n                    } catch (x) {\n                        self._debug(x);\n                        if (!success) {\n                            self.transportFailure(envelopeToSend, request, {\n                                exception: x\n                            });\n                        }\n                    }\n                },\n                onError: function(reason, exception) {\n                    var failure = {\n                        reason: reason,\n                        exception: exception\n                    };\n                    if (sameStack) {\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        self.setTimeout(function() {\n                            self.transportFailure(envelopeToSend, request, failure);\n                        }, 0);\n                    } else {\n                        self.transportFailure(envelopeToSend, request, failure);\n                    }\n                }\n            });\n            sameStack = false;\n        } catch (xx) {\n            // Keep the semantic of calling response callbacks asynchronously after the request\n            self.setTimeout(function() {\n                self.transportFailure(envelopeToSend, request, {\n                    exception: xx\n                });\n            }, 0);\n        }\n    };\n\n    return _self;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/CallbackPollingTransport.js\n ** module id = 8\n ** module chunks = 0\n **/","var Utils = require('./Utils')\n\n/**\n * Base object with the common functionality for transports.\n */\nmodule.exports = function Transport() {\n    var _type;\n    var _cometd;\n    var _url;\n\n    /**\n     * Function invoked just after a transport has been successfully registered.\n     * @param type the type of transport (for example 'long-polling')\n     * @param cometd the cometd object this transport has been registered to\n     * @see #unregistered()\n     */\n    this.registered = function(type, cometd) {\n        _type = type;\n        _cometd = cometd;\n    };\n\n    /**\n     * Function invoked just after a transport has been successfully unregistered.\n     * @see #registered(type, cometd)\n     */\n    this.unregistered = function() {\n        _type = null;\n        _cometd = null;\n    };\n\n    this._debug = function() {\n        _cometd._debug.apply(_cometd, arguments);\n    };\n\n    this._mixin = function() {\n        return _cometd._mixin.apply(_cometd, arguments);\n    };\n\n    this.getConfiguration = function() {\n        return _cometd.getConfiguration();\n    };\n\n    this.getAdvice = function() {\n        return _cometd.getAdvice();\n    };\n\n    this.setTimeout = function(funktion, delay) {\n        return Utils.setTimeout(_cometd, funktion, delay);\n    };\n\n    this.clearTimeout = function(handle) {\n        Utils.clearTimeout(handle);\n    };\n\n    /**\n     * Converts the given response into an array of bayeux messages\n     * @param response the response to convert\n     * @return an array of bayeux messages obtained by converting the response\n     */\n    this.convertToMessages = function(response) {\n        if (Utils.isString(response)) {\n            try {\n                return JSON.parse(response);\n            } catch (x) {\n                this._debug('Could not convert to JSON the following string', '\"' + response + '\"');\n                throw x;\n            }\n        }\n        if (Utils.isArray(response)) {\n            return response;\n        }\n        if (response === undefined || response === null) {\n            return [];\n        }\n        if (response instanceof Object) {\n            return [response];\n        }\n        throw 'Conversion Error ' + response + ', typeof ' + (typeof response);\n    };\n\n    /**\n     * Returns whether this transport can work for the given version and cross domain communication case.\n     * @param version a string indicating the transport version\n     * @param crossDomain a boolean indicating whether the communication is cross domain\n     * @param url the URL to connect to\n     * @return true if this transport can work for the given version and cross domain communication case,\n     * false otherwise\n     */\n    this.accept = function(version, crossDomain, url) {\n        throw 'Abstract';\n    };\n\n    /**\n     * Returns the type of this transport.\n     * @see #registered(type, cometd)\n     */\n    this.getType = function() {\n        return _type;\n    };\n\n    this.getURL = function() {\n        return _url;\n    };\n\n    this.setURL = function(url) {\n        _url = url;\n    };\n\n    this.send = function(envelope, metaConnect) {\n        throw 'Abstract';\n    };\n\n    this.reset = function(init) {\n        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');\n    };\n\n    this.abort = function() {\n        this._debug('Transport', _type, 'aborted');\n    };\n\n    this.toString = function() {\n        return this.getType();\n    };\n};\n\nmodule.exports.derive = function(baseObject) {\n    function F() {\n    }\n\n    F.prototype = baseObject;\n    return new F();\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/Transport.js\n ** module id = 9\n ** module chunks = 0\n **/","exports.isString = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return typeof value === 'string' || value instanceof String;\n};\n\nexports.isArray = function (value) {\n    if (value === undefined || value === null) {\n        return false;\n    }\n    return value instanceof Array;\n};\n\n/**\n * Returns whether the given element is contained into the given array.\n * @param element the element to check presence for\n * @param array the array to check for the element presence\n * @return the index of the element, if present, or a negative index if the element is not present\n */\nexports.inArray = function (element, array) {\n    for (var i = 0; i < array.length; ++i) {\n        if (element === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nexports.setTimeout = function (cometd, funktion, delay) {\n    return setTimeout(function() {\n        try {\n            cometd._debug('Invoking timed function', funktion);\n            funktion();\n        } catch (x) {\n            cometd._debug('Exception invoking timed function', funktion, x);\n        }\n    }, delay);\n};\n\nexports.clearTimeout = function (timeoutHandle) {\n    clearTimeout(timeoutHandle);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/Utils.js\n ** module id = 10\n ** module chunks = 0\n **/","var Transport = require('./Transport')\nvar Utils = require('./Utils')\n\n/**\n * Base object with the common functionality for transports based on requests.\n * The key responsibility is to allow at most 2 outstanding requests to the server,\n * to avoid that requests are sent behind a long poll.\n * To achieve this, we have one reserved request for the long poll, and all other\n * requests are serialized one after the other.\n */\nmodule.exports = function RequestTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _requestIds = 0;\n    var _metaConnectRequest = null;\n    var _requests = [];\n    var _envelopes = [];\n\n    function _coalesceEnvelopes(envelope) {\n        while (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes[0];\n            var newEnvelope = envelopeAndRequest[0];\n            var newRequest = envelopeAndRequest[1];\n            if (newEnvelope.url === envelope.url &&\n                newEnvelope.sync === envelope.sync) {\n                _envelopes.shift();\n                envelope.messages = envelope.messages.concat(newEnvelope.messages);\n                this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);\n                continue;\n            }\n            break;\n        }\n    }\n\n    function _transportSend(envelope, request) {\n        this.transportSend(envelope, request);\n        request.expired = false;\n\n        if (!envelope.sync) {\n            var maxDelay = this.getConfiguration().maxNetworkDelay;\n            var delay = maxDelay;\n            if (request.metaConnect === true) {\n                delay += this.getAdvice().timeout;\n            }\n\n            this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);\n\n            var self = this;\n            request.timeout = self.setTimeout(function() {\n                request.expired = true;\n                var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';\n                var failure = {\n                    reason: errorMessage\n                };\n                var xhr = request.xhr;\n                failure.httpCode = self.xhrStatus(xhr);\n                self.abortXHR(xhr);\n                self._debug(errorMessage);\n                self.complete(request, false, request.metaConnect);\n                envelope.onFailure(xhr, envelope.messages, failure);\n            }, delay);\n        }\n    }\n\n    function _queueSend(envelope) {\n        var requestId = ++_requestIds;\n        var request = {\n            id: requestId,\n            metaConnect: false,\n            envelope: envelope\n        };\n\n        // Consider the metaConnect requests which should always be present\n        if (_requests.length < this.getConfiguration().maxConnections - 1) {\n            _requests.push(request);\n            _transportSend.call(this, envelope, request);\n        } else {\n            this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);\n            _envelopes.push([envelope, request]);\n        }\n    }\n\n    function _metaConnectComplete(request) {\n        var requestId = request.id;\n        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);\n        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {\n            throw 'Longpoll request mismatch, completing request ' + requestId;\n        }\n\n        // Reset metaConnect request\n        _metaConnectRequest = null;\n    }\n\n    function _complete(request, success) {\n        var index = Utils.inArray(request, _requests);\n        // The index can be negative if the request has been aborted\n        if (index >= 0) {\n            _requests.splice(index, 1);\n        }\n\n        if (_envelopes.length > 0) {\n            var envelopeAndRequest = _envelopes.shift();\n            var nextEnvelope = envelopeAndRequest[0];\n            var nextRequest = envelopeAndRequest[1];\n            this._debug('Transport dequeued request', nextRequest.id);\n            if (success) {\n                if (this.getConfiguration().autoBatch) {\n                    _coalesceEnvelopes.call(this, nextEnvelope);\n                }\n                _queueSend.call(this, nextEnvelope);\n                this._debug('Transport completed request', request.id, nextEnvelope);\n            } else {\n                // Keep the semantic of calling response callbacks asynchronously after the request\n                var self = this;\n                self.setTimeout(function() {\n                    self.complete(nextRequest, false, nextRequest.metaConnect);\n                    var failure = {\n                        reason: 'Previous request failed'\n                    };\n                    var xhr = nextRequest.xhr;\n                    failure.httpCode = self.xhrStatus(xhr);\n                    nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);\n                }, 0);\n            }\n        }\n    }\n\n    _self.complete = function(request, success, metaConnect) {\n        if (metaConnect) {\n            _metaConnectComplete.call(this, request);\n        } else {\n            _complete.call(this, request, success);\n        }\n    };\n\n    /**\n     * Performs the actual send depending on the transport type details.\n     * @param envelope the envelope to send\n     * @param request the request information\n     */\n    _self.transportSend = function(envelope, request) {\n        throw 'Abstract';\n    };\n\n    _self.transportSuccess = function(envelope, request, responses) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, true, request.metaConnect);\n            if (responses && responses.length > 0) {\n                envelope.onSuccess(responses);\n            } else {\n                envelope.onFailure(request.xhr, envelope.messages, {\n                    httpCode: 204\n                });\n            }\n        }\n    };\n\n    _self.transportFailure = function(envelope, request, failure) {\n        if (!request.expired) {\n            this.clearTimeout(request.timeout);\n            this.complete(request, false, request.metaConnect);\n            envelope.onFailure(request.xhr, envelope.messages, failure);\n        }\n    };\n\n    function _metaConnectSend(envelope) {\n        if (_metaConnectRequest !== null) {\n            throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';\n        }\n\n        var requestId = ++_requestIds;\n        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);\n        var request = {\n            id: requestId,\n            metaConnect: true,\n            envelope: envelope\n        };\n        _transportSend.call(this, envelope, request);\n        _metaConnectRequest = request;\n    }\n\n    _self.send = function(envelope, metaConnect) {\n        if (metaConnect) {\n            _metaConnectSend.call(this, envelope);\n        } else {\n            _queueSend.call(this, envelope);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        for (var i = 0; i < _requests.length; ++i) {\n            var request = _requests[i];\n            if (request) {\n                this._debug('Aborting request', request);\n                if (!this.abortXHR(request.xhr)) {\n                    this.transportFailure(request.envelope, request, {reason: 'abort'});\n                }\n            }\n        }\n        if (_metaConnectRequest) {\n            this._debug('Aborting metaConnect request', _metaConnectRequest);\n            if (!this.abortXHR(_metaConnectRequest.xhr)) {\n                this.transportFailure(_metaConnectRequest.envelope, _metaConnectRequest, {reason: 'abort'});\n            }\n        }\n        this.reset(true);\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _metaConnectRequest = null;\n        _requests = [];\n        _envelopes = [];\n    };\n\n    _self.abortXHR = function(xhr) {\n        if (xhr) {\n            try {\n                var state = xhr.readyState;\n                xhr.abort();\n                return state !== XMLHttpRequest.UNSENT;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return false;\n    };\n\n    _self.xhrStatus = function(xhr) {\n        if (xhr) {\n            try {\n                return xhr.status;\n            } catch (x) {\n                this._debug(x);\n            }\n        }\n        return -1;\n    };\n\n    return _self;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/RequestTransport.js\n ** module id = 11\n ** module chunks = 0\n **/","var TransportRegistry = require('./TransportRegistry')\nvar Utils = require('./Utils')\n/**\n * The constructor for a CometD object, identified by an optional name.\n * The default name is the string 'default'.\n * In the rare case a page needs more than one Bayeux conversation,\n * a new instance can be created via:\n * <pre>\n * var bayeuxUrl2 = ...;\n *\n * // Dojo style\n * var cometd2 = new dojox.CometD('another_optional_name');\n *\n * // jQuery style\n * var cometd2 = new $.CometD('another_optional_name');\n *\n * cometd2.init({url: bayeuxUrl2});\n * </pre>\n * @param name the optional name of this cometd object\n */\nmodule.exports = function CometD(name) {\n    var _cometd = this;\n    var _name = name || 'default';\n    var _crossDomain = false;\n    var _transports = new TransportRegistry();\n    var _transport;\n    var _status = 'disconnected';\n    var _messageId = 0;\n    var _clientId = null;\n    var _batch = 0;\n    var _messageQueue = [];\n    var _internalBatch = false;\n    var _listeners = {};\n    var _backoff = 0;\n    var _scheduledSend = null;\n    var _extensions = [];\n    var _advice = {};\n    var _handshakeProps;\n    var _handshakeCallback;\n    var _callbacks = {};\n    var _remoteCalls = {};\n    var _reestablish = false;\n    var _connected = false;\n    var _unconnectTime = 0;\n    var _handshakeMessages = 0;\n    var _config = {\n        protocol: null,\n        stickyReconnect: true,\n        connectTimeout: 0,\n        maxConnections: 2,\n        backoffIncrement: 1000,\n        maxBackoff: 60000,\n        logLevel: 'info',\n        reverseIncomingExtensions: true,\n        maxNetworkDelay: 10000,\n        requestHeaders: {},\n        appendMessageTypeToURL: true,\n        autoBatch: false,\n        urls: {},\n        maxURILength: 2000,\n        advice: {\n            timeout: 60000,\n            interval: 0,\n            reconnect: 'retry',\n            maxInterval: 0\n        }\n    };\n\n    function _fieldValue(object, name) {\n        try {\n            return object[name];\n        } catch (x) {\n            return undefined;\n        }\n    }\n\n    /**\n     * Mixes in the given objects into the target object by copying the properties.\n     * @param deep if the copy must be deep\n     * @param target the target object\n     * @param objects the objects whose properties are copied into the target\n     */\n    this._mixin = function(deep, target, objects) {\n        var result = target || {};\n\n        // Skip first 2 parameters (deep and target), and loop over the others\n        for (var i = 2; i < arguments.length; ++i) {\n            var object = arguments[i];\n\n            if (object === undefined || object === null) {\n                continue;\n            }\n\n            for (var propName in object) {\n                if (object.hasOwnProperty(propName)) {\n                    var prop = _fieldValue(object, propName);\n                    var targ = _fieldValue(result, propName);\n\n                    // Avoid infinite loops\n                    if (prop === target) {\n                        continue;\n                    }\n                    // Do not mixin undefined values\n                    if (prop === undefined) {\n                        continue;\n                    }\n\n                    if (deep && typeof prop === 'object' && prop !== null) {\n                        if (prop instanceof Array) {\n                            result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);\n                        } else {\n                            var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};\n                            result[propName] = this._mixin(deep, source, prop);\n                        }\n                    } else {\n                        result[propName] = prop;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    function _isString(value) {\n        return Utils.isString(value);\n    }\n\n    function _isFunction(value) {\n        if (value === undefined || value === null) {\n            return false;\n        }\n        return typeof value === 'function';\n    }\n\n    function _zeroPad(value, length) {\n        var result = '';\n        while (--length > 0) {\n            if (value >= Math.pow(10, length)) {\n                break;\n            }\n            result += '0';\n        }\n        result += value;\n        return result;\n    }\n\n    function _log(level, args) {\n        if ('undefined' !== typeof console) {\n            var logger = console[level];\n            if (_isFunction(logger)) {\n                var now = new Date();\n                [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' +\n                        _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));\n                logger.apply(console, args);\n            }\n        }\n    }\n\n    this._warn = function() {\n        _log('warn', arguments);\n    };\n\n    this._info = function() {\n        if (_config.logLevel !== 'warn') {\n            _log('info', arguments);\n        }\n    };\n\n    this._debug = function() {\n        if (_config.logLevel === 'debug') {\n            _log('debug', arguments);\n        }\n    };\n\n    function _splitURL(url) {\n        // [1] = protocol://,\n        // [2] = host:port,\n        // [3] = host,\n        // [4] = IPv6_host,\n        // [5] = IPv4_host,\n        // [6] = :port,\n        // [7] = port,\n        // [8] = uri,\n        // [9] = rest (query / fragment)\n        return /(^https?:\\/\\/)?(((\\[[^\\]]+\\])|([^:\\/\\?#]+))(:(\\d+))?)?([^\\?#]*)(.*)?/.exec(url);\n    }\n\n    /**\n     * Returns whether the given hostAndPort is cross domain.\n     * The default implementation checks against window.location.host\n     * but this function can be overridden to make it work in non-browser\n     * environments.\n     *\n     * @param hostAndPort the host and port in format host:port\n     * @return whether the given hostAndPort is cross domain\n     */\n    this._isCrossDomain = function(hostAndPort) {\n        return hostAndPort && hostAndPort !== window.location.host;\n    };\n\n    function _configure(configuration) {\n        _cometd._debug('Configuring cometd object with', configuration);\n        // Support old style param, where only the Bayeux server URL was passed\n        if (_isString(configuration)) {\n            configuration = { url: configuration };\n        }\n        if (!configuration) {\n            configuration = {};\n        }\n\n        _config = _cometd._mixin(false, _config, configuration);\n\n        var url = _cometd.getURL();\n        if (!url) {\n            throw 'Missing required configuration parameter \\'url\\' specifying the Bayeux server URL';\n        }\n\n        // Check if we're cross domain.\n        var urlParts = _splitURL(url);\n        var hostAndPort = urlParts[2];\n        var uri = urlParts[8];\n        var afterURI = urlParts[9];\n        _crossDomain = _cometd._isCrossDomain(hostAndPort);\n\n        // Check if appending extra path is supported\n        if (_config.appendMessageTypeToURL) {\n            if (afterURI !== undefined && afterURI.length > 0) {\n                _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                _config.appendMessageTypeToURL = false;\n            } else {\n                var uriSegments = uri.split('/');\n                var lastSegmentIndex = uriSegments.length - 1;\n                if (uri.match(/\\/$/)) {\n                    lastSegmentIndex -= 1;\n                }\n                if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {\n                    // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd\n                    // It will be difficult to add the extra path in this case\n                    _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \\'appendMessageTypeToURL\\' configuration');\n                    _config.appendMessageTypeToURL = false;\n                }\n            }\n        }\n    }\n\n    function _removeListener(subscription) {\n        if (subscription) {\n            var subscriptions = _listeners[subscription.channel];\n            if (subscriptions && subscriptions[subscription.id]) {\n                delete subscriptions[subscription.id];\n                _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);\n            }\n        }\n    }\n\n    function _removeSubscription(subscription) {\n        if (subscription && !subscription.listener) {\n            _removeListener(subscription);\n        }\n    }\n\n    function _clearSubscriptions() {\n        for (var channel in _listeners) {\n            if (_listeners.hasOwnProperty(channel)) {\n                var subscriptions = _listeners[channel];\n                if (subscriptions) {\n                    for (var i = 0; i < subscriptions.length; ++i) {\n                        _removeSubscription(subscriptions[i]);\n                    }\n                }\n            }\n        }\n    }\n\n    function _setStatus(newStatus) {\n        if (_status !== newStatus) {\n            _cometd._debug('Status', _status, '->', newStatus);\n            _status = newStatus;\n        }\n    }\n\n    function _isDisconnected() {\n        return _status === 'disconnecting' || _status === 'disconnected';\n    }\n\n    function _nextMessageId() {\n        var result = ++_messageId;\n        return '' + result;\n    }\n\n    function _applyExtension(scope, callback, name, message, outgoing) {\n        try {\n            return callback.call(scope, message);\n        } catch (x) {\n            var handler = _cometd.onExtensionException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking extension exception handler', name, x);\n                try {\n                    handler.call(_cometd, x, name, outgoing, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of extension exception handler', name, xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of extension', name, x);\n            }\n            return message;\n        }\n    }\n\n    function _applyIncomingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;\n            var extension = _extensions[index];\n            var callback = extension.extension.incoming;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, false);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _applyOutgoingExtensions(message) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            if (message === undefined || message === null) {\n                break;\n            }\n\n            var extension = _extensions[i];\n            var callback = extension.extension.outgoing;\n            if (_isFunction(callback)) {\n                var result = _applyExtension(extension.extension, callback, extension.name, message, true);\n                message = result === undefined ? message : result;\n            }\n        }\n        return message;\n    }\n\n    function _notify(channel, message) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions && subscriptions.length > 0) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                var subscription = subscriptions[i];\n                // Subscriptions may come and go, so the array may have 'holes'\n                if (subscription) {\n                    try {\n                        subscription.callback.call(subscription.scope, message);\n                    } catch (x) {\n                        var handler = _cometd.onListenerException;\n                        if (_isFunction(handler)) {\n                            _cometd._debug('Invoking listener exception handler', subscription, x);\n                            try {\n                                handler.call(_cometd, x, subscription, subscription.listener, message);\n                            } catch (xx) {\n                                _cometd._info('Exception during execution of listener exception handler', subscription, xx);\n                            }\n                        } else {\n                            _cometd._info('Exception during execution of listener', subscription, message, x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _notifyListeners(channel, message) {\n        // Notify direct listeners\n        _notify(channel, message);\n\n        // Notify the globbing listeners\n        var channelParts = channel.split('/');\n        var last = channelParts.length - 1;\n        for (var i = last; i > 0; --i) {\n            var channelPart = channelParts.slice(0, i).join('/') + '/*';\n            // We don't want to notify /foo/* if the channel is /foo/bar/baz,\n            // so we stop at the first non recursive globbing\n            if (i === last) {\n                _notify(channelPart, message);\n            }\n            // Add the recursive globber and notify\n            channelPart += '*';\n            _notify(channelPart, message);\n        }\n    }\n\n    function _cancelDelayedSend() {\n        if (_scheduledSend !== null) {\n            Utils.clearTimeout(_scheduledSend);\n        }\n        _scheduledSend = null;\n    }\n\n    function _delayedSend(operation, delay) {\n        _cancelDelayedSend();\n        var time = _advice.interval + delay;\n        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);\n        _scheduledSend = Utils.setTimeout(_cometd, operation, time);\n    }\n\n    // Needed to break cyclic dependencies between function definitions\n    var _handleMessages;\n    var _handleFailure;\n\n    /**\n     * Delivers the messages to the CometD server\n     * @param sync whether the send is synchronous\n     * @param messages the array of messages to send\n     * @param metaConnect true if this send is on /meta/connect\n     * @param extraPath an extra path to append to the Bayeux server URL\n     */\n    function _send(sync, messages, metaConnect, extraPath) {\n        // We must be sure that the messages have a clientId.\n        // This is not guaranteed since the handshake may take time to return\n        // (and hence the clientId is not known yet) and the application\n        // may create other messages.\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var messageId = message.id;\n\n            if (_clientId) {\n                message.clientId = _clientId;\n            }\n\n            message = _applyOutgoingExtensions(message);\n            if (message !== undefined && message !== null) {\n                // Extensions may have modified the message id, but we need to own it.\n                message.id = messageId;\n                messages[i] = message;\n            } else {\n                delete _callbacks[messageId];\n                messages.splice(i--, 1);\n            }\n        }\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        var url = _cometd.getURL();\n        if (_config.appendMessageTypeToURL) {\n            // If url does not end with '/', then append it\n            if (!url.match(/\\/$/)) {\n                url = url + '/';\n            }\n            if (extraPath) {\n                url = url + extraPath;\n            }\n        }\n\n        var envelope = {\n            url: url,\n            sync: sync,\n            messages: messages,\n            onSuccess: function(rcvdMessages) {\n                try {\n                    _handleMessages.call(_cometd, rcvdMessages);\n                } catch (x) {\n                    _cometd._info('Exception during handling of messages', x);\n                }\n            },\n            onFailure: function(conduit, messages, failure) {\n                try {\n                    var transport = _cometd.getTransport();\n                    failure.connectionType = transport ? transport.getType() : \"unknown\";\n                    _handleFailure.call(_cometd, conduit, messages, failure);\n                } catch (x) {\n                    _cometd._info('Exception during handling of failure', x);\n                }\n            }\n        };\n        _cometd._debug('Send', envelope);\n        _transport.send(envelope, metaConnect);\n    }\n\n    function _queueSend(message) {\n        if (_batch > 0 || _internalBatch === true) {\n            _messageQueue.push(message);\n        } else {\n            _send(false, [message], false);\n        }\n    }\n\n    /**\n     * Sends a complete bayeux message.\n     * This method is exposed as a public so that extensions may use it\n     * to send bayeux message directly, for example in case of re-sending\n     * messages that have already been sent but that for some reason must\n     * be resent.\n     */\n    this.send = _queueSend;\n\n    function _resetBackoff() {\n        _backoff = 0;\n    }\n\n    function _increaseBackoff() {\n        if (_backoff < _config.maxBackoff) {\n            _backoff += _config.backoffIncrement;\n        }\n        return _backoff;\n    }\n\n    /**\n     * Starts a the batch of messages to be sent in a single request.\n     * @see #_endBatch(sendMessages)\n     */\n    function _startBatch() {\n        ++_batch;\n        _cometd._debug('Starting batch, depth', _batch);\n    }\n\n    function _flushBatch() {\n        var messages = _messageQueue;\n        _messageQueue = [];\n        if (messages.length > 0) {\n            _send(false, messages, false);\n        }\n    }\n\n    /**\n     * Ends the batch of messages to be sent in a single request,\n     * optionally sending messages present in the message queue depending\n     * on the given argument.\n     * @see #_startBatch()\n     */\n    function _endBatch() {\n        --_batch;\n        _cometd._debug('Ending batch, depth', _batch);\n        if (_batch < 0) {\n            throw 'Calls to startBatch() and endBatch() are not paired';\n        }\n\n        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n            _flushBatch();\n        }\n    }\n\n    /**\n     * Sends the connect message\n     */\n    function _connect() {\n        if (!_isDisconnected()) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/connect',\n                connectionType: _transport.getType()\n            };\n\n            // In case of reload or temporary loss of connection\n            // we want the next successful connect to return immediately\n            // instead of being held by the server, so that connect listeners\n            // can be notified that the connection has been re-established\n            if (!_connected) {\n                bayeuxMessage.advice = { timeout: 0 };\n            }\n\n            _setStatus('connecting');\n            _cometd._debug('Connect sent', bayeuxMessage);\n            _send(false, [bayeuxMessage], true, 'connect');\n            _setStatus('connected');\n        }\n    }\n\n    function _delayedConnect(delay) {\n        _setStatus('connecting');\n        _delayedSend(function() {\n            _connect();\n        }, delay);\n    }\n\n    function _updateAdvice(newAdvice) {\n        if (newAdvice) {\n            _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);\n            _cometd._debug('New advice', _advice);\n        }\n    }\n\n    function _disconnect(abort) {\n        _cancelDelayedSend();\n        if (abort && _transport) {\n            _transport.abort();\n        }\n        _clientId = null;\n        _setStatus('disconnected');\n        _batch = 0;\n        _resetBackoff();\n        _transport = null;\n\n        // Fail any existing queued message\n        if (_messageQueue.length > 0) {\n            var messages = _messageQueue;\n            _messageQueue = [];\n            _handleFailure.call(_cometd, undefined, messages, {\n                reason: 'Disconnected'\n            });\n        }\n    }\n\n    function _notifyTransportFailure(oldTransport, newTransport, failure) {\n        var handler = _cometd.onTransportException;\n        if (_isFunction(handler)) {\n            _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);\n            try {\n                handler.call(_cometd, failure, oldTransport, newTransport);\n            } catch (x) {\n                _cometd._info('Exception during execution of transport exception handler', x);\n            }\n        }\n    }\n\n    /**\n     * Sends the initial handshake message\n     */\n    function _handshake(handshakeProps, handshakeCallback) {\n        if (_isFunction(handshakeProps)) {\n            handshakeCallback = handshakeProps;\n            handshakeProps = undefined;\n        }\n\n        _clientId = null;\n\n        _clearSubscriptions();\n\n        // Reset the transports if we're not retrying the handshake\n        if (_isDisconnected()) {\n            _transports.reset(true);\n            _updateAdvice(_config.advice);\n        } else {\n            // We are retrying the handshake, either because another handshake failed\n            // and we're backing off, or because the server timed us out and asks us to\n            // re-handshake: in both cases, make sure that if the handshake succeeds\n            // the next action is a connect.\n            _updateAdvice(_cometd._mixin(false, _advice, {reconnect: 'retry'}));\n        }\n\n        _batch = 0;\n\n        // Mark the start of an internal batch.\n        // This is needed because handshake and connect are async.\n        // It may happen that the application calls init() then subscribe()\n        // and the subscribe message is sent before the connect message, if\n        // the subscribe message is not held until the connect message is sent.\n        // So here we start a batch to hold temporarily any message until\n        // the connection is fully established.\n        _internalBatch = true;\n\n        // Save the properties provided by the user, so that\n        // we can reuse them during automatic re-handshake\n        _handshakeProps = handshakeProps;\n        _handshakeCallback = handshakeCallback;\n\n        var version = '1.0';\n\n        // Figure out the transports to send to the server\n        var url = _cometd.getURL();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            version: version,\n            minimumVersion: version,\n            channel: '/meta/handshake',\n            supportedConnectionTypes: transportTypes,\n            advice: {\n                timeout: _advice.timeout,\n                interval: _advice.interval\n            }\n        };\n        // Do not allow the user to override important fields.\n        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, handshakeCallback);\n\n        // Pick up the first available transport as initial transport\n        // since we don't know if the server supports it\n        if (!_transport) {\n            _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n            if (!_transport) {\n                var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();\n                _cometd._warn(failure);\n                throw failure;\n            }\n        }\n\n        _cometd._debug('Initial transport is', _transport.getType());\n\n        // We started a batch to hold the application messages,\n        // so here we must bypass it and send immediately.\n        _setStatus('handshaking');\n        _cometd._debug('Handshake sent', message);\n        _send(false, [message], false, 'handshake');\n    }\n\n    function _delayedHandshake(delay) {\n        _setStatus('handshaking');\n\n        // We will call _handshake() which will reset _clientId, but we want to avoid\n        // that between the end of this method and the call to _handshake() someone may\n        // call publish() (or other methods that call _queueSend()).\n        _internalBatch = true;\n\n        _delayedSend(function() {\n            _handshake(_handshakeProps, _handshakeCallback);\n        }, delay);\n    }\n\n    function _notifyCallback(callback, message) {\n        try {\n            callback.call(_cometd, message);\n        } catch (x) {\n            var handler = _cometd.onCallbackException;\n            if (_isFunction(handler)) {\n                _cometd._debug('Invoking callback exception handler', x);\n                try {\n                    handler.call(_cometd, x, message);\n                } catch (xx) {\n                    _cometd._info('Exception during execution of callback exception handler', xx);\n                }\n            } else {\n                _cometd._info('Exception during execution of message callback', x);\n            }\n        }\n    }\n\n    this._getCallback = function(messageId) {\n        return _callbacks[messageId];\n    };\n\n    this._putCallback = function(messageId, callback) {\n        var result = this._getCallback(messageId);\n        if (_isFunction(callback)) {\n            _callbacks[messageId] = callback;\n        }\n        return result;\n    };\n\n    function _handleCallback(message) {\n        var callback = _cometd._getCallback([message.id]);\n        if (_isFunction(callback)) {\n            delete _callbacks[message.id];\n            _notifyCallback(callback, message);\n        }\n    }\n\n    function _handleRemoteCall(message) {\n        var context = _remoteCalls[message.id];\n        delete _remoteCalls[message.id];\n        _cometd._debug('Handling remote call response for', message, 'with context', context);\n        if (context) {\n            // Clear the timeout, if present.\n            var timeout = context.timeout;\n            if (timeout) {\n                Utils.clearTimeout(timeout);\n            }\n\n            var callback = context.callback;\n            if (_isFunction(callback)) {\n                _notifyCallback(callback, message);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _failHandshake(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/handshake', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // Only try again if we haven't been disconnected and\n        // the advice permits us to retry the handshake\n        var retry = !_isDisconnected() && _advice.reconnect !== 'none';\n        if (retry) {\n            _increaseBackoff();\n            _delayedHandshake();\n        } else {\n            _disconnect(true);\n        }\n    }\n\n    function _handshakeResponse(message) {\n        if (message.successful) {\n            // Save clientId, figure out transport, then follow the advice to connect\n            _clientId = message.clientId;\n\n            var url = _cometd.getURL();\n            var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);\n            if (newTransport === null) {\n                var failure = 'Could not negotiate transport with server; client=[' +\n                    _transports.findTransportTypes(message.version, _crossDomain, url) +\n                    '], server=[' + message.supportedConnectionTypes + ']';\n                var oldTransport = _cometd.getTransport();\n                _notifyTransportFailure(oldTransport.getType(), null, {\n                    reason: failure,\n                    connectionType: oldTransport.getType(),\n                    transport: oldTransport\n                });\n                _cometd._warn(failure);\n                _disconnect(true);\n                return;\n            } else if (_transport !== newTransport) {\n                _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());\n                _transport = newTransport;\n            }\n\n            // End the internal batch and allow held messages from the application\n            // to go to the server (see _handshake() where we start the internal batch).\n            _internalBatch = false;\n            _flushBatch();\n\n            // Here the new transport is in place, as well as the clientId, so\n            // the listeners can perform a publish() if they want.\n            // Notify the listeners before the connect below.\n            message.reestablish = _reestablish;\n            _reestablish = true;\n\n            _handleCallback(message);\n            _notifyListeners('/meta/handshake', message);\n\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    _disconnect(true);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failHandshake(message);\n        }\n    }\n\n    function _handshakeFailure(message) {\n        var version = '1.0';\n        var url = _cometd.getURL();\n        var oldTransport = _cometd.getTransport();\n        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);\n        var newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);\n        if (!newTransport) {\n            _notifyTransportFailure(oldTransport.getType(), null, message.failure);\n            _cometd._warn('Could not negotiate transport; client=[' + transportTypes + ']');\n            _disconnect(true);\n            _failHandshake(message);\n        } else {\n            _cometd._debug('Transport', oldTransport.getType(), '->', newTransport.getType());\n            _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure);\n            _failHandshake(message);\n            _transport = newTransport;\n        }\n    }\n\n    function _failConnect(message) {\n        // Notify the listeners after the status change but before the next action\n        _notifyListeners('/meta/connect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n\n        // This may happen when the server crashed, the current clientId\n        // will be invalid, and the server will ask to handshake again\n        // Listeners can call disconnect(), so check the state after they run\n        var action = _isDisconnected() ? 'none' : _advice.reconnect;\n        switch (action) {\n            case 'retry':\n                _delayedConnect();\n                _increaseBackoff();\n                break;\n            case 'handshake':\n                // The current transport may be failed (e.g. network disconnection)\n                // Reset the transports so the new handshake picks up the right one\n                _transports.reset(true);\n                _resetBackoff();\n                _delayedHandshake();\n                break;\n            case 'none':\n                _disconnect(true);\n                break;\n            default:\n                throw 'Unrecognized advice action' + action;\n        }\n    }\n\n    function _connectResponse(message) {\n        _connected = message.successful;\n\n        if (_connected) {\n            _notifyListeners('/meta/connect', message);\n\n            // Normally, the advice will say \"reconnect: 'retry', interval: 0\"\n            // and the server will hold the request, so when a response returns\n            // we immediately call the server again (long polling)\n            // Listeners can call disconnect(), so check the state after they run\n            var action = _isDisconnected() ? 'none' : _advice.reconnect;\n            switch (action) {\n                case 'retry':\n                    _resetBackoff();\n                    _delayedConnect();\n                    break;\n                case 'none':\n                    // Wait for the /meta/disconnect to arrive.\n                    _disconnect(false);\n                    break;\n                default:\n                    throw 'Unrecognized advice action ' + action;\n            }\n        } else {\n            _failConnect(message);\n        }\n    }\n\n    function _connectFailure(message) {\n        _connected = false;\n        _failConnect(message);\n    }\n\n    function _failDisconnect(message) {\n        _disconnect(true);\n        _handleCallback(message);\n        _notifyListeners('/meta/disconnect', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _disconnectResponse(message) {\n        if (message.successful) {\n            // Wait for the /meta/connect to arrive.\n            _disconnect(false);\n            _handleCallback(message);\n            _notifyListeners('/meta/disconnect', message);\n        } else {\n            _failDisconnect(message);\n        }\n    }\n\n    function _disconnectFailure(message) {\n        _failDisconnect(message);\n    }\n\n    function _failSubscribe(message) {\n        var subscriptions = _listeners[message.subscription];\n        if (subscriptions) {\n            for (var i = subscriptions.length - 1; i >= 0; --i) {\n                var subscription = subscriptions[i];\n                if (subscription && !subscription.listener) {\n                    delete subscriptions[i];\n                    _cometd._debug('Removed failed subscription', subscription);\n                    break;\n                }\n            }\n        }\n        _handleCallback(message);\n        _notifyListeners('/meta/subscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _subscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/subscribe', message);\n        } else {\n            _failSubscribe(message);\n        }\n    }\n\n    function _subscribeFailure(message) {\n        _failSubscribe(message);\n    }\n\n    function _failUnsubscribe(message) {\n        _handleCallback(message);\n        _notifyListeners('/meta/unsubscribe', message);\n        _notifyListeners('/meta/unsuccessful', message);\n    }\n\n    function _unsubscribeResponse(message) {\n        if (message.successful) {\n            _handleCallback(message);\n            _notifyListeners('/meta/unsubscribe', message);\n        } else {\n            _failUnsubscribe(message);\n        }\n    }\n\n    function _unsubscribeFailure(message) {\n        _failUnsubscribe(message);\n    }\n\n    function _failMessage(message) {\n        if (!_handleRemoteCall(message)) {\n            _handleCallback(message);\n            _notifyListeners('/meta/publish', message);\n            _notifyListeners('/meta/unsuccessful', message);\n        }\n    }\n\n    function _messageResponse(message) {\n        if (message.data !== undefined) {\n            if (!_handleRemoteCall(message)) {\n                _notifyListeners(message.channel, message);\n                if (_handshakeMessages > 0) {\n                    --_handshakeMessages;\n                    if (_handshakeMessages === 0) {\n                        _cometd._debug('Processed last handshake-delivered message');\n                        _delayedConnect(0);\n                    }\n                }\n            }\n        } else {\n            if (message.successful === undefined) {\n                _cometd._warn('Unknown Bayeux Message', message);\n            } else {\n                if (message.successful) {\n                    _handleCallback(message);\n                    _notifyListeners('/meta/publish', message);\n                } else {\n                    _failMessage(message);\n                }\n            }\n        }\n    }\n\n    function _messageFailure(failure) {\n        _failMessage(failure);\n    }\n\n    function _receive(message) {\n        _unconnectTime = 0;\n\n        message = _applyIncomingExtensions(message);\n        if (message === undefined || message === null) {\n            return;\n        }\n\n        _updateAdvice(message.advice);\n\n        var channel = message.channel;\n        switch (channel) {\n            case '/meta/handshake':\n                _handshakeResponse(message);\n                break;\n            case '/meta/connect':\n                _connectResponse(message);\n                break;\n            case '/meta/disconnect':\n                _disconnectResponse(message);\n                break;\n            case '/meta/subscribe':\n                _subscribeResponse(message);\n                break;\n            case '/meta/unsubscribe':\n                _unsubscribeResponse(message);\n                break;\n            default:\n                _messageResponse(message);\n                break;\n        }\n    }\n\n    /**\n     * Receives a message.\n     * This method is exposed as a public so that extensions may inject\n     * messages simulating that they had been received.\n     */\n    this.receive = _receive;\n\n    _handleMessages = function(rcvdMessages) {\n        _cometd._debug('Received', rcvdMessages);\n\n        for (var i = 0; i < rcvdMessages.length; ++i) {\n            var message = rcvdMessages[i];\n            _receive(message);\n        }\n    };\n\n    _handleFailure = function(conduit, messages, failure) {\n        _cometd._debug('handleFailure', conduit, messages, failure);\n\n        failure.transport = conduit;\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n            var failureMessage = {\n                id: message.id,\n                successful: false,\n                channel: message.channel,\n                failure: failure\n            };\n            failure.message = message;\n            switch (message.channel) {\n                case '/meta/handshake':\n                    _handshakeFailure(failureMessage);\n                    break;\n                case '/meta/connect':\n                    _connectFailure(failureMessage);\n                    break;\n                case '/meta/disconnect':\n                    _disconnectFailure(failureMessage);\n                    break;\n                case '/meta/subscribe':\n                    failureMessage.subscription = message.subscription;\n                    _subscribeFailure(failureMessage);\n                    break;\n                case '/meta/unsubscribe':\n                    failureMessage.subscription = message.subscription;\n                    _unsubscribeFailure(failureMessage);\n                    break;\n                default:\n                    _messageFailure(failureMessage);\n                    break;\n            }\n        }\n    };\n\n    function _hasSubscriptions(channel) {\n        var subscriptions = _listeners[channel];\n        if (subscriptions) {\n            for (var i = 0; i < subscriptions.length; ++i) {\n                if (subscriptions[i]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function _resolveScopedCallback(scope, callback) {\n        var delegate = {\n            scope: scope,\n            method: callback\n        };\n        if (_isFunction(scope)) {\n            delegate.scope = undefined;\n            delegate.method = scope;\n        } else {\n            if (_isString(callback)) {\n                if (!scope) {\n                    throw 'Invalid scope ' + scope;\n                }\n                delegate.method = scope[callback];\n                if (!_isFunction(delegate.method)) {\n                    throw 'Invalid callback ' + callback + ' for scope ' + scope;\n                }\n            } else if (!_isFunction(callback)) {\n                throw 'Invalid callback ' + callback;\n            }\n        }\n        return delegate;\n    }\n\n    function _addListener(channel, scope, callback, isListener) {\n        // The data structure is a map<channel, subscription[]>, where each subscription\n        // holds the callback to be called and its scope.\n\n        var delegate = _resolveScopedCallback(scope, callback);\n        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);\n\n        var subscription = {\n            channel: channel,\n            scope: delegate.scope,\n            callback: delegate.method,\n            listener: isListener\n        };\n\n        var subscriptions = _listeners[channel];\n        if (!subscriptions) {\n            subscriptions = [];\n            _listeners[channel] = subscriptions;\n        }\n\n        // Pushing onto an array appends at the end and returns the id associated with the element increased by 1.\n        // Note that if:\n        // a.push('a'); var hb=a.push('b'); delete a[hb-1]; var hc=a.push('c');\n        // then:\n        // hc==3, a.join()=='a',,'c', a.length==3\n        subscription.id = subscriptions.push(subscription) - 1;\n\n        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);\n\n        // For backward compatibility: we used to return [channel, subscription.id]\n        subscription[0] = channel;\n        subscription[1] = subscription.id;\n\n        return subscription;\n    }\n\n    //\n    // PUBLIC API\n    //\n\n    /**\n     * Registers the given transport under the given transport type.\n     * The optional index parameter specifies the \"priority\" at which the\n     * transport is registered (where 0 is the max priority).\n     * If a transport with the same type is already registered, this function\n     * does nothing and returns false.\n     * @param type the transport type\n     * @param transport the transport object\n     * @param index the index at which this transport is to be registered\n     * @return true if the transport has been registered, false otherwise\n     * @see #unregisterTransport(type)\n     */\n    this.registerTransport = function(type, transport, index) {\n        var result = _transports.add(type, transport, index);\n        if (result) {\n            this._debug('Registered transport', type);\n\n            if (_isFunction(transport.registered)) {\n                transport.registered(type, this);\n            }\n        }\n        return result;\n    };\n\n    /**\n     * Unregisters the transport with the given transport type.\n     * @param type the transport type to unregister\n     * @return the transport that has been unregistered,\n     * or null if no transport was previously registered under the given transport type\n     */\n    this.unregisterTransport = function(type) {\n        var transport = _transports.remove(type);\n        if (transport !== null) {\n            this._debug('Unregistered transport', type);\n\n            if (_isFunction(transport.unregistered)) {\n                transport.unregistered();\n            }\n        }\n        return transport;\n    };\n\n    this.unregisterTransports = function() {\n        _transports.clear();\n    };\n\n    /**\n     * @return an array of all registered transport types\n     */\n    this.getTransportTypes = function() {\n        return _transports.getTransportTypes();\n    };\n\n    this.findTransport = function(name) {\n        return _transports.find(name);\n    };\n\n    /**\n     * @returns the TransportRegistry object\n     */\n    this.getTransportRegistry = function() {\n        return _transports;\n    };\n\n    /**\n     * Configures the initial Bayeux communication with the Bayeux server.\n     * Configuration is passed via an object that must contain a mandatory field <code>url</code>\n     * of type string containing the URL of the Bayeux server.\n     * @param configuration the configuration object\n     */\n    this.configure = function(configuration) {\n        _configure.call(this, configuration);\n    };\n\n    /**\n     * Configures and establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param configuration the configuration object\n     * @param handshakeProps an object to be merged with the handshake message\n     * @see #configure(configuration)\n     * @see #handshake(handshakeProps)\n     */\n    this.init = function(configuration, handshakeProps) {\n        this.configure(configuration);\n        this.handshake(handshakeProps);\n    };\n\n    /**\n     * Establishes the Bayeux communication with the Bayeux server\n     * via a handshake and a subsequent connect.\n     * @param handshakeProps an object to be merged with the handshake message\n     * @param handshakeCallback a function to be invoked when the handshake is acknowledged\n     */\n    this.handshake = function(handshakeProps, handshakeCallback) {\n        _setStatus('disconnected');\n        _reestablish = false;\n        _handshake(handshakeProps, handshakeCallback);\n    };\n\n    /**\n     * Disconnects from the Bayeux server.\n     * It is possible to suggest to attempt a synchronous disconnect, but this feature\n     * may only be available in certain transports (for example, long-polling may support\n     * it, callback-polling certainly does not).\n     * @param sync whether attempt to perform a synchronous disconnect\n     * @param disconnectProps an object to be merged with the disconnect message\n     * @param disconnectCallback a function to be invoked when the disconnect is acknowledged\n     */\n    this.disconnect = function(sync, disconnectProps, disconnectCallback) {\n        if (_isDisconnected()) {\n            return;\n        }\n\n        if (typeof sync !== 'boolean') {\n            disconnectCallback = disconnectProps;\n            disconnectProps = sync;\n            sync = false;\n        }\n        if (_isFunction(disconnectProps)) {\n            disconnectCallback = disconnectProps;\n            disconnectProps = undefined;\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: '/meta/disconnect'\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, disconnectCallback);\n\n        _setStatus('disconnecting');\n        _send(sync === true, [message], false, 'disconnect');\n    };\n\n    /**\n     * Marks the start of a batch of application messages to be sent to the server\n     * in a single request, obtaining a single response containing (possibly) many\n     * application reply messages.\n     * Messages are held in a queue and not sent until {@link #endBatch()} is called.\n     * If startBatch() is called multiple times, then an equal number of endBatch()\n     * calls must be made to close and send the batch of messages.\n     * @see #endBatch()\n     */\n    this.startBatch = function() {\n        _startBatch();\n    };\n\n    /**\n     * Marks the end of a batch of application messages to be sent to the server\n     * in a single request.\n     * @see #startBatch()\n     */\n    this.endBatch = function() {\n        _endBatch();\n    };\n\n    /**\n     * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}\n     * and {@link #endBatch()} calls.\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls\n     */\n    this.batch = function(scope, callback) {\n        var delegate = _resolveScopedCallback(scope, callback);\n        this.startBatch();\n        try {\n            delegate.method.call(delegate.scope);\n            this.endBatch();\n        } catch (x) {\n            this._info('Exception during execution of batch', x);\n            this.endBatch();\n            throw x;\n        }\n    };\n\n    /**\n     * Adds a listener for bayeux messages, performing the given callback in the given scope\n     * when a message for the given channel arrives.\n     * @param channel the channel the listener is interested to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @returns the subscription handle to be passed to {@link #removeListener(object)}\n     * @see #removeListener(subscription)\n     */\n    this.addListener = function(channel, scope, callback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n\n        return _addListener(channel, scope, callback, true);\n    };\n\n    /**\n     * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @see #addListener(channel, scope, callback)\n     */\n    this.removeListener = function(subscription) {\n        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id\n        if (!subscription || !subscription.channel || !(\"id\" in subscription)) {\n            throw 'Invalid argument: expected subscription, not ' + subscription;\n        }\n\n        _removeListener(subscription);\n    };\n\n    /**\n     * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or\n     * {@link #subscribe(channel, scope, callback)}.\n     */\n    this.clearListeners = function() {\n        _listeners = {};\n    };\n\n    /**\n     * Subscribes to the given channel, performing the given callback in the given scope\n     * when a message for the channel arrives.\n     * @param channel the channel to subscribe to\n     * @param scope the scope of the callback, may be omitted\n     * @param callback the callback to call when a message is sent to the channel\n     * @param subscribeProps an object to be merged with the subscribe message\n     * @param subscribeCallback a function to be invoked when the subscription is acknowledged\n     * @return the subscription handle to be passed to {@link #unsubscribe(object)}\n     */\n    this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        // Normalize arguments\n        if (_isFunction(scope)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = callback;\n            callback = scope;\n            scope = undefined;\n        }\n        if (_isFunction(subscribeProps)) {\n            subscribeCallback = subscribeProps;\n            subscribeProps = undefined;\n        }\n\n        // Only send the message to the server if this client has not yet subscribed to the channel\n        var send = !_hasSubscriptions(channel);\n\n        var subscription = _addListener(channel, scope, callback, false);\n\n        if (send) {\n            // Send the subscription message after the subscription registration to avoid\n            // races where the server would send a message to the subscribers, but here\n            // on the client the subscription has not been added yet to the data structures\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/subscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, subscribeCallback);\n\n            _queueSend(message);\n        }\n\n        return subscription;\n    };\n\n    /**\n     * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.\n     * @param subscription the subscription to unsubscribe.\n     * @param unsubscribeProps an object to be merged with the unsubscribe message\n     * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged\n     */\n    this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(unsubscribeProps)) {\n            unsubscribeCallback = unsubscribeProps;\n            unsubscribeProps = undefined;\n        }\n\n        // Remove the local listener before sending the message\n        // This ensures that if the server fails, this client does not get notifications\n        this.removeListener(subscription);\n\n        var channel = subscription.channel;\n        // Only send the message to the server if this client unsubscribes the last subscription\n        if (!_hasSubscriptions(channel)) {\n            var bayeuxMessage = {\n                id: _nextMessageId(),\n                channel: '/meta/unsubscribe',\n                subscription: channel\n            };\n            // Do not allow the user to override important fields.\n            var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);\n\n            // Save the callback.\n            _cometd._putCallback(message.id, unsubscribeCallback);\n\n            _queueSend(message);\n        }\n    };\n\n    this.resubscribe = function(subscription, subscribeProps) {\n        _removeSubscription(subscription);\n        if (subscription) {\n            return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);\n        }\n        return undefined;\n    };\n\n    /**\n     * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},\n     * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.\n     */\n    this.clearSubscriptions = function() {\n        _clearSubscriptions();\n    };\n\n    /**\n     * Publishes a message on the given channel, containing the given content.\n     * @param channel the channel to publish the message to\n     * @param content the content of the message\n     * @param publishProps an object to be merged with the publish message\n     * @param publishCallback a function to be invoked when the publish is acknowledged by the server\n     */\n    this.publish = function(channel, content, publishProps, publishCallback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(channel)) {\n            throw 'Illegal argument type: channel must be a string';\n        }\n        if (/^\\/meta\\//.test(channel)) {\n            throw 'Illegal argument: cannot publish to meta channels';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            publishCallback = content;\n            content = publishProps = {};\n        } else if (_isFunction(publishProps)) {\n            publishCallback = publishProps;\n            publishProps = {};\n        }\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n        // Do not allow the user to override important fields.\n        var message = this._mixin(false, {}, publishProps, bayeuxMessage);\n\n        // Save the callback.\n        _cometd._putCallback(message.id, publishCallback);\n\n        _queueSend(message);\n    };\n\n    this.remoteCall = function(target, content, timeout, callback) {\n        if (arguments.length < 1) {\n            throw 'Illegal arguments number: required 1, got ' + arguments.length;\n        }\n        if (!_isString(target)) {\n            throw 'Illegal argument type: target must be a string';\n        }\n        if (_isDisconnected()) {\n            throw 'Illegal state: already disconnected';\n        }\n\n        if (_isFunction(content)) {\n            callback = content;\n            content = {};\n            timeout = _config.maxNetworkDelay;\n        } else if (_isFunction(timeout)) {\n            callback = timeout;\n            timeout = _config.maxNetworkDelay;\n        }\n\n        if (typeof timeout !== 'number') {\n            throw 'Illegal argument type: timeout must be a number';\n        }\n\n        if (!target.match(/^\\//)) {\n            target = '/' + target;\n        }\n        var channel = '/service' + target;\n\n        var bayeuxMessage = {\n            id: _nextMessageId(),\n            channel: channel,\n            data: content\n        };\n\n        var context = {\n            callback: callback\n        };\n        if (timeout > 0) {\n            context.timeout = Utils.setTimeout(_cometd, function() {\n                _cometd._debug('Timing out remote call', bayeuxMessage, 'after', timeout, 'ms');\n                _failMessage({\n                    id: bayeuxMessage.id,\n                    error: '406::timeout',\n                    successful: false,\n                    failure: {\n                        message : bayeuxMessage,\n                        reason: 'Remote Call Timeout'\n                    }\n                });\n            }, timeout);\n            _cometd._debug('Scheduled remote call timeout', bayeuxMessage, 'in', timeout, 'ms');\n        }\n        _remoteCalls[bayeuxMessage.id] = context;\n\n        _queueSend(bayeuxMessage);\n    };\n\n    /**\n     * Returns a string representing the status of the bayeux communication with the Bayeux server.\n     */\n    this.getStatus = function() {\n        return _status;\n    };\n\n    /**\n     * Returns whether this instance has been disconnected.\n     */\n    this.isDisconnected = _isDisconnected;\n\n    /**\n     * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * Default value is 1 second, which means if there is a persistent failure the retries will happen\n     * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of\n     * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).\n     * @param period the backoff period to set\n     * @see #getBackoffIncrement()\n     */\n    this.setBackoffIncrement = function(period) {\n        _config.backoffIncrement = period;\n    };\n\n    /**\n     * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.\n     * @see #setBackoffIncrement(period)\n     */\n    this.getBackoffIncrement = function() {\n        return _config.backoffIncrement;\n    };\n\n    /**\n     * Returns the backoff period to wait before retrying an unsuccessful or failed message.\n     */\n    this.getBackoffPeriod = function() {\n        return _backoff;\n    };\n\n    /**\n     * Increases the backoff period up to the maximum value configured.\n     * @returns the backoff period after increment\n     * @see getBackoffIncrement\n     */\n    this.increaseBackoffPeriod = function() {\n        return _increaseBackoff();\n    };\n\n    /**\n     * Resets the backoff period to zero.\n     */\n    this.resetBackoffPeriod = function() {\n        _resetBackoff();\n    };\n\n    /**\n     * Sets the log level for console logging.\n     * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n     * less verbose to more verbose.\n     * @param level the log level string\n     */\n    this.setLogLevel = function(level) {\n        _config.logLevel = level;\n    };\n\n    /**\n     * Registers an extension whose callbacks are called for every incoming message\n     * (that comes from the server to this client implementation) and for every\n     * outgoing message (that originates from this client implementation for the\n     * server).\n     * The format of the extension object is the following:\n     * <pre>\n     * {\n     *     incoming: function(message) { ... },\n     *     outgoing: function(message) { ... }\n     * }\n     * </pre>\n     * Both properties are optional, but if they are present they will be called\n     * respectively for each incoming message and for each outgoing message.\n     * @param name the name of the extension\n     * @param extension the extension to register\n     * @return true if the extension was registered, false otherwise\n     * @see #unregisterExtension(name)\n     */\n    this.registerExtension = function(name, extension) {\n        if (arguments.length < 2) {\n            throw 'Illegal arguments number: required 2, got ' + arguments.length;\n        }\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var existing = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var existingExtension = _extensions[i];\n            if (existingExtension.name === name) {\n                existing = true;\n                break;\n            }\n        }\n        if (!existing) {\n            _extensions.push({\n                name: name,\n                extension: extension\n            });\n            this._debug('Registered extension', name);\n\n            // Callback for extensions\n            if (_isFunction(extension.registered)) {\n                extension.registered(name, this);\n            }\n\n            return true;\n        } else {\n            this._info('Could not register extension with name', name, 'since another extension with the same name already exists');\n            return false;\n        }\n    };\n\n    /**\n     * Unregister an extension previously registered with\n     * {@link #registerExtension(name, extension)}.\n     * @param name the name of the extension to unregister.\n     * @return true if the extension was unregistered, false otherwise\n     */\n    this.unregisterExtension = function(name) {\n        if (!_isString(name)) {\n            throw 'Illegal argument type: extension name must be a string';\n        }\n\n        var unregistered = false;\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                _extensions.splice(i, 1);\n                unregistered = true;\n                this._debug('Unregistered extension', name);\n\n                // Callback for extensions\n                var ext = extension.extension;\n                if (_isFunction(ext.unregistered)) {\n                    ext.unregistered();\n                }\n\n                break;\n            }\n        }\n        return unregistered;\n    };\n\n    /**\n     * Find the extension registered with the given name.\n     * @param name the name of the extension to find\n     * @return the extension found or null if no extension with the given name has been registered\n     */\n    this.getExtension = function(name) {\n        for (var i = 0; i < _extensions.length; ++i) {\n            var extension = _extensions[i];\n            if (extension.name === name) {\n                return extension.extension;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Returns the name assigned to this CometD object, or the string 'default'\n     * if no name has been explicitly passed as parameter to the constructor.\n     */\n    this.getName = function() {\n        return _name;\n    };\n\n    /**\n     * Returns the clientId assigned by the Bayeux server during handshake.\n     */\n    this.getClientId = function() {\n        return _clientId;\n    };\n\n    /**\n     * Returns the URL of the Bayeux server.\n     */\n    this.getURL = function() {\n        if (_transport) {\n            var url = _transport.getURL();\n            if (url) {\n                return url;\n            }\n            url = _config.urls[_transport.getType()];\n            if (url) {\n                return url;\n            }\n        }\n        return _config.url;\n    };\n\n    this.getTransport = function() {\n        return _transport;\n    };\n\n    this.getConfiguration = function() {\n        return this._mixin(true, {}, _config);\n    };\n\n    this.getAdvice = function() {\n        return this._mixin(true, {}, _advice);\n    };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/CometD.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * A registry for transports used by the CometD object.\n */\nmodule.exports = function TransportRegistry() {\n    var _types = [];\n    var _transports = {};\n\n    this.getTransportTypes = function() {\n        return _types.slice(0);\n    };\n\n    this.findTransportTypes = function(version, crossDomain, url) {\n        var result = [];\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            if (_transports[type].accept(version, crossDomain, url) === true) {\n                result.push(type);\n            }\n        }\n        return result;\n    };\n\n    this.negotiateTransport = function(types, version, crossDomain, url) {\n        for (var i = 0; i < _types.length; ++i) {\n            var type = _types[i];\n            for (var j = 0; j < types.length; ++j) {\n                if (type === types[j]) {\n                    var transport = _transports[type];\n                    if (transport.accept(version, crossDomain, url) === true) {\n                        return transport;\n                    }\n                }\n            }\n        }\n        return null;\n    };\n\n    this.add = function(type, transport, index) {\n        var existing = false;\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                existing = true;\n                break;\n            }\n        }\n\n        if (!existing) {\n            if (typeof index !== 'number') {\n                _types.push(type);\n            } else {\n                _types.splice(index, 0, type);\n            }\n            _transports[type] = transport;\n        }\n\n        return !existing;\n    };\n\n    this.find = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                return _transports[type];\n            }\n        }\n        return null;\n    };\n\n    this.remove = function(type) {\n        for (var i = 0; i < _types.length; ++i) {\n            if (_types[i] === type) {\n                _types.splice(i, 1);\n                var transport = _transports[type];\n                delete _transports[type];\n                return transport;\n            }\n        }\n        return null;\n    };\n\n    this.clear = function() {\n        _types = [];\n        _transports = {};\n    };\n\n    this.reset = function(init) {\n        for (var i = 0; i < _types.length; ++i) {\n            _transports[_types[i]].reset(init);\n        }\n    };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/TransportRegistry.js\n ** module id = 13\n ** module chunks = 0\n **/","var Transport = require('./Transport');\nvar RequestTransport = require('./RequestTransport');\n\nmodule.exports = function LongPollingTransport() {\n    var _super = new RequestTransport();\n    var _self = Transport.derive(_super);\n    // By default, support cross domain\n    var _supportsCrossDomain = true;\n\n    _self.accept = function(version, crossDomain, url) {\n        return _supportsCrossDomain || !crossDomain;\n    };\n\n    _self.xhrSend = function(packet) {\n        throw 'Abstract';\n    };\n\n    _self.transportSend = function(envelope, request) {\n        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);\n\n        var self = this;\n        try {\n            var sameStack = true;\n            request.xhr = this.xhrSend({\n                transport: this,\n                url: envelope.url,\n                sync: envelope.sync,\n                headers: this.getConfiguration().requestHeaders,\n                body: JSON.stringify(envelope.messages),\n                onSuccess: function(response) {\n                    self._debug('Transport', self.getType(), 'received response', response);\n                    var success = false;\n                    try {\n                        var received = self.convertToMessages(response);\n                        if (received.length === 0) {\n                            _supportsCrossDomain = false;\n                            self.transportFailure(envelope, request, {\n                                httpCode: 204\n                            });\n                        } else {\n                            success = true;\n                            self.transportSuccess(envelope, request, received);\n                        }\n                    } catch (x) {\n                        self._debug(x);\n                        if (!success) {\n                            _supportsCrossDomain = false;\n                            var failure = {\n                                exception: x\n                            };\n                            failure.httpCode = self.xhrStatus(request.xhr);\n                            self.transportFailure(envelope, request, failure);\n                        }\n                    }\n                },\n                onError: function(reason, exception) {\n                    self._debug('Transport', self.getType(), 'received error', reason, exception);\n                    _supportsCrossDomain = false;\n                    var failure = {\n                        reason: reason,\n                        exception: exception\n                    };\n                    failure.httpCode = self.xhrStatus(request.xhr);\n                    if (sameStack) {\n                        // Keep the semantic of calling response callbacks asynchronously after the request\n                        self.setTimeout(function() {\n                            self.transportFailure(envelope, request, failure);\n                        }, 0);\n                    } else {\n                        self.transportFailure(envelope, request, failure);\n                    }\n                }\n            });\n            sameStack = false;\n        } catch (x) {\n            _supportsCrossDomain = false;\n            // Keep the semantic of calling response callbacks asynchronously after the request\n            self.setTimeout(function() {\n                self.transportFailure(envelope, request, {\n                    exception: x\n                });\n            }, 0);\n        }\n    };\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _supportsCrossDomain = true;\n    };\n\n    return _self;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/LongPollingTransport.js\n ** module id = 14\n ** module chunks = 0\n **/","var Transport = require('./Transport')\nvar Utils = require('./Utils')\n\nmodule.exports = function WebSocketTransport() {\n    var _super = new Transport();\n    var _self = Transport.derive(_super);\n    var _cometd;\n    // By default WebSocket is supported\n    var _webSocketSupported = true;\n    // Whether we were able to establish a WebSocket connection\n    var _webSocketConnected = false;\n    var _stickyReconnect = true;\n    // The context contains the envelopes that have been sent\n    // and the timeouts for the messages that have been sent.\n    var _context = null;\n    var _connecting = null;\n    var _connected = false;\n    var _successCallback = null;\n\n    _self.reset = function(init) {\n        _super.reset(init);\n        _webSocketSupported = true;\n        if (init) {\n            _webSocketConnected = false;\n        }\n        _stickyReconnect = true;\n        _context = null;\n        _connecting = null;\n        _connected = false;\n    };\n\n    function _forceClose(context, event) {\n        if (context) {\n            this.webSocketClose(context, event.code, event.reason);\n            // Force immediate failure of pending messages to trigger reconnect.\n            // This is needed because the server may not reply to our close()\n            // and therefore the onclose function is never called.\n            this.onClose(context, event);\n        }\n    }\n\n    function _sameContext(context) {\n        return context === _connecting || context === _context;\n    }\n\n    function _storeEnvelope(context, envelope, metaConnect) {\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            var message = envelope.messages[i];\n            if (message.id) {\n                messageIds.push(message.id);\n            }\n        }\n        context.envelopes[messageIds.join(',')] = [envelope, metaConnect];\n        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);\n    }\n\n    function _websocketConnect(context) {\n        // We may have multiple attempts to open a WebSocket\n        // connection, for example a /meta/connect request that\n        // may take time, along with a user-triggered publish.\n        // Early return if we are already connecting.\n        if (_connecting) {\n            return;\n        }\n\n        // Mangle the URL, changing the scheme from 'http' to 'ws'.\n        var url = _cometd.getURL().replace(/^http/, 'ws');\n        this._debug('Transport', this.getType(), 'connecting to URL', url);\n\n        try {\n            var protocol = _cometd.getConfiguration().protocol;\n            context.webSocket = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n            _connecting = context;\n        } catch (x) {\n            _webSocketSupported = false;\n            this._debug('Exception while creating WebSocket object', x);\n            throw x;\n        }\n\n        // By default use sticky reconnects.\n        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;\n\n        var self = this;\n        var connectTimeout = _cometd.getConfiguration().connectTimeout;\n        if (connectTimeout > 0) {\n            context.connectTimer = self.setTimeout(function() {\n                _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');\n                // The connection was not opened, close anyway.\n                _forceClose.call(self, context, {code: 1000, reason: 'Connect Timeout'});\n            }, connectTimeout);\n        }\n\n        var onopen = function() {\n            _cometd._debug('WebSocket onopen', context);\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            if (_sameContext(context)) {\n                _connecting = null;\n                _context = context;\n                _webSocketConnected = true;\n                self.onOpen(context);\n            } else {\n                // We have a valid connection already, close this one.\n                _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);\n                _forceClose.call(self, context, {code: 1000, reason: 'Extra Connection'});\n            }\n        };\n\n        // This callback is invoked when the server sends the close frame.\n        // The close frame for a connection may arrive *after* another\n        // connection has been opened, so we must make sure that actions\n        // are performed only if it's the same connection.\n        var onclose = function(event) {\n            event = event || {code: 1000};\n            _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);\n\n            if (context.connectTimer) {\n                self.clearTimeout(context.connectTimer);\n            }\n\n            self.onClose(context, event);\n        };\n\n        var onmessage = function(wsMessage) {\n            _cometd._debug('WebSocket onmessage', wsMessage, context);\n            self.onMessage(context, wsMessage);\n        };\n\n        context.webSocket.onopen = onopen;\n        context.webSocket.onclose = onclose;\n        context.webSocket.onerror = function() {\n            // Clients should call onclose(), but if they do not we do it here for safety.\n            onclose({code: 1000, reason: 'Error'});\n        };\n        context.webSocket.onmessage = onmessage;\n\n        this._debug('Transport', this.getType(), 'configured callbacks on', context);\n    }\n\n    function _webSocketSend(context, envelope, metaConnect) {\n        var json = JSON.stringify(envelope.messages);\n        context.webSocket.send(json);\n        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);\n\n        // Manage the timeout waiting for the response.\n        var maxDelay = this.getConfiguration().maxNetworkDelay;\n        var delay = maxDelay;\n        if (metaConnect) {\n            delay += this.getAdvice().timeout;\n            _connected = true;\n        }\n\n        var self = this;\n        var messageIds = [];\n        for (var i = 0; i < envelope.messages.length; ++i) {\n            (function() {\n                var message = envelope.messages[i];\n                if (message.id) {\n                    messageIds.push(message.id);\n                    context.timeouts[message.id] = self.setTimeout(function() {\n                        _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);\n                        _forceClose.call(self, context, {code: 1000, reason: 'Message Timeout'});\n                    }, delay);\n                }\n            })();\n        }\n\n        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);\n    }\n\n    _self._notifySuccess = function(fn, messages) {\n        fn.call(this, messages);\n    };\n\n    _self._notifyFailure = function(fn, context, messages, failure) {\n        fn.call(this, context, messages, failure);\n    };\n\n    function _send(context, envelope, metaConnect) {\n        try {\n            if (context === null) {\n                context = _connecting || {\n                        envelopes: {},\n                        timeouts: {}\n                    };\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _websocketConnect.call(this, context);\n            } else {\n                _storeEnvelope.call(this, context, envelope, metaConnect);\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        } catch (x) {\n            // Keep the semantic of calling response callbacks asynchronously after the request.\n            var self = this;\n            self.setTimeout(function() {\n                _forceClose.call(self, context, {\n                    code: 1000,\n                    reason: 'Exception',\n                    exception: x\n                });\n            }, 0);\n        }\n    }\n\n    _self.onOpen = function(context) {\n        var envelopes = context.envelopes;\n        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var element = envelopes[key];\n                var envelope = element[0];\n                var metaConnect = element[1];\n                // Store the success callback, which is independent from the envelope,\n                // so that it can be used to notify arrival of messages.\n                _successCallback = envelope.onSuccess;\n                _webSocketSend.call(this, context, envelope, metaConnect);\n            }\n        }\n    };\n\n    _self.onMessage = function(context, wsMessage) {\n        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);\n\n        var close = false;\n        var messages = this.convertToMessages(wsMessage.data);\n        var messageIds = [];\n        for (var i = 0; i < messages.length; ++i) {\n            var message = messages[i];\n\n            // Detect if the message is a response to a request we made.\n            // If it's a meta message, for sure it's a response; otherwise it's\n            // a publish message and publish responses don't have the data field.\n            if (/^\\/meta\\//.test(message.channel) || message.data === undefined) {\n                if (message.id) {\n                    messageIds.push(message.id);\n\n                    var timeout = context.timeouts[message.id];\n                    if (timeout) {\n                        this.clearTimeout(timeout);\n                        delete context.timeouts[message.id];\n                        this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);\n                    }\n                }\n            }\n\n            if ('/meta/connect' === message.channel) {\n                _connected = false;\n            }\n            if ('/meta/disconnect' === message.channel && !_connected) {\n                close = true;\n            }\n        }\n\n        // Remove the envelope corresponding to the messages.\n        var removed = false;\n        var envelopes = context.envelopes;\n        for (var j = 0; j < messageIds.length; ++j) {\n            var id = messageIds[j];\n            for (var key in envelopes) {\n                if (envelopes.hasOwnProperty(key)) {\n                    var ids = key.split(',');\n                    var index = Utils.inArray(id, ids);\n                    if (index >= 0) {\n                        removed = true;\n                        ids.splice(index, 1);\n                        var envelope = envelopes[key][0];\n                        var metaConnect = envelopes[key][1];\n                        delete envelopes[key];\n                        if (ids.length > 0) {\n                            envelopes[ids.join(',')] = [envelope, metaConnect];\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (removed) {\n            this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);\n        }\n\n        this._notifySuccess(_successCallback, messages);\n\n        if (close) {\n            this.webSocketClose(context, 1000, 'Disconnect');\n        }\n    };\n\n    _self.onClose = function(context, event) {\n        this._debug('Transport', this.getType(), 'closed', context, event);\n\n        if (_sameContext(context)) {\n            // Remember if we were able to connect.\n            // This close event could be due to server shutdown,\n            // and if it restarts we want to try websocket again.\n            _webSocketSupported = _stickyReconnect && _webSocketConnected;\n            _connecting = null;\n            _context = null;\n        }\n\n        var timeouts = context.timeouts;\n        context.timeouts = {};\n        for (var id in timeouts) {\n            if (timeouts.hasOwnProperty(id)) {\n                this.clearTimeout(timeouts[id]);\n            }\n        }\n\n        var envelopes = context.envelopes;\n        context.envelopes = {};\n        for (var key in envelopes) {\n            if (envelopes.hasOwnProperty(key)) {\n                var envelope = envelopes[key][0];\n                var metaConnect = envelopes[key][1];\n                if (metaConnect) {\n                    _connected = false;\n                }\n                var failure = {\n                    websocketCode: event.code,\n                    reason: event.reason\n                };\n                if (event.exception) {\n                    failure.exception = event.exception;\n                }\n                this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);\n            }\n        }\n    };\n\n    _self.registered = function(type, cometd) {\n        _super.registered(type, cometd);\n        _cometd = cometd;\n    };\n\n    _self.accept = function(version, crossDomain, url) {\n        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);\n        // Using !! to return a boolean (and not the WebSocket object).\n        return _webSocketSupported && !('undefined' === typeof WebSocket) && _cometd.websocketEnabled !== false;\n    };\n\n    _self.send = function(envelope, metaConnect) {\n        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);\n        _send.call(this, _context, envelope, metaConnect);\n    };\n\n    _self.webSocketClose = function(context, code, reason) {\n        try {\n            if (context.webSocket) {\n                context.webSocket.close(code, reason);\n            }\n        } catch (x) {\n            this._debug(x);\n        }\n    };\n\n    _self.abort = function() {\n        _super.abort();\n        _forceClose.call(this, _context, {code: 1000, reason: 'Abort'});\n        this.reset(true);\n    };\n\n    return _self;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zetapush-cometd/lib/WebSocketTransport.js\n ** module id = 15\n ** module chunks = 0\n **/","import { API_URL, isHttpsProtocol } from './utils/index'\nimport { ClientHelper } from './client-helper'\nimport { ConnectionStatusListener } from './connection/connection-status'\n\n/**\n * Client config object.\n * @typedef {Object} ClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {function():AbstractHandshake} credentials - Return credentials properties\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * ZetaPush Client to connect\n * @access public\n * @example\n * // Securized client with token based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   credentials() {\n *     return ZetaPush.Authentication.weak({\n *       token: null\n  *    })\n *   }\n * })\n * @example\n * // Client with credentials based connection\n * const client = new ZetaPush.Client({\n *   sandboxId: '<YOUR-SANDBOX-ID>',\n *   credentials() {\n *     return ZetaPush.Authentication.simple({\n *       login: '<USER-LOGIN>',\n *       password: '<USER-PASSWORD>'\n  *    })\n *   }\n * })\n */\nexport class Client {\n  /**\n   * @param {ClientConfig} config\n   * Create a new ZetaPush client\n   */\n  constructor({ apiUrl = API_URL, sandboxId, forceHttps = isHttpsProtocol(), credentials, resource, transports }) {\n    /**\n     * @access private\n     * @type {ClientHelper}\n     */\n    this.helper = new ClientHelper({\n      apiUrl,\n      sandboxId,\n      forceHttps,\n      credentials,\n      resource,\n      transports\n    })\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return {boolean}\n   */\n  isConnected() {\n    return this.helper.isConnected()\n  }\n  /**\n   * Connect client to ZetaPush\n   */\n  connect() {\n    this.helper.connect()\n  }\n  /**\n   * Disonnect client from ZetaPush\n   */\n  disconnect() {\n    this.helper.disconnect()\n  }\n  /**\n   * Get the client sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.helper.getSandboxId()\n  }\n  /**\n   * Get the client resource\n   * @return {string}\n   */\n  getResource() {\n    return this.helper.getResource()\n  }\n  /**\n   * Get the client user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.helper.getUserId()\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} service\n   */\n  unsubscribe(service) {\n    if (!service.$subscriptions) {\n      throw new TypeError('Missing $subscriptions property in service')\n    }\n    return this.helper.unsubscribe(service.$subscriptions)\n  }\n  /**\n   * Create a publish/subscribe for a service type\n   * @param {{type: class, deploymentId: string, listener: Object}} parameters\n   * @return {Object} service\n   */\n  createService({ type, listener, deploymentId = type.DEFAULT_DEPLOYMENT_ID }) {\n    return this.helper.createService({ deploymentId, listener, type })\n  }\n  /**\n   * Set new client resource value\n   * @param {string} resource\n   */\n  setResource(resource) {\n    this.helper.setResource(resource)\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    return this.helper.addConnectionStatusListener(listener)\n  }\n  /**\n   * Remove a connection status listener\n   * @param {number} handler\n   */\n  removeConnectionStatusListener(handler) {\n    return this.helper.removeConnectionStatusListener(handler)\n  }\n  /**\n   * Set logging level\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.helper.setLogLevel(level)\n  }\n}\n\n/**\n * Add shorthand connection status method\n */\nObject.getOwnPropertyNames(ConnectionStatusListener.prototype).forEach((method) => {\n  // Only implements unsupported methods\n  if (!Client.prototype.hasOwnProperty(method)) {\n    Client.prototype[method] = function addListener(listener) {\n      return this.addConnectionStatusListener({\n        [method]: listener\n      })\n    }\n  }\n})\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/client.js\n **/","/**\n * Match unsecure pattern web\n * @type {RegExp}\n */\nconst UNSECURE_PATTERN = /^http:\\/\\/|^\\/\\//\n\n/**\n* Default ZetaPush API URL\n* @access private\n*/\nexport const API_URL = 'https://api.zpush.io/'\n\n/**\n * @access private\n * @param {Array<Object>} list\n * @return {Object}\n */\nexport const shuffle = (list) => {\n  const index = Math.floor(Math.random() * list.length)\n  return list[index]\n}\n\n/**\n * @access private\n * @param {string} url\n * @param {boolean} forceHttps\n * @return {string}\n */\nexport const getSecureUrl = (url, forceHttps) => {\n  return forceHttps ? url.replace(UNSECURE_PATTERN, 'https://') : url\n}\n\n/**\n * @access private\n * @param {{apiUrl: string, sandboxId: string, forceHttps: boolean}} parameters\n * @return {Promise}\n */\nexport const getServers = ({ apiUrl, sandboxId, forceHttps }) => {\n  const secureApiUrl = getSecureUrl(apiUrl, forceHttps)\n  const url = `${secureApiUrl}${sandboxId}`\n  return fetch(url)\n    .then((response) => {\n      return response.json()\n    })\n    .then(({ servers }) => {\n      // TODO: Replace by a server side implementation when available\n      return servers.map((server) => {\n        return getSecureUrl(server, forceHttps)\n      })\n    })\n}\n\n/**\n * @access private\n * @return {boolean}\n */\nexport const isHttpsProtocol = () => {\n  return 'https:' === location.protocol\n}\n\n/**\n * @access  private\n * @return {boolean}\n */\nexport const isPrototypeOf = (derived, parent) => {\n  let prototype = Object.getPrototypeOf(derived)\n  let is = false\n  while (!(is || prototype === null)) {\n    is = prototype === parent\n    prototype = Object.getPrototypeOf(prototype)\n  }\n  return is\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/utils/index.js\n **/","import { CometD } from 'zetapush-cometd'\nimport { TransportTypes, TransportLayers } from './connection/cometd'\nimport { ConnectionStatusListener } from './connection/connection-status'\nimport { Macro } from './services'\nimport { getServers, shuffle, isPrototypeOf } from './utils/index'\n\n/**\n * CometD Messages enumeration\n */\nconst Message = {\n  RECONNECT_HANDSHAKE_VALUE: 'handshake',\n  RECONNECT_NONE_VALUE: 'none',\n  RECONNECT_RETRY_VALUE: 'retry'\n}\n\n/**\n * Get all transport types\n */\nconst AllTransports = Object.values(TransportTypes)\n\n/**\n * Provide utilities and abstraction on CometD Transport layer\n * @access private\n */\nexport class ClientHelper {\n  /**\n   * Create a new ZetaPush client helper\n   */\n  constructor({ apiUrl, sandboxId, forceHttps = false, credentials, resource = null, transports = AllTransports }) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.sandboxId = sandboxId\n    /**\n     * @access private\n     * @type {function():AbstractHandshake}\n     */\n    this.credentials = credentials\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.resource = resource\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.userId = null\n    /**\n     * @access private\n     * @type {Promise}\n     */\n    this.servers = getServers({ apiUrl, sandboxId, forceHttps })\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.connectionListeners = []\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.connected = false\n    /**\n     * @access private\n     * @type {boolean}\n     */\n    this.wasConnected = false\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.serverUrl = null\n    /**\n     * @access private\n     * @type {Array<Object>}\n     */\n    this.subscribeQueue = []\n    /**\n     * @access private\n     * @type {CometD}\n     */\n    this.cometd = new CometD()\n\n    // Filter transports layers\n    TransportLayers.filter(({ type }) => {\n      return transports.includes(type)\n    }).forEach(({ type, Transport }) => {\n      this.cometd.registerTransport(type, new Transport())\n    })\n\n    // Handle transport exception\n    this.cometd.onTransportException = (cometd, transport) => {\n      if (TransportTypes.LONG_POLLING === transport) {\n        // Try to find an other available server\n        // Remove the current one from the _serverList array\n        this.updateServerUrl()\n      }\n    }\n\n    this.cometd.addListener('/meta/handshake', ({ ext, successful, advice, error }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      if (successful) {\n        const { authentication = null } = ext\n        this.initialized(authentication)\n      }\n      else {\n        this.handshakeFailure(error)\n      }\n    })\n\n    this.cometd.addListener('/meta/handshake', ({ advice, error, ext, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/handshake', { ext, successful, advice, error })\n      // AuthNegotiation\n      if (!successful) {\n        if ('undefined' === typeof advice) {\n          return\n        }\n        if (Message.RECONNECT_NONE_VALUE === advice.reconnect) {\n          this.authenticationFailed(error)\n        }\n        else if (Message.RECONNECT_HANDSHAKE_VALUE === advice.reconnect) {\n          this.negotiate(ext)\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/connect', ({ advice, channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/connect', { advice, channel, successful })\n      // ConnectionListener\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection will close\n        this.connectionWillClose()\n      }\n      else {\n        this.wasConnected = this.connected\n        this.connected = successful\n        if (!this.wasConnected && this.connected) {\n          this.cometd.batch(this, () => {\n            // Unqueue subscriptions\n            this.subscribeQueue.forEach(({ prefix, listener, subscriptions }) => {\n              this.subscribe(prefix, listener, subscriptions)\n            })\n          })\n          // Notify connection is established\n          this.connectionEstablished()\n        }\n        else if (this.wasConnected && !this.connected) {\n          // Notify connection is broken\n          this.connectionBroken()\n        }\n      }\n    })\n\n    this.cometd.addListener('/meta/disconnect', ({ channel, successful }) => {\n      this.cometd._debug('ClientHelper::/meta/disconnect', { channel, successful })\n      if (this.cometd.isDisconnected()) {\n        this.connected = false\n        // Notify connection is closed\n        this.connectionClosed()\n      }\n    })\n  }\n  /**\n   * Is client connected to ZetaPush\n   * @return boolean\n   */\n  isConnected() {\n    return !this.cometd.isDisconnected()\n  }\n  /**\n   * Connect client using CometD Transport\n   */\n  connect() {\n    this.servers.then((servers) => {\n      this.serverUrl = shuffle(servers)\n\n      this.cometd.configure({\n        url: `${this.serverUrl}/strd`,\n        backoffIncrement: 1000,\n        maxBackoff: 60000,\n        appendMessageTypeToURL: false\n      })\n\n      this.cometd.handshake(this.getHandshakeFields())\n    })\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  connectionEstablished() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionEstablished()\n      })\n  }\n  /**\n   * Notify listeners when connection is broken\n   */\n  connectionBroken() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionBroken()\n      })\n  }\n  /**\n   * Notify listeners when a message is lost\n   */\n  messageLost(channel, data) {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onMessageLost(channel, data)\n      })\n  }\n  /**\n   * Notify listeners when connection will close\n   */\n  connectionWillClose() {\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionWillClose()\n      })\n  }\n  /**\n   * Notify listeners when connection is closed\n   */\n  connectionClosed() {\n    this.userId = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onConnectionClosed()\n      })\n  }\n  /**\n   * Notify listeners when connection is established\n   */\n  initialized(authentication) {\n    if (authentication) {\n      this.userId = authentication.userId\n    }\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onSuccessfulHandshake(authentication)\n      })\n  }\n  /**\n   * Notify listeners when handshake step succeed\n   */\n  authenticationFailed(error) {\n    this.userId = null\n    this.connectionListeners\n      .filter(({ enabled }) => enabled)\n      .forEach(({ listener }) => {\n        listener.onFailedHandshake(error)\n      })\n  }\n  /**\n   * Manage handshake failure case\n   */\n  handshakeFailure() {\n    this.userId = null\n  }\n  /**\n  * Remove current server url from the server list and shuffle for another one\n  */\n  updateServerUrl() {\n    this.servers.then((servers) => {\n      const index = servers.indexOf(this.serverUrl)\n      if (index > -1) {\n        servers.splice(index, 1)\n      }\n      if (servers.length === 0) {\n        // No more server available\n      }\n      else {\n        this.serverUrl = shuffle(servers)\n        this.cometd.configure({\n          url: `${this.serverUrl}/strd`\n        })\n        setTimeout(() => {\n          this.cometd.handshake(this.getHandshakeFields())\n        }, 250)\n      }\n    })\n  }\n  /**\n   * Negociate authentication\n   */\n  negotiate(ext) {\n    this.cometd._debug('ClientHelper::negotiate', ext)\n  }\n  /**\n   * Disconnect CometD client\n   */\n  disconnect() {\n    this.cometd.disconnect(true)\n  }\n  /**\n   * Get CometD handshake parameters\n   * @return {Object}\n   */\n  getHandshakeFields() {\n    const handshake = this.credentials()\n    return handshake.getHandshakeFields(this)\n  }\n  /**\n   * Set a new handshake factory methods\n   * @param {function():AbstractHandshake} credentials\n   */\n  setCredentials(credentials) {\n    this.credentials = credentials\n  }\n  /**\n   * Get sandbox id\n   * @return {string}\n   */\n  getSandboxId() {\n    return this.sandboxId\n  }\n  /**\n   * Get resource\n   * @return {string}\n   */\n  getResource() {\n    return this.resource\n  }\n  /**\n   * Get user id\n   * @return {string}\n   */\n  getUserId() {\n    return this.userId\n  }\n  /**\n   * Subsribe all methods defined in the listener for the given prefixed channel\n   * @param {string} prefix - Channel prefix\n   * @param {Object} listener\n   * @param {Object} subscriptions\n   * @return {Object} subscriptions\n   */\n  subscribe(prefix, listener, subscriptions = {}) {\n    const { queued } = this.getQueuedSubscription(subscriptions)\n    if (!queued) {\n      // Store arguments to renew subscriptions on connection\n      this.subscribeQueue.push({ prefix, listener, subscriptions })\n    }\n    // Subscribe if user is connected\n    if (!this.cometd.isDisconnected()) {\n      for (let method in listener) {\n        if (listener.hasOwnProperty(method)) {\n          const channel = `${prefix}/${method}`\n          subscriptions[method] = this.cometd.subscribe(channel, listener[method])\n        }\n      }\n    }\n    return subscriptions\n  }\n  /**\n   * Remove all subscriptions\n   * @param {Object} subscriptions\n   */\n  unsubscribe(subscriptions = {}) {\n    // Unsubscribe\n    for (let method in subscriptions) {\n      if (subscriptions.hasOwnProperty(method)) {\n        const subscription = subscriptions[method]\n        this.cometd.unsubscribe(subscription)\n      }\n    }\n    // Remove subscription from queue\n    const { index, queued } = this.getQueuedSubscription(subscriptions)\n    if (queued)  {\n      this.subscribeQueue.splice(index, 1)\n    }\n  }\n  /**\n   * Get queued subscription index\n   * @return {Object} index\n   */\n  getQueuedSubscription(subscriptions = {}) {\n    const index = this.subscribeQueue.findIndex((element) => subscriptions === element.subscriptions)\n    return {\n      index,\n      queued: -1 < index\n    }\n  }\n  /**\n   * Get a publisher for a macro service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getMacroPublisher(prefix) {\n    return (name, parameters, hardFail = true, debug = 1) => {\n      const channel = `${prefix}/call`\n      this.publish(channel, {\n        name,\n        parameters,\n        hardFail,\n        debug\n      })\n    }\n  }\n  /**\n   * Get a publisher for a service\n   * @param {string} prefix - Channel prefix\n   * @return {Function} publisher\n   */\n  getServicePublisher(prefix) {\n    return (method, parameters) => {\n      const channel = `${prefix}/${method}`\n      this.publish(channel, parameters)\n    }\n  }\n  /**\n   * @param {{deploymentId: string, listener: Object, type: class}} parameters\n   * @return {Object} service\n   */\n  createService({ deploymentId, listener, type }) {\n    const isMacroType = isPrototypeOf(type, Macro)\n    const prefix = `/service/${this.getSandboxId()}/${deploymentId}`\n    const $publish = isMacroType ? this.getMacroPublisher(prefix) : this.getServicePublisher(prefix)\n    const service = new type({ $publish })\n    // Store subscription in service instance\n    service.$subscriptions = this.subscribe(prefix, listener)\n    return service\n  }\n  /**\n   * Unsubcribe all subscriptions defined in given subscriptions object\n   * @param {Object} subscriptions\n   */\n  unsubscribe(subscriptions) {\n    for (let method in subscriptions) {\n      if (subscriptions.hasOwnProperty(method)) {\n        this.cometd.unsubscribe(subscriptions[method])\n      }\n    }\n  }\n  /**\n   * Add a connection listener to handle life cycle connection events\n   * @param {ConnectionStatusListener} listener\n   * @return {number} handler\n   */\n  addConnectionStatusListener(listener) {\n    this.connectionListeners.push({\n      enabled: true,\n      listener: Object.assign(new ConnectionStatusListener(), listener)\n    })\n    return this.connectionListeners.length - 1\n  }\n  /**\n   * Remove a connection status listener\n   */\n  removeConnectionStatusListener(handler) {\n    const listener = this.connectionListeners[handler]\n    if (listener) {\n      listener.enabled = false\n    }\n  }\n  /**\n   * Wrap CometdD publish method\n   * @param {String} channel\n   * @param {Object} parameters\n   */\n  publish(channel, parameters = {}) {\n    this.cometd.publish(channel, parameters)\n  }\n  /**\n   * Set logging level for CometD client\n   * Valid values are the strings 'error', 'warn', 'info' and 'debug', from\n   * less verbose to more verbose.\n   * @param {string} level\n   */\n  setLogLevel(level) {\n    this.cometd.setLogLevel(level)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/client-helper.js\n **/","import { Client } from './client'\nimport { Authentication } from './authentication/handshake'\nimport { LocalStorageTokenPersistenceStrategy } from './utils/token-persistence'\n\n/**\n * WeakClient config object.\n * @typedef {Object} WeakClientConfig\n * @property {string} apiUrl - Api Url\n * @property {string} deploymentId - Authentication deployment id\n * @property {string} sandboxId - Sandbox id\n * @property {boolean} forceHttps - Force end to end HTTPS connection\n * @property {string} resource - Client resource id\n * @property {Array} transports - Client transports list\n */\n\n/**\n * @access public\n * @extends {Client}\n * @example\n * // Create a new WeakClient\n * const client = new ZetaPush.WeakClient({\n *   sandboxId: '<YOUR-SANDBOX-ID>'\n * })\n */\nexport class WeakClient extends Client {\n  /**\n   * Create a new ZetaPush smart client\n   * @param {WeakClientConfig} config\n   */\n  constructor({ apiUrl, sandboxId, deploymentId, forceHttps, resource, transports }) {\n    const credentials = () => {\n      const token = this.getToken()\n      const handshake = Authentication.weak({\n        deploymentId,\n        token\n      })\n      return handshake\n    }\n    /**\n     * Call Client constructor with specific parameters\n     */\n    super({ apiUrl , sandboxId, forceHttps, credentials, resource, transports })\n    // Handle successful handshake\n    const onSuccessfulHandshake = ({ publicToken, userId, token }) => {\n      if (token) {\n        this.strategy.set({ token })\n      }\n    }\n    this.addConnectionStatusListener({ onSuccessfulHandshake })\n    /**\n     * @access private\n     * @type {TokenPersistenceStrategy}\n     */\n    this.strategy = new LocalStorageTokenPersistenceStrategy()\n  }\n  /**\n   * @return {string} The stored token\n   */\n  getToken() {\n    return this.strategy.get()\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/weak-client.js\n **/","/**\n * @type {string}\n */\nconst ZETAPUSH_TOKEN_KEY = 'zetapush.token'\n\n/**\n * Provide abstraction for token persistence\n * @access protected\n */\nexport class AbstractTokenPersistenceStrategy {\n  /**\n   * @param {{key: string}} parameters\n   */\n  constructor({ key = ZETAPUSH_TOKEN_KEY } = {}) {\n    /**\n     * @access private\n     * @type {string}\n     */\n    this.key = key\n  }\n  /**\n   * @abstract\n   * @return {string} The stored token\n   */\n  get() {}\n  /**\n   * @abstract\n   * @param {{token: string}} parameters\n   */\n  set({ token }) {}\n}\n\n/**\n * @access protected\n * @extends {AbstractTokenPersistenceStrategy}\n */\nexport class LocalStorageTokenPersistenceStrategy extends AbstractTokenPersistenceStrategy {\n  /**\n   * @override\n   * @return {string} The stored token\n   */\n  get() {\n    return localStorage.getItem(this.key)\n  }\n  /**\n   * @override\n   * @param {{token: string}} parameters\n   */\n  set({ token }) {\n    localStorage.setItem(this.key, token)\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/utils/token-persistence.js\n **/"],"sourceRoot":""}