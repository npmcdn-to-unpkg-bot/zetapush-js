<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/definitions/index.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/zetapush/zetapush-js" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/client.js~Client.html">Client</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/weak-client.js~WeakClient.html">WeakClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-VERSION">VERSION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ClientConfig">ClientConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-WeakClientConfig">WeakClientConfig</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">authentication</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/authentication/handshake.js~AbstractHandshakeManager.html">AbstractHandshakeManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/authentication/handshake.js~AuthentFactory.html">AuthentFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/authentication/handshake.js~CredentialsHandshakeManager.html">CredentialsHandshakeManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/authentication/handshake.js~TokenHandshakeManager.html">TokenHandshakeManager</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">connection</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/connection/connection-status.js~ConnectionStatusListener.html">ConnectionStatusListener</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">definitions</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~AggregPublisherDefinition.html">AggregPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~CronPublisherDefinition.html">CronPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~DelegatingPublisherDefinition.html">DelegatingPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~EchoPublisherDefinition.html">EchoPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~GameEnginePublisherDefinition.html">GameEnginePublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~GamePublisherDefinition.html">GamePublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~GdaPublisherDefinition.html">GdaPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~GroupManagementPublisherDefinition.html">GroupManagementPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~HttpclientPublisherDefinition.html">HttpclientPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~MacroPublisherDefinition.html">MacroPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~MessagingPublisherDefinition.html">MessagingPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~QueuePublisherDefinition.html">QueuePublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~RemotingPublisherDefinition.html">RemotingPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~SearchPublisherDefinition.html">SearchPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~SendmailPublisherDefinition.html">SendmailPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~SimplePublisherDefinition.html">SimplePublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~Sms_ovhPublisherDefinition.html">Sms_ovhPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~StackPublisherDefinition.html">StackPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~TemplatePublisherDefinition.html">TemplatePublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~UserdirPublisherDefinition.html">UserdirPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~WeakPublisherDefinition.html">WeakPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~Zpfs_hdfsPublisherDefinition.html">Zpfs_hdfsPublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~Zpfs_s3PublisherDefinition.html">Zpfs_s3PublisherDefinition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/definitions/index.js~Zpfs_s3compatPublisherDefinition.html">Zpfs_s3compatPublisherDefinition</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/definitions/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @access protected
 */
export class AbstractPublisherDefinition {
	constructor({ $publish }) {
		this.$publish = $publish
	}
}
/**
 * Data aggregation
 * 
 * Provides data aggregation over time and across different items
 *  User devices push items data on developer-defined categories
 *  This service automatically aggregates the data
 * Raw data is not available for reading, only the generated aggregation result
 * 
 * */
/**
 * User API for item aggregation
 * 
 * Users can push data and be notified of aggregated data.
 * This service does not allow you to read the data. To achieve that kind of behavior, you could configure a callback to store the data.
 * @access public
 * */
export class AggregPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Pushes some data
	 * 
	 * Pushes the given data.
	 * All the items are processed according to the defined rules.
	 * At least one push for a given item is needed during a time period to trigger processing and calling of the corresponding callback verb/macro.
	 * */
	push({items,owner}) { this.$publish(&apos;push&apos;, {items,owner})}
}
/**
 * Data stacks
 * 
 * Stacks are a per-user named persistent queue of data
 *  An administrator creates a stack service
 *  End-users can push data on an arbitrary number of their own arbitrary named stacks
 * */
/**
 * Data stack user API
 * 
 * Data is stored on a per user basis. However, notifications can be sent to a configurable set of listeners.
 * Stack names are arbitrary and do not need to be explicitly initialized.
 * @access public
 * */
export class StackPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Lists the listeners
	 * 
	 * Returns the whole list of listeners for the given stack.
	 * */
	getListeners({owner,stack}) { this.$publish(&apos;getListeners&apos;, {owner,stack})}
	/**
	 * Lists content
	 * 
	 * Returns a paginated list of contents for the given stack.
	 * Content is sorted according to the statically configured order.
	 * */
	list({owner,page,stack}) { this.$publish(&apos;list&apos;, {owner,page,stack})}
	/**
	 * Empties a stack
	 * 
	 * Removes all items from the given stack.
	 * */
	purge({owner,stack}) { this.$publish(&apos;purge&apos;, {owner,stack})}
	/**
	 * Pushes an item
	 * 
	 * Pushes an item onto the given stack.
	 * The stack does not need to be created.
	 * */
	push({stack,data,owner}) { this.$publish(&apos;push&apos;, {stack,data,owner})}
	/**
	 * Removes items
	 * 
	 * Removes the item with the given guid from the given stack.
	 * */
	remove({guids,owner,stack}) { this.$publish(&apos;remove&apos;, {guids,owner,stack})}
	/**
	 * Sets the listeners
	 * 
	 * Sets the listeners for the given stack.
	 * */
	setListeners({listeners,owner,stack}) { this.$publish(&apos;setListeners&apos;, {listeners,owner,stack})}
	/**
	 * Updates an item
	 * 
	 * Updates an existing item of the given stack.
	 * The item MUST exist prior to the call.
	 * */
	update({guid,stack,data,owner}) { this.$publish(&apos;update&apos;, {guid,stack,data,owner})}
}
/**
 * Echo
 * 
 * Echo
 * */
/**
 * Echo service
 * 
 * Simple echo service, for development purposes.
 * @access public
 * */
export class EchoPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Echoes an object
	 * 
	 * Echoes an object: the server will echo that object on channel &apos;echo&apos; for the current user.
	 * */
	echo({}) { this.$publish(&apos;echo&apos;, {})}
}
/**
 * Game engine
 * 
 * Abstract Game Engine
 *  Concrete game engines are remote cometd clients or internal macros
 * */
/**
 * Game Engine API
 * 
 * The Game Engine API is for game engine clients, not end-users.
 * @access public
 * */
export class GameEnginePublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Notify the result for a join request
	 * 
	 * A Game Engine notifies the STR of the result of a join request that it received on join_callback
	 * */
	join_result({callerId,error,msgId,payload}) { this.$publish(&apos;join_result&apos;, {callerId,error,msgId,payload})}
	/**
	 * Notify the result for an organization request
	 * 
	 * A Game Engine notifies the STR of the result of an organization request that it received on organize_callback
	 * */
	organize_result({callerId,error,msgId,payload}) { this.$publish(&apos;organize_result&apos;, {callerId,error,msgId,payload})}
	/**
	 * Registers a game engine
	 * 
	 * A client registers itself to the STR as a Game Engine.
	 * The STR may, from now on, dispatch game of the given game type to said client.
	 * Unregistration is done automatically on logoff.
	 * */
	register({gameInfo,location,maxGames}) { this.$publish(&apos;register&apos;, {gameInfo,location,maxGames})}
	/**
	 * Notify the result for a start request
	 * 
	 * A Game Engine notifies the STR of the result of a start request that it received on start_callback
	 * */
	start_result({gameId}) { this.$publish(&apos;start_result&apos;, {gameId})}
	/**
	 * Notify a game event
	 * 
	 * A Game Engine notifies the STR of some arbitrary game event.
	 * */
	state({data,gameId,status}) { this.$publish(&apos;state&apos;, {data,gameId,status})}
	/**
	 * Notify the result for an unjoin request
	 * 
	 * A Game Engine notifies the STR of the result of an unjoin request that it received on unjoin_callback
	 * */
	unjoin_result({callerId,error,msgId,payload}) { this.$publish(&apos;unjoin_result&apos;, {callerId,error,msgId,payload})}
}
/**
 * User API for games
 * 
 * Users can list, start, join games, and play.
 * @access public
 * */
export class GamePublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Lists game types
	 * 
	 * Returns the list of game types supported by the server and the currently registered game engines.
	 * */
	available({}) { this.$publish(&apos;available&apos;, {})}
	/**A user joins a game*/
	join({gameId,role,userId,userName}) { this.$publish(&apos;join&apos;, {gameId,role,userId,userName})}
	/**Organizes a game*/
	organize({type,owner,options}) { this.$publish(&apos;organize&apos;, {type,owner,options})}
	/**Gives some command to the game engine*/
	play({data,gameId,userId}) { this.$publish(&apos;play&apos;, {data,gameId,userId})}
	/**Starts a game*/
	start({gameId}) { this.$publish(&apos;start&apos;, {gameId})}
	/**A user cancels joining a game*/
	unjoin({gameId,role,userId,userName}) { this.$publish(&apos;unjoin&apos;, {gameId,role,userId,userName})}
}
/**
 * Generic Data Access
 * 
 * Generic Data Access Service : NoSQL storage
 * */
/**
 * GDA User API
 * 
 * User API for Generic Data Access.
 * Data is stored on a per-user basis.
 * Users can put, get, list their data.
 * @access public
 * */
export class GdaPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Asks for a data row
	 * 
	 * Returns a full data row.
	 * */
	get({key,owner,table}) { this.$publish(&apos;get&apos;, {key,owner,table})}
	/**
	 * Asks for a data cell
	 * 
	 * Returns a precise list of cells from a column in a data row.
	 * */
	getCells({column,key,key2,owner,table}) { this.$publish(&apos;getCells&apos;, {column,key,key2,owner,table})}
	/**
	 * Increments an integer value
	 * 
	 * Increments a cell 64-bit signed integer value and returns the result in the data field.
	 * The increment is atomic : if you concurrently increment 10 times a value by 1, the final result will be the initial value plus 10. The actual individual resulting values seen by the 10 concurrent callers may vary discontinuously, with duplicates : at least one of them will see the final (+10) result.
	 * */
	inc({table,data,key,key2,owner,column}) { this.$publish(&apos;inc&apos;, {table,data,key,key2,owner,column})}
	/**
	 * Asks for a list of rows
	 * 
	 * Returns a paginated list of rows from the given table.
	 * */
	list({columns,owner,page,table}) { this.$publish(&apos;list&apos;, {columns,owner,page,table})}
	/**
	 * Puts some data into a cell
	 * 
	 * Creates or replaces the contents of a particular cell.
	 * */
	put({column,data,key,key2,owner,table}) { this.$publish(&apos;put&apos;, {column,data,key,key2,owner,table})}
	/**
	 * Puts several rows
	 * 
	 * Creates or replaces the (maybe partial) contents of a collection of rows.
	 * This method only creates or replaces cells for non-null input values.
	 * */
	puts({owner,rows,table}) { this.$publish(&apos;puts&apos;, {owner,rows,table})}
	/**
	 * Asks for a range of rows
	 * 
	 * Returns a paginated range of rows from the given table.
	 * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).
	 * You can specify partial keys for the start and stop fields.
	 * */
	range({columns,owner,page,start,stop,table}) { this.$publish(&apos;range&apos;, {columns,owner,page,start,stop,table})}
	/**
	 * Reduces a range of rows
	 * 
	 * Returns a computed single reduced result from a range of rows from the given table.
	 * A range consists of consecutive rows from the start key (inclusive) to the stop key (exclusive).
	 * You can specify partial keys for the start and stop fields.
	 * */
	reduce({}) { this.$publish(&apos;reduce&apos;, {})}
	/**
	 * Removes one cell inside a column of a row
	 * 
	 * Removes only one cell of the given column of the given row from the given table.
	 * */
	removeCell({column,key,key2,owner,table}) { this.$publish(&apos;removeCell&apos;, {column,key,key2,owner,table})}
	/**
	 * Removes one full column of a row
	 * 
	 * Removes all cells of the given column of the given row from the given table.
	 * */
	removeColumn({column,key,owner,table}) { this.$publish(&apos;removeColumn&apos;, {column,key,owner,table})}
	/**
	 * Removes a range of rows
	 * 
	 * Removes the specified columns of the given range of rows from the given table.
	 * */
	removeRange({columns,owner,start,stop,table}) { this.$publish(&apos;removeRange&apos;, {columns,owner,start,stop,table})}
	/**
	 * Removes one full row
	 * 
	 * Removes all columns of the given row from the given table.
	 * */
	removeRow({key,owner,table}) { this.$publish(&apos;removeRow&apos;, {key,owner,table})}
}
/**
 * Groups Management
 * 
 * Groups management for users, grants on resources, remote commands on devices
 *  This is where you can configure rights for any resource
 * 
 * */
/**
 * User API for remote control
 * 
 * @access public
 * */
export class RemotingPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Adds a listener
	 * 
	 * A user requests notifications from a device owned by anyone who granted him the right authorizations.
	 * Whenever the device calls &apos;notify&apos;, notifications will be sent to the caller of this verb.
	 * */
	addListener({cmd,data,from,fromResource,owner,resource}) { this.$publish(&apos;addListener&apos;, {cmd,data,from,fromResource,owner,resource})}
	/**Response to &apos;getCapabilities&apos;*/
	capabilities({answeringResource,askingResource,capabilities}) { this.$publish(&apos;capabilities&apos;, {answeringResource,askingResource,capabilities})}
	/**
	 * Executes a command
	 * 
	 * A user executes a command on a device owned by anyone who granted him the right authorizations.
	 * The command is issued on channel &apos;command&apos;
	 * */
	execute({resource,cmd,data,owner}) { this.$publish(&apos;execute&apos;, {resource,cmd,data,owner})}
	/**
	 * Requests capabilities
	 * 
	 * A user requests all his devices for the whole list of their capabilities.
	 * Devices are expected to answer on channel &apos;capabilities&apos;
	 * */
	getCapabilities({}) { this.$publish(&apos;getCapabilities&apos;, {})}
	/**
	 * Notifies of some event
	 * 
	 * A device notifies the registered users/devices on this channel.
	 * The server forwards the notification to said users.
	 * */
	notify({cmd,data,from,fromResource,owner,resource}) { this.$publish(&apos;notify&apos;, {cmd,data,from,fromResource,owner,resource})}
	/**
	 * Pings devices
	 * 
	 * A user requests all devices (of all owners) on which he has authorizations to respond on channel &apos;pong&apos;
	 * */
	ping({action}) { this.$publish(&apos;ping&apos;, {action})}
	/**Response to ping*/
	pong({action,available,owner,resource,uid,user}) { this.$publish(&apos;pong&apos;, {action,available,owner,resource,uid,user})}
	/**
	 * Removes a listener
	 * 
	 * A user stops requesting notifications from a device owned by anyone who granted him the right authorizations
	 * */
	removeListener({cmd,data,from,fromResource,owner,resource}) { this.$publish(&apos;removeListener&apos;, {cmd,data,from,fromResource,owner,resource})}
}
/**
 * User API for groups and rights.
 * 
 * Groups are stored per user.
 * This means that two users can own a group with the same identifier. A couple (owner, group) is needed to uniquely identify a group inside a group management service.
 * The triplet (deploymentId, owner, group) is actually needed to fully qualify a group outside of the scope of this service.
 * @access public
 * */
export class GroupManagementPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Adds me to a group
	 * 
	 * Adds me (the caller) to a group.
	 * This verb exists so that group owners may grant the right to join their groups without granting the right to add other users to those groups.
	 * The &apos;user&apos; field is implicitly set to the current user&apos;s key.
	 * */
	addMe({group,owner}) { this.$publish(&apos;addMe&apos;, {group,owner})}
	/**
	 * Adds a user to a group
	 * 
	 * Adds the given user to the given group.
	 * Addition may fail if the given group does not already exist.
	 * */
	addUser({user,group,owner}) { this.$publish(&apos;addUser&apos;, {user,group,owner})}
	/**Adds users to a group*/
	addUsers({users,group,owner}) { this.$publish(&apos;addUsers&apos;, {users,group,owner})}
	/**
	 * Lists my owned groups, with details
	 * 
	 * Returns the whole list of groups owned by the current user, with their members
	 * */
	allGroups({owner}) { this.$publish(&apos;allGroups&apos;, {owner})}
	/**
	 * Creates a group
	 * 
	 * Creates a group owned by the current user.
	 * Group creation may fail if the group already exists.
	 * */
	createGroup({group,groupName,owner}) { this.$publish(&apos;createGroup&apos;, {group,groupName,owner})}
	/**
	 * Removes a group
	 * 
	 * Removes the given group owned by the current user or the given owner.
	 * Also removes all grants to that group.
	 * */
	delGroup({group,owner}) { this.$publish(&apos;delGroup&apos;, {group,owner})}
	/**Removes a user from a group*/
	delUser({group,owner,user}) { this.$publish(&apos;delUser&apos;, {group,owner,user})}
	/**Removes users from a group*/
	delUsers({group,groupName,owner,users}) { this.$publish(&apos;delUsers&apos;, {group,groupName,owner,users})}
	/**
	 * Tests for a group&apos;s existence
	 * 
	 * Returns whether a group exists or not.
	 * */
	exists({group,owner}) { this.$publish(&apos;exists&apos;, {group,owner})}
	/**
	 * Grants a right to a group
	 * 
	 * The granting API does not do any check when storing permissions.
	 * In particular when granting rights on a verb and resource of another API, the existence of said verb and resource is not checked.
	 * */
	grant({action,group,owner,resource}) { this.$publish(&apos;grant&apos;, {action,group,owner,resource})}
	/**
	 * Lists the group users
	 * 
	 * Returns the whole list of users configured inside the given group.
	 * */
	groupUsers({group,owner}) { this.$publish(&apos;groupUsers&apos;, {group,owner})}
	/**
	 * Lists my owned groups
	 * 
	 * Returns the whole list of groups owned by the current user
	 * */
	groups({owner}) { this.$publish(&apos;groups&apos;, {owner})}
	/**
	 * Lists rights for a group
	 * 
	 * This API lists explicitly configured rights.
	 * Effective rights include configured rights, implicit rights and inherited rights.
	 * */
	listGrants({group,owner}) { this.$publish(&apos;listGrants&apos;, {group,owner})}
	/**
	 * Lists presences for a group
	 * 
	 * Returns the list of members of the given groups, along with their actual and current presence on the zetapush server.
	 * The current implementation does not include information about the particular devices users are connected with.
	 * If a user is connected twice with two different devices, two identical entries will be returned.
	 * */
	listPresences({group,owner}) { this.$publish(&apos;listPresences&apos;, {group,owner})}
	/**
	 * Tests membership
	 * 
	 * Tests whether I (the caller) am a member of the given group.
	 * This verb exists so that users can determine if they are part of a group without being granted particular rights.
	 * The &apos;user&apos; field is implicitly set to the current user&apos;s key.
	 * */
	memberOf({hardFail,group,owner}) { this.$publish(&apos;memberOf&apos;, {hardFail,group,owner})}
	/**
	 * Grants rights to a group
	 * 
	 * Grant several rights at once.
	 * */
	mgrant({actions,group,owner,resource}) { this.$publish(&apos;mgrant&apos;, {actions,group,owner,resource})}
	/**Revokes rights for a group*/
	mrevoke({actions,group,owner,resource}) { this.$publish(&apos;mrevoke&apos;, {actions,group,owner,resource})}
	/**
	 * Lists the groups I am part of
	 * 
	 * Returns the whole list of groups the current user is part of.
	 * Groups may be owned by anyone, including the current user.
	 * */
	myGroups({owner}) { this.$publish(&apos;myGroups&apos;, {owner})}
	/**Revokes a right for a group*/
	revoke({action,group,owner,resource}) { this.$publish(&apos;revoke&apos;, {action,group,owner,resource})}
}
/**
 * HTTP client
 * 
 * Web-service client
 *  An admin records URL templates that can be called by users
 *  Calls are not configurable by end-users
 *  However an admin may leverage the macro service to achieve URL, headers and body configurability
 * */
/**
 * User API for http requests
 * 
 * @access public
 * */
export class HttpclientPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Makes a predefined request
	 * 
	 * Lookups a predefined request by name, and executes it.
	 * */
	call({name,requestId}) { this.$publish(&apos;call&apos;, {name,requestId})}
	/**
	 * Makes a parameterized request
	 * 
	 * Executes an HTTP request with the given url, method, headers and body.
	 * */
	request({}) { this.$publish(&apos;request&apos;, {})}
}
/**
 * Macros
 * 
 * Macro-command service
 *  An admin defines macro-commands that can sequentially call any number of other api verbs, loop on collections of data, make decisions, etc
 * 
 * 
 *  End-users play them, with contextual parameters
 * */
/**
 * User API for macro execution
 * 
 * Simple errors are reported as usual.
 * However, the macro execution verbs treat most errors in a particular way : instead of reporting errors on the usual &apos;error&apos; channel, errors are put in the returned &apos;MacroCompletion&apos; result.
 * This behavior can be tuned on a per-call basis with the hardFail parameter.
 * Note that some particular errors will always behave as if hardFail were true, because they are related to programming errors, or prevent processing from ending gracefully : STACK_OVERFLOW, NO_SUCH_FUNCTION, RAM_EXCEEDED, CYCLES_EXCEEDED, TIME_EXCEEDED, QUOTA_EXCEEDED, RATE_EXCEEDED, BAD_COMPARATOR_VALUE
 * @access public
 * */
export class MacroPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Plays a previously recorded macro
	 * 
	 * DO NOT use this verb from inside an enclosing macro when you need the result in order to proceed with the enclosing macro.
	 * You can override the default notification channel when defining the macro.
	 * */
	call({debug,hardFail,name,parameters}) { this.$publish(&apos;call&apos;, {debug,hardFail,name,parameters})}
	/**
	 * Plays a previously recorded macro and returns the result.
	 * 
	 * Use this verb when you want to synchronously call a macro from inside another macro.
	 * */
	func({}) { this.$publish(&apos;func&apos;, {})}
	/**
	 * Similar to func, with the ability to impersonate any user at will.
	 * 
	 * Use this verb when you do not want to use or cannot use the standard rights system and wish to bypass it completely.
	 * Use this verb sparingly, as it can give the caller any right on any resource.
	 * */
	sudo({}) { this.$publish(&apos;sudo&apos;, {})}
}
/**
 * Mail sender
 * 
 * Sends email through SMTP
 * */
/**
 * Mail service user API
 * 
 * This service is statically configured with an outgoing SMTP server.
 * Users call the API here to actually send emails.
 * @access public
 * */
export class SendmailPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Sends an email
	 * 
	 * Sends an email with the given body to the intended recipients.
	 * */
	send({}) { this.$publish(&apos;send&apos;, {})}
}
/**
 * Messaging service
 * 
 * Messaging service
 * */
/**
 * Messaging service
 * 
 * Simple and flexible user-to-user or user-to-group messaging service.
 * @access public
 * */
export class MessagingPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Sends a message to a target
	 * 
	 * Sends the given message to the specified target on the given (optional) channel.
	 * The administratively given default channel name is used when none is provided in the message itself.
	 * */
	send({target,channel,data}) { this.$publish(&apos;send&apos;, {target,channel,data})}
}
/**
 * Producer consumer
 * 
 * Producer consumer service
 *  Users can submit tasks and other users consume them
 * */
/**
 * Producer / consumer real-time API
 * 
 * Task producers submits their tasks.
 * The server dispatches the tasks.
 * Consumers process them and report completion back to the server.
 * Tasks are global to the service (i.e. NOT per user).
 * @access public
 * */
export class QueuePublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Submits a task
	 * 
	 * Producer API.
	 * A task producer submits the given task to the server.
	 * The server will find a tasker with processing capacity and dispatch the task.
	 * The task result will be returned to the caller.
	 * When called from inside a macro, the comsumer generated result is available for further use.
	 * */
	call({description,originBusinessId,originDeploymentId,data,owner}) { this.$publish(&apos;call&apos;, {description,originBusinessId,originDeploymentId,data,owner})}
	/**
	 * Notifies completion of a task
	 * 
	 * Consumer API.
	 * The tasker notifies completion of the given task to the server.
	 * The tasker can optionally include a result or an error code.
	 * */
	done({result,success,taskId}) { this.$publish(&apos;done&apos;, {result,success,taskId})}
	/**
	 * Registers a consumer
	 * 
	 * Consumer API.
	 * Registers the current user resource as an available task consumer.
	 * Tasks will be then dispatched to that consumer.
	 * */
	register({capacity}) { this.$publish(&apos;register&apos;, {capacity})}
	/**
	 * Submits a task
	 * 
	 * Producer API.
	 * A task producer submits the given task to the server.
	 * The server will find a tasker with processing capacity and dispatch the task.
	 * The task result will be ignored : the producer will not receive any notification of any kind, even in case of errors (including capacity exceeded errors).
	 * This verb will return immediately : you can use this API to asynchronously submit a task.
	 * */
	submit({description,originBusinessId,originDeploymentId,data,owner}) { this.$publish(&apos;submit&apos;, {description,originBusinessId,originDeploymentId,data,owner})}
	/**
	 * Unregisters a consumer
	 * 
	 * Consumer API.
	 * Unregisters the current user resource as an available task consumer.
	 * All non finished tasks are returned to the server.
	 * */
	unregister({}) { this.$publish(&apos;unregister&apos;, {})}
}
/**
 * SMS via OVH
 * 
 * SMS sender, to send text messages to mobile phones
 * This SMS sending service uses the OVH API
 * 
 * */
/**
 * SMS service
 * 
 * User API for SMS.
 * @access public
 * */
export class Sms_ovhPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Sends an SMS
	 * 
	 * Sends the given message to the given recipients.
	 * */
	send({}) { this.$publish(&apos;send&apos;, {})}
}
/**
 * Scheduler
 * 
 * Scheduler service
 *  End-users can schedule one-time or repetitive tasks using a classical cron syntax (with the year field) or a timestamp (milliseconds from the epoch)
 * */
/**
 * User API for the Scheduler
 * 
 * User endpoints for scheduling : users can schedule, list and delete tasks.
 * Tasks are stored on a per-user basis: a task will run with the priviledges of the user who stored it.
 * Tasks are run on the server and thus can call api verbs marked as server-only.
 * @access public
 * */
export class CronPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * List the configured tasks
	 * 
	 * Returns a paginated list of the asking user&apos;s tasks.
	 * */
	list({owner,page,start,stop}) { this.$publish(&apos;list&apos;, {owner,page,start,stop})}
	/**
	 * Schedules a task
	 * 
	 * Schedules a task for later execution.
	 * If a task already exists with the same cronName, this new task completely replaces it.
	 * A task can be scheduled with a cron-like syntax for repetitive or one-shot execution.
	 * Wildcards are not allowed for minutes and hours.
	 * When scheduling for one-shot execution, the time must be at least two minutes into the future.
	 * */
	schedule({}) { this.$publish(&apos;schedule&apos;, {})}
	/**
	 * Removes a scheduled task
	 * 
	 * Removes a previously scheduled task.
	 * Does absolutely nothing if asked to remove a non-existent task.
	 * */
	unschedule({cronName,owner}) { this.$publish(&apos;unschedule&apos;, {cronName,owner})}
}
/**
 * Search engine
 * 
 * ElasticSearch engine, to index and search data
 *  An admin creates indices
 *  Users index and search documents
 * 
 * */
/**
 * ElasticSearch Service
 * 
 * This API is a very thin wrapper around ElasticSearch&apos;s API.
 * @access public
 * */
export class SearchPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Deletes data
	 * 
	 * Deletes a document from the elasticsearch engine by id.
	 * */
	delete({id,index,type}) { this.$publish(&apos;delete&apos;, {id,index,type})}
	/**
	 * Gets data
	 * 
	 * Retrieves a document from the elasticsearch engine by id.
	 * */
	get({id,index,type}) { this.$publish(&apos;get&apos;, {id,index,type})}
	/**
	 * Indexes data
	 * 
	 * Inserts or updates a document into the elasticsearch engine.
	 * */
	index({data,id,index,type}) { this.$publish(&apos;index&apos;, {data,id,index,type})}
	/**Searches for data*/
	search({indices,page,query,sort}) { this.$publish(&apos;search&apos;, {indices,page,query,sort})}
}
/**
 * Template engine
 * 
 * Template engine to produce documents from parameterized templates
 * &lt;br&gt;An admin creates templates
 * &lt;br&gt; Users produce documents
 * &lt;br&gt;The implementation uses the &lt;a href=&apos;http://freemarker
 * org/&apos;&gt;freemarker&lt;/a&gt; engine
 * 
 * */
/**
 * User API for templates
 * 
 * Users use this API to evaluate pre-configured templates.
 * @access public
 * */
export class TemplatePublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Evaluates a template
	 * 
	 * Evaluates the given template and returns the result as a string.
	 * Templates are parsed the first time they are evaluated. Evaluation may fail early due to a parsing error.
	 * */
	evaluate({data,languageTag,name,requestId}) { this.$publish(&apos;evaluate&apos;, {data,languageTag,name,requestId})}
}
/**
 * Upload: S3
 * 
 * Upload service with S3 storage
 * */
/**
 * User API for file management
 * 
 * User API for virtual file management and http file upload
 * This API contains all the verbs needed to browse, upload and remove files.
 * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.
 * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.
 * @access public
 * */
export class Zpfs_s3PublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Copies a file
	 * 
	 * Copies a file or folder (recursively) to a new location.
	 * May fail if the target location is not empty.
	 * */
	cp({oldPath,owner,path}) { this.$publish(&apos;cp&apos;, {oldPath,owner,path})}
	/**
	 * Returns disk usage
	 * 
	 * Returns an recursively aggregated number of used bytes, starting at the given path.
	 * */
	du({owner,path}) { this.$publish(&apos;du&apos;, {owner,path})}
	/**Requests an upload URL without constraints.*/
	freeUploadUrl({}) { this.$publish(&apos;freeUploadUrl&apos;, {})}
	/**
	 * Links a file
	 * 
	 * Links a file or folder to another location.
	 * May fail if the target location is not empty.
	 * */
	link({oldPath,owner,path}) { this.$publish(&apos;link&apos;, {oldPath,owner,path})}
	/**
	 * Lists a folder content
	 * 
	 * Returns a paginated list of the folder&apos;s content.
	 * */
	ls({folder,owner,page}) { this.$publish(&apos;ls&apos;, {folder,owner,page})}
	/**
	 * Creates a folder
	 * 
	 * Creates a new folder.
	 * May fail if the target location is not empty.
	 * */
	mkdir({folder,owner,parents}) { this.$publish(&apos;mkdir&apos;, {folder,owner,parents})}
	/**
	 * Moves a file
	 * 
	 * Moves a file or folder (recursively) to a new location.
	 * May fail if the target location is not empty.
	 * */
	mv({oldPath,owner,path}) { this.$publish(&apos;mv&apos;, {oldPath,owner,path})}
	/**
	 * Notifies of upload completion
	 * 
	 * The client application calls this verb to notify that it&apos;s done uploading to the cloud.
	 * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.
	 * */
	newFile({guid,metadata,owner,tags}) { this.$publish(&apos;newFile&apos;, {guid,metadata,owner,tags})}
	/**
	 * Requests an upload URL
	 * 
	 * Requests an HTTP upload URL.
	 * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.
	 * */
	newUploadUrl({contentType,owner,path}) { this.$publish(&apos;newUploadUrl&apos;, {contentType,owner,path})}
	/**
	 * Removes a file
	 * 
	 * Removes a file or folder (recursively).
	 * */
	rm({owner,path}) { this.$publish(&apos;rm&apos;, {owner,path})}
	/**
	 * Returns information about a file
	 * 
	 * Returns information about a single file.
	 * The entry field will be null if the path does not exist
	 * */
	stat({owner,path}) { this.$publish(&apos;stat&apos;, {owner,path})}
	/**Updates a file&apos;s metadata*/
	updateMeta({metadata,metadataFiles,owner,path}) { this.$publish(&apos;updateMeta&apos;, {metadata,metadataFiles,owner,path})}
}
/**
 * Upload: local
 * 
 * Upload service with local HDFS storage
 * */
/**
 * User API for file management
 * 
 * User API for virtual file management and http file upload
 * This API contains all the verbs needed to browse, upload and remove files.
 * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.
 * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.
 * @access public
 * */
export class Zpfs_hdfsPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Copies a file
	 * 
	 * Copies a file or folder (recursively) to a new location.
	 * May fail if the target location is not empty.
	 * */
	cp({oldPath,owner,path}) { this.$publish(&apos;cp&apos;, {oldPath,owner,path})}
	/**
	 * Returns disk usage
	 * 
	 * Returns an recursively aggregated number of used bytes, starting at the given path.
	 * */
	du({owner,path}) { this.$publish(&apos;du&apos;, {owner,path})}
	/**Requests an upload URL without constraints.*/
	freeUploadUrl({}) { this.$publish(&apos;freeUploadUrl&apos;, {})}
	/**
	 * Links a file
	 * 
	 * Links a file or folder to another location.
	 * May fail if the target location is not empty.
	 * */
	link({oldPath,owner,path}) { this.$publish(&apos;link&apos;, {oldPath,owner,path})}
	/**
	 * Lists a folder content
	 * 
	 * Returns a paginated list of the folder&apos;s content.
	 * */
	ls({folder,owner,page}) { this.$publish(&apos;ls&apos;, {folder,owner,page})}
	/**
	 * Creates a folder
	 * 
	 * Creates a new folder.
	 * May fail if the target location is not empty.
	 * */
	mkdir({folder,owner,parents}) { this.$publish(&apos;mkdir&apos;, {folder,owner,parents})}
	/**
	 * Moves a file
	 * 
	 * Moves a file or folder (recursively) to a new location.
	 * May fail if the target location is not empty.
	 * */
	mv({oldPath,owner,path}) { this.$publish(&apos;mv&apos;, {oldPath,owner,path})}
	/**
	 * Notifies of upload completion
	 * 
	 * The client application calls this verb to notify that it&apos;s done uploading to the cloud.
	 * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.
	 * */
	newFile({guid,metadata,owner,tags}) { this.$publish(&apos;newFile&apos;, {guid,metadata,owner,tags})}
	/**
	 * Requests an upload URL
	 * 
	 * Requests an HTTP upload URL.
	 * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.
	 * */
	newUploadUrl({contentType,owner,path}) { this.$publish(&apos;newUploadUrl&apos;, {contentType,owner,path})}
	/**
	 * Removes a file
	 * 
	 * Removes a file or folder (recursively).
	 * */
	rm({owner,path}) { this.$publish(&apos;rm&apos;, {owner,path})}
	/**
	 * Returns information about a file
	 * 
	 * Returns information about a single file.
	 * The entry field will be null if the path does not exist
	 * */
	stat({owner,path}) { this.$publish(&apos;stat&apos;, {owner,path})}
	/**Updates a file&apos;s metadata*/
	updateMeta({metadata,metadataFiles,owner,path}) { this.$publish(&apos;updateMeta&apos;, {metadata,metadataFiles,owner,path})}
}
/**
 * Upload: pseudo-S3
 * 
 * Upload service with pseudo-S3compatible storage
 * */
/**
 * User API for file management
 * 
 * User API for virtual file management and http file upload
 * This API contains all the verbs needed to browse, upload and remove files.
 * Files are stored on a per-user basis: each user has his or her own whole virtual filesystem.
 * Uploading a file is a 3-step process : request an upload URL, upload via HTTP, notify this service of completion.
 * @access public
 * */
export class Zpfs_s3compatPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Copies a file
	 * 
	 * Copies a file or folder (recursively) to a new location.
	 * May fail if the target location is not empty.
	 * */
	cp({oldPath,owner,path}) { this.$publish(&apos;cp&apos;, {oldPath,owner,path})}
	/**
	 * Returns disk usage
	 * 
	 * Returns an recursively aggregated number of used bytes, starting at the given path.
	 * */
	du({owner,path}) { this.$publish(&apos;du&apos;, {owner,path})}
	/**Requests an upload URL without constraints.*/
	freeUploadUrl({}) { this.$publish(&apos;freeUploadUrl&apos;, {})}
	/**
	 * Links a file
	 * 
	 * Links a file or folder to another location.
	 * May fail if the target location is not empty.
	 * */
	link({oldPath,owner,path}) { this.$publish(&apos;link&apos;, {oldPath,owner,path})}
	/**
	 * Lists a folder content
	 * 
	 * Returns a paginated list of the folder&apos;s content.
	 * */
	ls({folder,owner,page}) { this.$publish(&apos;ls&apos;, {folder,owner,page})}
	/**
	 * Creates a folder
	 * 
	 * Creates a new folder.
	 * May fail if the target location is not empty.
	 * */
	mkdir({folder,owner,parents}) { this.$publish(&apos;mkdir&apos;, {folder,owner,parents})}
	/**
	 * Moves a file
	 * 
	 * Moves a file or folder (recursively) to a new location.
	 * May fail if the target location is not empty.
	 * */
	mv({oldPath,owner,path}) { this.$publish(&apos;mv&apos;, {oldPath,owner,path})}
	/**
	 * Notifies of upload completion
	 * 
	 * The client application calls this verb to notify that it&apos;s done uploading to the cloud.
	 * Calling that verb MAY trigger additional events such as thumbnail/metadata creation.
	 * */
	newFile({guid,metadata,owner,tags}) { this.$publish(&apos;newFile&apos;, {guid,metadata,owner,tags})}
	/**
	 * Requests an upload URL
	 * 
	 * Requests an HTTP upload URL.
	 * The URL contains temporary credentials (typically valid for a few minutes) and is meant for immediate use.
	 * */
	newUploadUrl({contentType,owner,path}) { this.$publish(&apos;newUploadUrl&apos;, {contentType,owner,path})}
	/**
	 * Removes a file
	 * 
	 * Removes a file or folder (recursively).
	 * */
	rm({owner,path}) { this.$publish(&apos;rm&apos;, {owner,path})}
	/**
	 * Returns information about a file
	 * 
	 * Returns information about a single file.
	 * The entry field will be null if the path does not exist
	 * */
	stat({owner,path}) { this.$publish(&apos;stat&apos;, {owner,path})}
	/**Updates a file&apos;s metadata*/
	updateMeta({metadata,metadataFiles,owner,path}) { this.$publish(&apos;updateMeta&apos;, {metadata,metadataFiles,owner,path})}
}
/**
 * User directory service
 * 
 * User directory service
 * */
/**
 * User API for user information
 * 
 * @access public
 * */
export class UserdirPublisherDefinition extends AbstractPublisherDefinition {
	/**Searches for users matching the request*/
	search({page,query,requestId}) { this.$publish(&apos;search&apos;, {page,query,requestId})}
	/**Requests public data for the specified users*/
	userInfo({userKeys}) { this.$publish(&apos;userInfo&apos;, {userKeys})}
}
/**
 * Delegating authentication
 * 
 * This authentication delegates authentication to an external auth provider
 * &lt;br&gt;When a zetapush client handshakes with a delegated authentication, the &apos;token&apos; field given by the client is sent to the configured remote server as part of the URL
 * &lt;br&gt;The response must be in JSON format
 *  Each key of the response will be considered a user information field name
 * 
 * */
/**
 * End-user API for the delegating authentication
 * 
 * Provisionning verbs.
 * @access public
 * */
export class DelegatingPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Get user info
	 * 
	 * Retrieves cached user info or (if missing) eagerly creates a zetapush key for the user.
	 * The returned field &apos;zetapushKey&apos; is a unique and permanent ID identifying a user in a sandbox.
	 * */
	userInfo({}) { this.$publish(&apos;userInfo&apos;, {})}
}
/**
 * Local authentication
 * 
 * Zetapush local authentication
 *  The configurer can choose the primary key and mandatory user fields for account creation
 *  The field &apos;zetapushKey&apos; is generated by the server and MUST not be used : it contains the unique key of the user inside a sandbox (it can be obtained from inside a macro with the &lt;b&gt;__userKey&lt;/b&gt; pseudo-constant)
 * */
/**
 * End-user API for the simple local authentication
 * 
 * These API verbs allow end-users to manage their account.
 * @access public
 * */
export class SimplePublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Changes a password
	 * 
	 * Changes a user password for this authentication realm.
	 * The user can be either implicit (the current user) or deduced from the token.
	 * The change is effective immediately. However, already logged in users might stay connected.
	 * */
	changePassword({}) { this.$publish(&apos;changePassword&apos;, {})}
	/**
	 * Checks some account&apos;s existence
	 * 
	 * Checks whether the given user already exists in this &apos;simple&apos; authentication realm.
	 * */
	checkUser({}) { this.$publish(&apos;checkUser&apos;, {})}
	/**
	 * Creates a user
	 * 
	 * Creates a new user in this &apos;simple&apos; authentication realm.
	 * */
	createUser({}) { this.$publish(&apos;createUser&apos;, {})}
	/**
	 * Deletes a user
	 * 
	 * Deletes an existing user in this &apos;simple&apos; authentication realm.
	 * */
	deleteUser({}) { this.$publish(&apos;deleteUser&apos;, {})}
	/**
	 * Requests a password reset
	 * 
	 * Requests a password reset for the given unique key.
	 * The key must exist and must be given, as it cannot obviously be deduced from the currently logged in user.
	 * The returned token needs to be sent to the intended recipient only. The typical use case is to define a macro that requests a reset, generates a email template and emails the user. The macro can then be safely called by a weakly authenticated user.
	 * Requesting a reset does not invalidate the password.
	 * Requesting a reset again invalidates previous reset requests (only the last token is usable)
	 * */
	requestReset({}) { this.$publish(&apos;requestReset&apos;, {})}
	/**
	 * Updates a user
	 * 
	 * Updates an existing user in this &apos;simple&apos; authentication realm.
	 * */
	updateUser({}) { this.$publish(&apos;updateUser&apos;, {})}
}
/**
 * Weak authentication
 * 
 * The weak authentication allows for anonymous authentication of devices
 *  Such devices can display a qrcode to allow regular users to take control of them
 * */
/**
 * User API for weak devices control
 * 
 * User API for control and release of weakly authenticated user sessions.
 * @access public
 * */
export class WeakPublisherDefinition extends AbstractPublisherDefinition {
	/**
	 * Controls a session
	 * 
	 * Takes control of a weak user session, identified by the given public token.
	 * The public token has been previously made available by the controlled device, for example by displaying a QRCode.
	 * Upon control notification, the client SDK of the controlled session is expected to re-handshake.
	 * */
	control({fullRights,publicToken}) { this.$publish(&apos;control&apos;, {fullRights,publicToken})}
	/**
	 * Releases a session
	 * 
	 * Releases control of a weak user session, identified by the given public token.
	 * The weak user session must have been previously controlled by a call to &apos;control&apos;.
	 * */
	release({fullRights,publicToken}) { this.$publish(&apos;release&apos;, {fullRights,publicToken})}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
